/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	
	var view = __webpack_require__(5);
	var MainMenu = __webpack_require__(10);
	var FreeplayMenu = __webpack_require__(15);
	var PuzzleMenu = __webpack_require__(19);
	var MapEditor = __webpack_require__(20);
	var GameGui = __webpack_require__(23);
	var attachFastClick = __webpack_require__(29);
	
	var currentView = new MainMenu(function (data) {
	  return onDone(data);
	});
	
	function onDone(data) {
	  currentView.dispose();
	  view.reset();
	
	  switch (data.view) {
	    case 'Main menu':
	      currentView = new MainMenu(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	    case 'Puzzle menu':
	      currentView = new PuzzleMenu(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	    case 'Freeplay menu':
	      currentView = new FreeplayMenu(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	    case 'Create map':
	      currentView = new MapEditor(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	    case 'Game':
	      currentView = new GameGui(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	    default:
	      currentView = new FreeplayMenu(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	  }
	}
	
	window.addEventListener('load', function () {
	  attachFastClick.attach(document.body);
	}, false);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./app.css", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./app.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "* {\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: monospace;\n  background-color: black;\n  -webkit-user-select: none;\n  -ms-touch-action: none;\n      touch-action: none;\n  -webkit-user-drag: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  margin: 0;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  overflow: hidden;\n}\n\nbody:before{\n  display: block;\n  content: \" \";\n  height: 20px;\n  top: 0;\n  background:rgba(0,0,0,0.8);\n  position:-webkit-sticky;\n  position:sticky;\n}\n\n.menu {\n  visibility: hidden;\n  position: absolute;\n  left: 0;\n  right: 0;\n  color: white;\n}\n\n.infoText {\n  text-align: center;\n  font-size: 1.2vw;\n}\n\n.button {\n  background-color: black;\n  color: teal;\n  padding: 0.3em 0.5em;\n  border-radius: 3px;\n  border: 1px solid white;\n  cursor: pointer;\n  position: relative;\n  text-align: center;\n  display: inline-block;\n}\n\n.button:after, .button > * {\n  margin: 0;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  margin-right: -50%;\n  -webkit-transform: translate(-50%, -50%);\n      -ms-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n\n.minusButton:after {\n  content: \"-\";\n}\n\n.plusButton:after {\n    content: \"+\";\n}\n.button.purple {\n  color: purple;\n  border-color: purple;\n}\n\n.button.green {\n  color: green;\n  border-color: green;\n}\n\n.button.yellow {\n  color: yellow;\n  border-color: yellow;\n}\n\n.button.selected {\n  color: white;\n}\n\n.button.disabled {\n  color: gray;\n  border-color: gray;\n}\n\n\n\n.menuClickZone {\n  position: absolute;\n  width: 30vw;\n}\n\n.menuClickZone-topLeft{\n  top: -10px;\n  left: -10px;\n}\n\n.menuClickZone-topRight{\n  top: -10px;\n  right: -10px;\n  -webkit-transform: rotate(0.25turn);\n      -ms-transform: rotate(0.25turn);\n          transform: rotate(0.25turn);\n}\n\n.menuClickZone-enabled .icon{\n  opacity: 1;\n}\n\n.menuBottom{\n  position: absolute;\n  bottom: -10px;\n  width: 100%;\n  height: 70vw;\n}\n\n.menuBottomArea{\n  height: 100%;\n  width: 100%;\n}\n\n.menuElement{\n  position: absolute;\n  fill: rgba(0, 128, 128, 0.2);\n  stroke: white;\n  stroke-width: 2;\n  vector-effect: non-scaling-stroke;\n}\n\n.icon{\n  opacity: 0.1;\n}\n\n.icon path{\n  vector-effect: non-scaling-stroke;\n  fill: white;\n}\n\n.icon-top{\n  position: absolute;\n  left: 3vw;\n  top: 3vw;\n  width: 6vw;\n}\n\n.svgMenu {\n  pointer-events: none;\n}\n\n.svgMenu svg > * {\n  pointer-events: auto;\n}\n", ""]);
	
	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.setView = setView;
	exports.reset = reset;
	exports.addCourse = addCourse;
	exports.toggleStarsVisibility = toggleStarsVisibility;
	var Paper = __webpack_require__(6);
	var changeCenter = __webpack_require__(7).changeCenter;
	var changeZoom = __webpack_require__(7).changeZoom;
	var animation = __webpack_require__(8);
	var storage = __webpack_require__(9);
	
	var canvas = document.getElementById('canvas');
	canvas.setAttribute('keepalive', true);
	
	var width = document.body.clientWidth;
	var height = document.body.clientHeight;
	
	initPaper(canvas, width, height);
	
	var outerBounds = new Paper.Rectangle(0, 0, width, height);
	
	var course = new Paper.Group(createGrid(outerBounds));
	course.clipped = true;
	
	var initialBounds = Paper.view.bounds.clone();
	
	Paper.view.draw();
	
	function setView(bounds) {
	  if (isSameBounds(Paper.view.bounds, bounds)) return;
	  var aspectRatio = width / height;
	  var size = bounds.size.clone();
	  var newRatio = size.width / size.height;
	  if (newRatio !== aspectRatio) {
	    if (newRatio < aspectRatio) {
	      size.width = size.width * aspectRatio / newRatio;
	    } else {
	      size.height = size.height * newRatio / aspectRatio;
	    }
	  }
	  var newZoom = Paper.view.viewSize.width / size.width;
	  newZoom = newZoom > 1 ? newZoom : 1;
	  animateView(bounds.center, newZoom);
	  Paper.view.draw();
	}
	
	function reset() {
	  setView(initialBounds);
	}
	
	function addCourse(element) {
	  course.appendBottom(element);
	}
	
	function initPaper(canvas, width, height) {
	  canvas.setAttribute('width', width);
	  canvas.setAttribute('height', height);
	  Paper.setup(canvas);
	  animation.init();
	}
	
	function createGrid(viewBounds) {
	  var grid = new Paper.Group();
	  for (var x = viewBounds.left; x < viewBounds.right; x += 20) {
	    var line = new Paper.Path.Rectangle(new Paper.Point(x - 0.5, viewBounds.top), new Paper.Point(x + 0.5, Paper.view.bounds.bottom));
	    line.fillColor = 'white';
	
	    grid.addChild(line);
	  }
	  for (var y = viewBounds.top; y < viewBounds.bottom; y += 20) {
	    var line = new Paper.Path.Rectangle(new Paper.Point(viewBounds.left, y), new Paper.Point(Paper.view.bounds.right, y + 1));
	    line.fillColor = 'white';
	
	    grid.addChild(line);
	  }
	
	  return grid;
	}
	
	function isSameBounds(view1, view2) {
	  var diff = view1.center.subtract(view2.center).length;
	  return diff < 1;
	}
	
	function animateView(center, zoom) {
	  var animationDuration = 0.3;
	  var startCenter = Paper.view.center.clone();
	  var deltaCenter = center.clone().subtract(startCenter);
	  var startZoom = Paper.view.zoom;
	  var deltaZoom = zoom - startZoom;
	  animation.add(function (elapsedTime) {
	    if (elapsedTime > animationDuration) {
	      Paper.view.center = center;
	      Paper.view.zoom = zoom;
	      return false;
	    } else {
	      var easeValue = elapsedTime / animationDuration;
	      var dtCenter = deltaCenter.multiply(easeValue);
	      Paper.view.center = startCenter.add(dtCenter);
	      var dtZoom = deltaZoom * easeValue;
	      Paper.view.zoom = startZoom + dtZoom;
	    }
	  });
	}
	
	var stars = [];
	
	createStars();
	if (storage.GetEnableStars()) {
	  enableStars();
	} else {
	  disableStars();
	}
	
	function createStars() {
	  for (var i = 0; i < 100; i++) {
	    var star = createStar();
	    stars.push(star);
	  }
	}
	
	function enableStars() {
	  stars.forEach(function (star) {
	    star.circle.visible = true;
	    star.animationRemover = animation.add(star.animation);
	  });
	}
	
	function disableStars() {
	  stars.forEach(function (star) {
	    star.circle.visible = false;
	    if (star.animationRemover) {
	      star.animationRemover.remove();
	    }
	  });
	}
	
	function toggleStarsVisibility() {
	  var starsEnabled = !storage.GetEnableStars();
	  storage.SetEnableStars(starsEnabled);
	
	  if (starsEnabled) {
	    enableStars();
	  } else {
	    disableStars();
	  }
	
	  return starsEnabled;
	}
	
	function createStar() {
	  // a random position anywhere in space
	  var start = new Paper.Point.random().multiply(outerBounds.bottomRight);
	
	  // distance from earth in pixels
	  var distance = 4 + Math.random() * 11;
	
	  var circle = new Paper.Path.Circle(start, 5 / distance);
	  circle.fillColor = 'white';
	  circle.position = start;
	
	  // the speed of a star is lower if its far away. this is known science fact.
	  var velocity = new Paper.Point(10 / distance, 0);
	
	  return {
	    circle: circle,
	    velocity: velocity,
	    animation: function animation(elapsedTime) {
	      circle.position = circle.position.add(velocity);
	      if (!outerBounds.contains(circle.position)) {
	        circle.position.x = 0;
	      }
	    }
	  };
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Paper.js v0.9.25 - The Swiss Army Knife of Vector Graphics Scripting.
	 * http://paperjs.org/
	 *
	 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
	 * http://scratchdisk.com/ & http://jonathanpuckey.com/
	 *
	 * Distributed under the MIT license. See LICENSE file for details.
	 *
	 * All rights reserved.
	 *
	 * Date: Sun Oct 25 11:23:38 2015 +0100
	 *
	 ***
	 *
	 * Straps.js - Class inheritance library with support for bean-style accessors
	 *
	 * Copyright (c) 2006 - 2013 Juerg Lehni
	 * http://scratchdisk.com/
	 *
	 * Distributed under the MIT license.
	 *
	 ***
	 *
	 * Acorn.js
	 * http://marijnhaverbeke.nl/acorn/
	 *
	 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
	 * created by Marijn Haverbeke and released under an MIT license.
	 *
	 */
	
	var paper = new function(undefined) {
	
	var Base = new function() {
		var hidden = /^(statics|enumerable|beans|preserve)$/,
	
			forEach = [].forEach || function(iter, bind) {
				for (var i = 0, l = this.length; i < l; i++)
					iter.call(bind, this[i], i, this);
			},
	
			forIn = function(iter, bind) {
				for (var i in this)
					if (this.hasOwnProperty(i))
						iter.call(bind, this[i], i, this);
			},
	
			create = Object.create || function(proto) {
				return { __proto__: proto };
			},
	
			describe = Object.getOwnPropertyDescriptor || function(obj, name) {
				var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
				return get
						? { get: get, set: obj.__lookupSetter__(name),
							enumerable: true, configurable: true }
						: obj.hasOwnProperty(name)
							? { value: obj[name], enumerable: true,
								configurable: true, writable: true }
							: null;
			},
	
			_define = Object.defineProperty || function(obj, name, desc) {
				if ((desc.get || desc.set) && obj.__defineGetter__) {
					if (desc.get)
						obj.__defineGetter__(name, desc.get);
					if (desc.set)
						obj.__defineSetter__(name, desc.set);
				} else {
					obj[name] = desc.value;
				}
				return obj;
			},
	
			define = function(obj, name, desc) {
				delete obj[name];
				return _define(obj, name, desc);
			};
	
		function inject(dest, src, enumerable, beans, preserve) {
			var beansNames = {};
	
			function field(name, val) {
				val = val || (val = describe(src, name))
						&& (val.get ? val : val.value);
				if (typeof val === 'string' && val[0] === '#')
					val = dest[val.substring(1)] || val;
				var isFunc = typeof val === 'function',
					res = val,
					prev = preserve || isFunc && !val.base
							? (val && val.get ? name in dest : dest[name])
							: null,
					bean;
				if (!preserve || !prev) {
					if (isFunc && prev)
						val.base = prev;
					if (isFunc && beans !== false
							&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
						beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
					if (!res || isFunc || !res.get || typeof res.get !== 'function'
							|| !Base.isPlainObject(res))
						res = { value: res, writable: true };
					if ((describe(dest, name)
							|| { configurable: true }).configurable) {
						res.configurable = true;
						res.enumerable = enumerable;
					}
					define(dest, name, res);
				}
			}
			if (src) {
				for (var name in src) {
					if (src.hasOwnProperty(name) && !hidden.test(name))
						field(name);
				}
				for (var name in beansNames) {
					var part = beansNames[name],
						set = dest['set' + part],
						get = dest['get' + part] || set && dest['is' + part];
					if (get && (beans === true || get.length === 0))
						field(name, { get: get, set: set });
				}
			}
			return dest;
		}
	
		function each(obj, iter, bind) {
			if (obj)
				('length' in obj && !obj.getLength
						&& typeof obj.length === 'number'
					? forEach
					: forIn).call(obj, iter, bind = bind || obj);
			return bind;
		}
	
		function set(obj, props, exclude) {
			for (var key in props)
				if (props.hasOwnProperty(key) && !(exclude && exclude[key]))
					obj[key] = props[key];
			return obj;
		}
	
		return inject(function Base() {
			for (var i = 0, l = arguments.length; i < l; i++)
				set(this, arguments[i]);
		}, {
			inject: function(src) {
				if (src) {
					var statics = src.statics === true ? src : src.statics,
						beans = src.beans,
						preserve = src.preserve;
					if (statics !== src)
						inject(this.prototype, src, src.enumerable, beans, preserve);
					inject(this, statics, true, beans, preserve);
				}
				for (var i = 1, l = arguments.length; i < l; i++)
					this.inject(arguments[i]);
				return this;
			},
	
			extend: function() {
				var base = this,
					ctor,
					proto;
				for (var i = 0, l = arguments.length; i < l; i++)
					if (ctor = arguments[i].initialize)
						break;
				ctor = ctor || function() {
					base.apply(this, arguments);
				};
				proto = ctor.prototype = create(this.prototype);
				define(proto, 'constructor',
						{ value: ctor, writable: true, configurable: true });
				inject(ctor, this, true);
				if (arguments.length)
					this.inject.apply(ctor, arguments);
				ctor.base = base;
				return ctor;
			}
		}, true).inject({
			inject: function() {
				for (var i = 0, l = arguments.length; i < l; i++) {
					var src = arguments[i];
					if (src)
						inject(this, src, src.enumerable, src.beans, src.preserve);
				}
				return this;
			},
	
			extend: function() {
				var res = create(this);
				return res.inject.apply(res, arguments);
			},
	
			each: function(iter, bind) {
				return each(this, iter, bind);
			},
	
			set: function(props) {
				return set(this, props);
			},
	
			clone: function() {
				return new this.constructor(this);
			},
	
			statics: {
				each: each,
				create: create,
				define: define,
				describe: describe,
				set: set,
	
				clone: function(obj) {
					return set(new obj.constructor(), obj);
				},
	
				isPlainObject: function(obj) {
					var ctor = obj != null && obj.constructor;
					return ctor && (ctor === Object || ctor === Base
							|| ctor.name === 'Object');
				},
	
				pick: function(a, b) {
					return a !== undefined ? a : b;
				}
			}
		});
	};
	
	if (true)
		module.exports = Base;
	
	Base.inject({
		toString: function() {
			return this._id != null
				?  (this._class || 'Object') + (this._name
					? " '" + this._name + "'"
					: ' @' + this._id)
				: '{ ' + Base.each(this, function(value, key) {
					if (!/^_/.test(key)) {
						var type = typeof value;
						this.push(key + ': ' + (type === 'number'
								? Formatter.instance.number(value)
								: type === 'string' ? "'" + value + "'" : value));
					}
				}, []).join(', ') + ' }';
		},
	
		getClassName: function() {
			return this._class || '';
		},
	
		exportJSON: function(options) {
			return Base.exportJSON(this, options);
		},
	
		toJSON: function() {
			return Base.serialize(this);
		},
	
		_set: function(props, exclude, dontCheck) {
			if (props && (dontCheck || Base.isPlainObject(props))) {
				var keys = Object.keys(props._filtering || props);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					if (!(exclude && exclude[key])) {
						var value = props[key];
						if (value !== undefined)
							this[key] = value;
					}
				}
				return true;
			}
		},
	
		statics: {
	
			exports: {
				enumerable: true
			},
	
			extend: function extend() {
				var res = extend.base.apply(this, arguments),
					name = res.prototype._class;
				if (name && !Base.exports[name])
					Base.exports[name] = res;
				return res;
			},
	
			equals: function(obj1, obj2) {
				if (obj1 === obj2)
					return true;
				if (obj1 && obj1.equals)
					return obj1.equals(obj2);
				if (obj2 && obj2.equals)
					return obj2.equals(obj1);
				if (obj1 && obj2
						&& typeof obj1 === 'object' && typeof obj2 === 'object') {
					if (Array.isArray(obj1) && Array.isArray(obj2)) {
						var length = obj1.length;
						if (length !== obj2.length)
							return false;
						while (length--) {
							if (!Base.equals(obj1[length], obj2[length]))
								return false;
						}
					} else {
						var keys = Object.keys(obj1),
							length = keys.length;
						if (length !== Object.keys(obj2).length)
							return false;
						while (length--) {
							var key = keys[length];
							if (!(obj2.hasOwnProperty(key)
									&& Base.equals(obj1[key], obj2[key])))
								return false;
						}
					}
					return true;
				}
				return false;
			},
	
			read: function(list, start, options, length) {
				if (this === Base) {
					var value = this.peek(list, start);
					list.__index++;
					return value;
				}
				var proto = this.prototype,
					readIndex = proto._readIndex,
					index = start || readIndex && list.__index || 0;
				if (!length)
					length = list.length - index;
				var obj = list[index];
				if (obj instanceof this
					|| options && options.readNull && obj == null && length <= 1) {
					if (readIndex)
						list.__index = index + 1;
					return obj && options && options.clone ? obj.clone() : obj;
				}
				obj = Base.create(this.prototype);
				if (readIndex)
					obj.__read = true;
				obj = obj.initialize.apply(obj, index > 0 || length < list.length
					? Array.prototype.slice.call(list, index, index + length)
					: list) || obj;
				if (readIndex) {
					list.__index = index + obj.__read;
					obj.__read = undefined;
				}
				return obj;
			},
	
			peek: function(list, start) {
				return list[list.__index = start || list.__index || 0];
			},
	
			remain: function(list) {
				return list.length - (list.__index || 0);
			},
	
			readAll: function(list, start, options) {
				var res = [],
					entry;
				for (var i = start || 0, l = list.length; i < l; i++) {
					res.push(Array.isArray(entry = list[i])
							? this.read(entry, 0, options)
							: this.read(list, i, options, 1));
				}
				return res;
			},
	
			readNamed: function(list, name, start, options, length) {
				var value = this.getNamed(list, name),
					hasObject = value !== undefined;
				if (hasObject) {
					var filtered = list._filtered;
					if (!filtered) {
						filtered = list._filtered = Base.create(list[0]);
						filtered._filtering = list[0];
					}
					filtered[name] = undefined;
				}
				return this.read(hasObject ? [value] : list, start, options, length);
			},
	
			getNamed: function(list, name) {
				var arg = list[0];
				if (list._hasObject === undefined)
					list._hasObject = list.length === 1 && Base.isPlainObject(arg);
				if (list._hasObject)
					return name ? arg[name] : list._filtered || arg;
			},
	
			hasNamed: function(list, name) {
				return !!this.getNamed(list, name);
			},
	
			isPlainValue: function(obj, asString) {
				return this.isPlainObject(obj) || Array.isArray(obj)
						|| asString && typeof obj === 'string';
			},
	
			serialize: function(obj, options, compact, dictionary) {
				options = options || {};
	
				var root = !dictionary,
					res;
				if (root) {
					options.formatter = new Formatter(options.precision);
					dictionary = {
						length: 0,
						definitions: {},
						references: {},
						add: function(item, create) {
							var id = '#' + item._id,
								ref = this.references[id];
							if (!ref) {
								this.length++;
								var res = create.call(item),
									name = item._class;
								if (name && res[0] !== name)
									res.unshift(name);
								this.definitions[id] = res;
								ref = this.references[id] = [id];
							}
							return ref;
						}
					};
				}
				if (obj && obj._serialize) {
					res = obj._serialize(options, dictionary);
					var name = obj._class;
					if (name && !compact && !res._compact && res[0] !== name)
						res.unshift(name);
				} else if (Array.isArray(obj)) {
					res = [];
					for (var i = 0, l = obj.length; i < l; i++)
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
					if (compact)
						res._compact = true;
				} else if (Base.isPlainObject(obj)) {
					res = {};
					var keys = Object.keys(obj);
					for (var i = 0, l = keys.length; i < l; i++) {
						var key = keys[i];
						res[key] = Base.serialize(obj[key], options, compact,
								dictionary);
					}
				} else if (typeof obj === 'number') {
					res = options.formatter.number(obj, options.precision);
				} else {
					res = obj;
				}
				return root && dictionary.length > 0
						? [['dictionary', dictionary.definitions], res]
						: res;
			},
	
			deserialize: function(json, create, _data, _isDictionary) {
				var res = json,
					isRoot = !_data;
				_data = _data || {};
				if (Array.isArray(json)) {
					var type = json[0],
						isDictionary = type === 'dictionary';
					if (json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
					res = [];
					if (_isDictionary)
						_data.dictionary = res;
					for (var i = type ? 1 : 0, l = json.length; i < l; i++)
						res.push(Base.deserialize(json[i], create, _data,
								isDictionary));
					if (type) {
						var args = res;
						if (create) {
							res = create(type, args);
						} else {
							res = Base.create(type.prototype);
							type.apply(res, args);
						}
					}
				} else if (Base.isPlainObject(json)) {
					res = {};
					if (_isDictionary)
						_data.dictionary = res;
					for (var key in json)
						res[key] = Base.deserialize(json[key], create, _data);
				}
				return isRoot && json && json.length && json[0][0] === 'dictionary'
						? res[1]
						: res;
			},
	
			exportJSON: function(obj, options) {
				var json = Base.serialize(obj, options);
				return options && options.asString === false
						? json
						: JSON.stringify(json);
			},
	
			importJSON: function(json, target) {
				return Base.deserialize(
						typeof json === 'string' ? JSON.parse(json) : json,
						function(type, args) {
							var obj = target && target.constructor === type
									? target
									: Base.create(type.prototype),
								isTarget = obj === target;
							if (args.length === 1 && obj instanceof Item
									&& (isTarget || !(obj instanceof Layer))) {
								var arg = args[0];
								if (Base.isPlainObject(arg))
									arg.insert = false;
							}
							type.apply(obj, args);
							if (isTarget)
								target = null;
							return obj;
						});
			},
	
			splice: function(list, items, index, remove) {
				var amount = items && items.length,
					append = index === undefined;
				index = append ? list.length : index;
				if (index > list.length)
					index = list.length;
				for (var i = 0; i < amount; i++)
					items[i]._index = index + i;
				if (append) {
					list.push.apply(list, items);
					return [];
				} else {
					var args = [index, remove];
					if (items)
						args.push.apply(args, items);
					var removed = list.splice.apply(list, args);
					for (var i = 0, l = removed.length; i < l; i++)
						removed[i]._index = undefined;
					for (var i = index + amount, l = list.length; i < l; i++)
						list[i]._index = i;
					return removed;
				}
			},
	
			capitalize: function(str) {
				return str.replace(/\b[a-z]/g, function(match) {
					return match.toUpperCase();
				});
			},
	
			camelize: function(str) {
				return str.replace(/-(.)/g, function(all, chr) {
					return chr.toUpperCase();
				});
			},
	
			hyphenate: function(str) {
				return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
			}
		}
	});
	
	var Emitter = {
		on: function(type, func) {
			if (typeof type !== 'string') {
				Base.each(type, function(value, key) {
					this.on(key, value);
				}, this);
			} else {
				var types = this._eventTypes,
					entry = types && types[type],
					handlers = this._callbacks = this._callbacks || {};
				handlers = handlers[type] = handlers[type] || [];
				if (handlers.indexOf(func) === -1) {
					handlers.push(func);
					if (entry && entry.install && handlers.length === 1)
						entry.install.call(this, type);
				}
			}
			return this;
		},
	
		off: function(type, func) {
			if (typeof type !== 'string') {
				Base.each(type, function(value, key) {
					this.off(key, value);
				}, this);
				return;
			}
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks && this._callbacks[type],
				index;
			if (handlers) {
				if (!func || (index = handlers.indexOf(func)) !== -1
						&& handlers.length === 1) {
					if (entry && entry.uninstall)
						entry.uninstall.call(this, type);
					delete this._callbacks[type];
				} else if (index !== -1) {
					handlers.splice(index, 1);
				}
			}
			return this;
		},
	
		once: function(type, func) {
			return this.on(type, function() {
				func.apply(this, arguments);
				this.off(type, func);
			});
		},
	
		emit: function(type, event) {
			var handlers = this._callbacks && this._callbacks[type];
			if (!handlers)
				return false;
			var args = [].slice.call(arguments, 1);
			handlers = handlers.slice();
			for (var i = 0, l = handlers.length; i < l; i++) {
				if (handlers[i].apply(this, args) === false) {
					if (event && event.stop)
						event.stop();
					break;
				}
			}
			return true;
		},
	
		responds: function(type) {
			return !!(this._callbacks && this._callbacks[type]);
		},
	
		attach: '#on',
		detach: '#off',
		fire: '#emit',
	
		_installEvents: function(install) {
			var handlers = this._callbacks,
				key = install ? 'install' : 'uninstall';
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var types = this._eventTypes,
						entry = types && types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		},
	
		statics: {
			inject: function inject(src) {
				var events = src._events;
				if (events) {
					var types = {};
					Base.each(events, function(entry, key) {
						var isString = typeof entry === 'string',
							name = isString ? entry : key,
							part = Base.capitalize(name),
							type = name.substring(2).toLowerCase();
						types[type] = isString ? {} : entry;
						name = '_' + name;
						src['get' + part] = function() {
							return this[name];
						};
						src['set' + part] = function(func) {
							var prev = this[name];
							if (prev)
								this.off(type, prev);
							if (func)
								this.on(type, func);
							this[name] = func;
						};
					});
					src._eventTypes = types;
				}
				return inject.base.apply(this, arguments);
			}
		}
	};
	
	var PaperScope = Base.extend({
		_class: 'PaperScope',
	
		initialize: function PaperScope() {
			paper = this;
			this.settings = new Base({
				applyMatrix: true,
				handleSize: 4,
				hitTolerance: 0
			});
			this.project = null;
			this.projects = [];
			this.tools = [];
			this.palettes = [];
			this._id = PaperScope._id++;
			PaperScope._scopes[this._id] = this;
			var proto = PaperScope.prototype;
			if (!this.support) {
				var ctx = CanvasProvider.getContext(1, 1);
				proto.support = {
					nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
					nativeBlendModes: BlendMode.nativeModes
				};
				CanvasProvider.release(ctx);
			}
	
			if (!this.browser) {
				var agent = navigator.userAgent.toLowerCase(),
					platform = (/(win)/.exec(agent)
							|| /(mac)/.exec(agent)
							|| /(linux)/.exec(agent)
							|| [])[0],
					browser = proto.browser = { platform: platform };
				if (platform)
					browser[platform] = true;
				agent.replace(
					/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
					function(all, n, v1, v2, rv) {
						if (!browser.chrome) {
							var v = n === 'opera' ? v2 : v1;
							if (n === 'trident') {
								v = rv;
								n = 'msie';
							}
							browser.version = v;
							browser.versionNumber = parseFloat(v);
							browser.name = n;
							browser[n] = true;
						}
					}
				);
				if (browser.chrome)
					delete browser.webkit;
				if (browser.atom)
					delete browser.chrome;
			}
		},
	
		version: "0.9.25",
	
		getView: function() {
			return this.project && this.project.getView();
		},
	
		getPaper: function() {
			return this;
		},
	
		execute: function(code, url, options) {
			paper.PaperScript.execute(code, this, url, options);
			View.updateFocus();
		},
	
		install: function(scope) {
			var that = this;
			Base.each(['project', 'view', 'tool'], function(key) {
				Base.define(scope, key, {
					configurable: true,
					get: function() {
						return that[key];
					}
				});
			});
			for (var key in this)
				if (!/^_/.test(key) && this[key])
					scope[key] = this[key];
		},
	
		setup: function(element) {
			paper = this;
			this.project = new Project(element);
			return this;
		},
	
		activate: function() {
			paper = this;
		},
	
		clear: function() {
			for (var i = this.projects.length - 1; i >= 0; i--)
				this.projects[i].remove();
			for (var i = this.tools.length - 1; i >= 0; i--)
				this.tools[i].remove();
			for (var i = this.palettes.length - 1; i >= 0; i--)
				this.palettes[i].remove();
		},
	
		remove: function() {
			this.clear();
			delete PaperScope._scopes[this._id];
		},
	
		statics: new function() {
			function handleAttribute(name) {
				name += 'Attribute';
				return function(el, attr) {
					return el[name](attr) || el[name]('data-paper-' + attr);
				};
			}
	
			return {
				_scopes: {},
				_id: 0,
	
				get: function(id) {
					return this._scopes[id] || null;
				},
	
				getAttribute: handleAttribute('get'),
				hasAttribute: handleAttribute('has')
			};
		}
	});
	
	var PaperScopeItem = Base.extend(Emitter, {
	
		initialize: function(activate) {
			this._scope = paper;
			this._index = this._scope[this._list].push(this) - 1;
			if (activate || !this._scope[this._reference])
				this.activate();
		},
	
		activate: function() {
			if (!this._scope)
				return false;
			var prev = this._scope[this._reference];
			if (prev && prev !== this)
				prev.emit('deactivate');
			this._scope[this._reference] = this;
			this.emit('activate', prev);
			return true;
		},
	
		isActive: function() {
			return this._scope[this._reference] === this;
		},
	
		remove: function() {
			if (this._index == null)
				return false;
			Base.splice(this._scope[this._list], null, this._index, 1);
			if (this._scope[this._reference] == this)
				this._scope[this._reference] = null;
			this._scope = null;
			return true;
		}
	});
	
	var Formatter = Base.extend({
		initialize: function(precision) {
			this.precision = precision || 5;
			this.multiplier = Math.pow(10, this.precision);
		},
	
		number: function(val) {
			return Math.round(val * this.multiplier) / this.multiplier;
		},
	
		pair: function(val1, val2, separator) {
			return this.number(val1) + (separator || ',') + this.number(val2);
		},
	
		point: function(val, separator) {
			return this.number(val.x) + (separator || ',') + this.number(val.y);
		},
	
		size: function(val, separator) {
			return this.number(val.width) + (separator || ',')
					+ this.number(val.height);
		},
	
		rectangle: function(val, separator) {
			return this.point(val, separator) + (separator || ',')
					+ this.size(val, separator);
		}
	});
	
	Formatter.instance = new Formatter();
	
	var Numerical = new function() {
	
		var abscissas = [
			[  0.5773502691896257645091488],
			[0,0.7745966692414833770358531],
			[  0.3399810435848562648026658,0.8611363115940525752239465],
			[0,0.5384693101056830910363144,0.9061798459386639927976269],
			[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
			[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
			[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
			[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
			[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
			[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
			[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
			[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
			[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
			[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
			[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
		];
	
		var weights = [
			[1],
			[0.8888888888888888888888889,0.5555555555555555555555556],
			[0.6521451548625461426269361,0.3478548451374538573730639],
			[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
			[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
			[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
			[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
			[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
			[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
			[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
			[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
			[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
			[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
			[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
			[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
		];
	
		var abs = Math.abs,
			sqrt = Math.sqrt,
			pow = Math.pow,
			EPSILON = 1e-12,
			MACHINE_EPSILON = 1.12e-16;
	
		function clip(value, min, max) {
			return value < min ? min : value > max ? max : value;
		}
	
		return {
			TOLERANCE: 1e-6,
			EPSILON: EPSILON,
			MACHINE_EPSILON: MACHINE_EPSILON,
			CURVETIME_EPSILON: 4e-7,
			GEOMETRIC_EPSILON: 2e-7,
			WINDING_EPSILON: 2e-7,
			TRIGONOMETRIC_EPSILON: 1e-7,
			CLIPPING_EPSILON: 1e-7,
			KAPPA: 4 * (sqrt(2) - 1) / 3,
	
			isZero: function(val) {
				return val >= -EPSILON && val <= EPSILON;
			},
	
			integrate: function(f, a, b, n) {
				var x = abscissas[n - 2],
					w = weights[n - 2],
					A = (b - a) * 0.5,
					B = A + a,
					i = 0,
					m = (n + 1) >> 1,
					sum = n & 1 ? w[i++] * f(B) : 0;
				while (i < m) {
					var Ax = A * x[i];
					sum += w[i++] * (f(B + Ax) + f(B - Ax));
				}
				return A * sum;
			},
	
			findRoot: function(f, df, x, a, b, n, tolerance) {
				for (var i = 0; i < n; i++) {
					var fx = f(x),
						dx = fx / df(x),
						nx = x - dx;
					if (abs(dx) < tolerance)
						return nx;
					if (fx > 0) {
						b = x;
						x = nx <= a ? (a + b) * 0.5 : nx;
					} else {
						a = x;
						x = nx >= b ? (a + b) * 0.5 : nx;
					}
				}
				return x;
			},
	
			solveQuadratic: function(a, b, c, roots, min, max) {
				var count = 0,
					eMin = min - EPSILON,
					eMax = max + EPSILON,
					x1, x2 = Infinity,
					B = b,
					D;
				b /= -2;
				D = b * b - a * c;
				if (D !== 0 && abs(D) < MACHINE_EPSILON) {
					var gmC = pow(abs(a * b * c), 1 / 3);
					if (gmC < 1e-8) {
						var mult = pow(10,
								abs(Math.floor(Math.log(gmC) * Math.LOG10E)));
						if (!isFinite(mult))
							mult = 0;
						a *= mult;
						b *= mult;
						c *= mult;
						D = b * b - a * c;
					}
				}
				if (abs(a) < EPSILON) {
					if (abs(B) < EPSILON)
						return abs(c) < EPSILON ? -1 : 0;
					x1 = -c / B;
				} else if (D >= -MACHINE_EPSILON) {
					var Q = D < 0 ? 0 : sqrt(D),
						R = b + (b < 0 ? -Q : Q);
					if (R === 0) {
						x1 = c / a;
						x2 = -x1;
					} else {
						x1 = R / a;
						x2 = c / R;
					}
				}
				if (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))
					roots[count++] = min == null ? x1 : clip(x1, min, max);
				if (x2 !== x1
						&& isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))
					roots[count++] = min == null ? x2 : clip(x2, min, max);
				return count;
			},
	
			solveCubic: function(a, b, c, d, roots, min, max) {
				var count = 0,
					x, b1, c2;
				if (abs(a) < EPSILON) {
					a = b;
					b1 = c;
					c2 = d;
					x = Infinity;
				} else if (abs(d) < EPSILON) {
					b1 = b;
					c2 = c;
					x = 0;
				} else {
					var ec = 1 + MACHINE_EPSILON,
						x0, q, qd, t, r, s, tmp;
					x = -(b / a) / 3;
					tmp = a * x,
					b1 = tmp + b,
					c2 = b1 * x + c,
					qd = (tmp + b1) * x + c2,
					q = c2 * x + d;
					t = q /a;
					r = pow(abs(t), 1/3);
					s = t < 0 ? -1 : 1;
					t = -qd / a;
					r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
					x0 = x - s * r;
					if (x0 !== x) {
						do {
							x = x0;
							tmp = a * x,
							b1 = tmp + b,
							c2 = b1 * x + c,
							qd = (tmp + b1) * x + c2,
							q = c2 * x + d;
							x0 = qd === 0 ? x : x - q / qd / ec;
							if (x0 === x) {
								x = x0;
								break;
							}
						} while (s * x0 > s * x);
						if (abs(a) * x * x > abs(d / x)) {
							c2 = -d / x;
							b1 = (c2 - c) / x;
						}
					}
				}
				var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
				if (isFinite(x) && (count === 0 || x !== roots[count - 1])
						&& (min == null || x > min - EPSILON && x < max + EPSILON))
					roots[count++] = min == null ? x : clip(x, min, max);
				return count;
			}
		};
	};
	
	var UID = {
		_id: 1,
		_pools: {},
	
		get: function(ctor) {
			if (ctor) {
				var name = ctor._class,
					pool = this._pools[name];
				if (!pool)
					pool = this._pools[name] = { _id: 1 };
				return pool._id++;
			} else {
				return this._id++;
			}
		}
	};
	
	var Point = Base.extend({
		_class: 'Point',
		_readIndex: true,
	
		initialize: function Point(arg0, arg1) {
			var type = typeof arg0;
			if (type === 'number') {
				var hasY = typeof arg1 === 'number';
				this.x = arg0;
				this.y = hasY ? arg1 : arg0;
				if (this.__read)
					this.__read = hasY ? 2 : 1;
			} else if (type === 'undefined' || arg0 === null) {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = arg0 === null ? 1 : 0;
			} else {
				if (Array.isArray(arg0)) {
					this.x = arg0[0];
					this.y = arg0.length > 1 ? arg0[1] : arg0[0];
				} else if (arg0.x != null) {
					this.x = arg0.x;
					this.y = arg0.y;
				} else if (arg0.width != null) {
					this.x = arg0.width;
					this.y = arg0.height;
				} else if (arg0.angle != null) {
					this.x = arg0.length;
					this.y = 0;
					this.setAngle(arg0.angle);
				} else {
					this.x = this.y = 0;
					if (this.__read)
						this.__read = 0;
				}
				if (this.__read)
					this.__read = 1;
			}
		},
	
		set: function(x, y) {
			this.x = x;
			this.y = y;
			return this;
		},
	
		equals: function(point) {
			return this === point || point
					&& (this.x === point.x && this.y === point.y
						|| Array.isArray(point)
							&& this.x === point[0] && this.y === point[1])
					|| false;
		},
	
		clone: function() {
			return new Point(this.x, this.y);
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
		},
	
		_serialize: function(options) {
			var f = options.formatter;
			return [f.number(this.x), f.number(this.y)];
		},
	
		getLength: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		},
	
		setLength: function(length) {
			if (this.isZero()) {
				var angle = this._angle || 0;
				this.set(
					Math.cos(angle) * length,
					Math.sin(angle) * length
				);
			} else {
				var scale = length / this.getLength();
				if (Numerical.isZero(scale))
					this.getAngle();
				this.set(
					this.x * scale,
					this.y * scale
				);
			}
		},
		getAngle: function() {
			return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
		},
	
		setAngle: function(angle) {
			this.setAngleInRadians.call(this, angle * Math.PI / 180);
		},
	
		getAngleInDegrees: '#getAngle',
		setAngleInDegrees: '#setAngle',
	
		getAngleInRadians: function() {
			if (!arguments.length) {
				return this.isZero()
						? this._angle || 0
						: this._angle = Math.atan2(this.y, this.x);
			} else {
				var point = Point.read(arguments),
					div = this.getLength() * point.getLength();
				if (Numerical.isZero(div)) {
					return NaN;
				} else {
					var a = this.dot(point) / div;
					return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
				}
			}
		},
	
		setAngleInRadians: function(angle) {
			this._angle = angle;
			if (!this.isZero()) {
				var length = this.getLength();
				this.set(
					Math.cos(angle) * length,
					Math.sin(angle) * length
				);
			}
		},
	
		getQuadrant: function() {
			return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
		}
	}, {
		beans: false,
	
		getDirectedAngle: function() {
			var point = Point.read(arguments);
			return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
		},
	
		getDistance: function() {
			var point = Point.read(arguments),
				x = point.x - this.x,
				y = point.y - this.y,
				d = x * x + y * y,
				squared = Base.read(arguments);
			return squared ? d : Math.sqrt(d);
		},
	
		normalize: function(length) {
			if (length === undefined)
				length = 1;
			var current = this.getLength(),
				scale = current !== 0 ? length / current : 0,
				point = new Point(this.x * scale, this.y * scale);
			if (scale >= 0)
				point._angle = this._angle;
			return point;
		},
	
		rotate: function(angle, center) {
			if (angle === 0)
				return this.clone();
			angle = angle * Math.PI / 180;
			var point = center ? this.subtract(center) : this,
				sin = Math.sin(angle),
				cos = Math.cos(angle);
			point = new Point(
				point.x * cos - point.y * sin,
				point.x * sin + point.y * cos
			);
			return center ? point.add(center) : point;
		},
	
		transform: function(matrix) {
			return matrix ? matrix._transformPoint(this) : this;
		},
	
		add: function() {
			var point = Point.read(arguments);
			return new Point(this.x + point.x, this.y + point.y);
		},
	
		subtract: function() {
			var point = Point.read(arguments);
			return new Point(this.x - point.x, this.y - point.y);
		},
	
		multiply: function() {
			var point = Point.read(arguments);
			return new Point(this.x * point.x, this.y * point.y);
		},
	
		divide: function() {
			var point = Point.read(arguments);
			return new Point(this.x / point.x, this.y / point.y);
		},
	
		modulo: function() {
			var point = Point.read(arguments);
			return new Point(this.x % point.x, this.y % point.y);
		},
	
		negate: function() {
			return new Point(-this.x, -this.y);
		},
	
		isInside: function() {
			return Rectangle.read(arguments).contains(this);
		},
	
		isClose: function() {
			var point = Point.read(arguments),
				tolerance = Base.read(arguments);
			return this.getDistance(point) < tolerance;
		},
	
		isCollinear: function() {
			var point = Point.read(arguments);
			return Point.isCollinear(this.x, this.y, point.x, point.y);
		},
	
		isColinear: '#isCollinear',
	
		isOrthogonal: function() {
			var point = Point.read(arguments);
			return Point.isOrthogonal(this.x, this.y, point.x, point.y);
		},
	
		isZero: function() {
			return Numerical.isZero(this.x) && Numerical.isZero(this.y);
		},
	
		isNaN: function() {
			return isNaN(this.x) || isNaN(this.y);
		},
	
		dot: function() {
			var point = Point.read(arguments);
			return this.x * point.x + this.y * point.y;
		},
	
		cross: function() {
			var point = Point.read(arguments);
			return this.x * point.y - this.y * point.x;
		},
	
		project: function() {
			var point = Point.read(arguments),
				scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		},
	
		statics: {
			min: function() {
				var point1 = Point.read(arguments),
					point2 = Point.read(arguments);
				return new Point(
					Math.min(point1.x, point2.x),
					Math.min(point1.y, point2.y)
				);
			},
	
			max: function() {
				var point1 = Point.read(arguments),
					point2 = Point.read(arguments);
				return new Point(
					Math.max(point1.x, point2.x),
					Math.max(point1.y, point2.y)
				);
			},
	
			random: function() {
				return new Point(Math.random(), Math.random());
			},
	
			isCollinear: function(x1, y1, x2, y2) {
				return Math.abs(x1 * y2 - y1 * x2)
						<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
							* 1e-7;
			},
	
			isOrthogonal: function(x1, y1, x2, y2) {
				return Math.abs(x1 * x2 + y1 * y2)
						<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
							* 1e-7;
			}
		}
	}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
		var op = Math[name];
		this[name] = function() {
			return new Point(op(this.x), op(this.y));
		};
	}, {}));
	
	var LinkedPoint = Point.extend({
		initialize: function Point(x, y, owner, setter) {
			this._x = x;
			this._y = y;
			this._owner = owner;
			this._setter = setter;
		},
	
		set: function(x, y, _dontNotify) {
			this._x = x;
			this._y = y;
			if (!_dontNotify)
				this._owner[this._setter](this);
			return this;
		},
	
		getX: function() {
			return this._x;
		},
	
		setX: function(x) {
			this._x = x;
			this._owner[this._setter](this);
		},
	
		getY: function() {
			return this._y;
		},
	
		setY: function(y) {
			this._y = y;
			this._owner[this._setter](this);
		}
	});
	
	var Size = Base.extend({
		_class: 'Size',
		_readIndex: true,
	
		initialize: function Size(arg0, arg1) {
			var type = typeof arg0;
			if (type === 'number') {
				var hasHeight = typeof arg1 === 'number';
				this.width = arg0;
				this.height = hasHeight ? arg1 : arg0;
				if (this.__read)
					this.__read = hasHeight ? 2 : 1;
			} else if (type === 'undefined' || arg0 === null) {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = arg0 === null ? 1 : 0;
			} else {
				if (Array.isArray(arg0)) {
					this.width = arg0[0];
					this.height = arg0.length > 1 ? arg0[1] : arg0[0];
				} else if (arg0.width != null) {
					this.width = arg0.width;
					this.height = arg0.height;
				} else if (arg0.x != null) {
					this.width = arg0.x;
					this.height = arg0.y;
				} else {
					this.width = this.height = 0;
					if (this.__read)
						this.__read = 0;
				}
				if (this.__read)
					this.__read = 1;
			}
		},
	
		set: function(width, height) {
			this.width = width;
			this.height = height;
			return this;
		},
	
		equals: function(size) {
			return size === this || size && (this.width === size.width
					&& this.height === size.height
					|| Array.isArray(size) && this.width === size[0]
						&& this.height === size[1]) || false;
		},
	
		clone: function() {
			return new Size(this.width, this.height);
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '{ width: ' + f.number(this.width)
					+ ', height: ' + f.number(this.height) + ' }';
		},
	
		_serialize: function(options) {
			var f = options.formatter;
			return [f.number(this.width),
					f.number(this.height)];
		},
	
		add: function() {
			var size = Size.read(arguments);
			return new Size(this.width + size.width, this.height + size.height);
		},
	
		subtract: function() {
			var size = Size.read(arguments);
			return new Size(this.width - size.width, this.height - size.height);
		},
	
		multiply: function() {
			var size = Size.read(arguments);
			return new Size(this.width * size.width, this.height * size.height);
		},
	
		divide: function() {
			var size = Size.read(arguments);
			return new Size(this.width / size.width, this.height / size.height);
		},
	
		modulo: function() {
			var size = Size.read(arguments);
			return new Size(this.width % size.width, this.height % size.height);
		},
	
		negate: function() {
			return new Size(-this.width, -this.height);
		},
	
		isZero: function() {
			return Numerical.isZero(this.width) && Numerical.isZero(this.height);
		},
	
		isNaN: function() {
			return isNaN(this.width) || isNaN(this.height);
		},
	
		statics: {
			min: function(size1, size2) {
				return new Size(
					Math.min(size1.width, size2.width),
					Math.min(size1.height, size2.height));
			},
	
			max: function(size1, size2) {
				return new Size(
					Math.max(size1.width, size2.width),
					Math.max(size1.height, size2.height));
			},
	
			random: function() {
				return new Size(Math.random(), Math.random());
			}
		}
	}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
		var op = Math[name];
		this[name] = function() {
			return new Size(op(this.width), op(this.height));
		};
	}, {}));
	
	var LinkedSize = Size.extend({
		initialize: function Size(width, height, owner, setter) {
			this._width = width;
			this._height = height;
			this._owner = owner;
			this._setter = setter;
		},
	
		set: function(width, height, _dontNotify) {
			this._width = width;
			this._height = height;
			if (!_dontNotify)
				this._owner[this._setter](this);
			return this;
		},
	
		getWidth: function() {
			return this._width;
		},
	
		setWidth: function(width) {
			this._width = width;
			this._owner[this._setter](this);
		},
	
		getHeight: function() {
			return this._height;
		},
	
		setHeight: function(height) {
			this._height = height;
			this._owner[this._setter](this);
		}
	});
	
	var Rectangle = Base.extend({
		_class: 'Rectangle',
		_readIndex: true,
		beans: true,
	
		initialize: function Rectangle(arg0, arg1, arg2, arg3) {
			var type = typeof arg0,
				read = 0;
			if (type === 'number') {
				this.x = arg0;
				this.y = arg1;
				this.width = arg2;
				this.height = arg3;
				read = 4;
			} else if (type === 'undefined' || arg0 === null) {
				this.x = this.y = this.width = this.height = 0;
				read = arg0 === null ? 1 : 0;
			} else if (arguments.length === 1) {
				if (Array.isArray(arg0)) {
					this.x = arg0[0];
					this.y = arg0[1];
					this.width = arg0[2];
					this.height = arg0[3];
					read = 1;
				} else if (arg0.x !== undefined || arg0.width !== undefined) {
					this.x = arg0.x || 0;
					this.y = arg0.y || 0;
					this.width = arg0.width || 0;
					this.height = arg0.height || 0;
					read = 1;
				} else if (arg0.from === undefined && arg0.to === undefined) {
					this.x = this.y = this.width = this.height = 0;
					this._set(arg0);
					read = 1;
				}
			}
			if (!read) {
				var point = Point.readNamed(arguments, 'from'),
					next = Base.peek(arguments);
				this.x = point.x;
				this.y = point.y;
				if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
					var to = Point.readNamed(arguments, 'to');
					this.width = to.x - point.x;
					this.height = to.y - point.y;
					if (this.width < 0) {
						this.x = to.x;
						this.width = -this.width;
					}
					if (this.height < 0) {
						this.y = to.y;
						this.height = -this.height;
					}
				} else {
					var size = Size.read(arguments);
					this.width = size.width;
					this.height = size.height;
				}
				read = arguments.__index;
			}
			if (this.__read)
				this.__read = read;
		},
	
		set: function(x, y, width, height) {
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			return this;
		},
	
		clone: function() {
			return new Rectangle(this.x, this.y, this.width, this.height);
		},
	
		equals: function(rect) {
			var rt = Base.isPlainValue(rect)
					? Rectangle.read(arguments)
					: rect;
			return rt === this
					|| rt && this.x === rt.x && this.y === rt.y
						&& this.width === rt.width && this.height === rt.height
					|| false;
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '{ x: ' + f.number(this.x)
					+ ', y: ' + f.number(this.y)
					+ ', width: ' + f.number(this.width)
					+ ', height: ' + f.number(this.height)
					+ ' }';
		},
	
		_serialize: function(options) {
			var f = options.formatter;
			return [f.number(this.x),
					f.number(this.y),
					f.number(this.width),
					f.number(this.height)];
		},
	
		getPoint: function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this.x, this.y, this, 'setPoint');
		},
	
		setPoint: function() {
			var point = Point.read(arguments);
			this.x = point.x;
			this.y = point.y;
		},
	
		getSize: function(_dontLink) {
			var ctor = _dontLink ? Size : LinkedSize;
			return new ctor(this.width, this.height, this, 'setSize');
		},
	
		setSize: function() {
			var size = Size.read(arguments);
			if (this._fixX)
				this.x += (this.width - size.width) * this._fixX;
			if (this._fixY)
				this.y += (this.height - size.height) * this._fixY;
			this.width = size.width;
			this.height = size.height;
			this._fixW = 1;
			this._fixH = 1;
		},
	
		getLeft: function() {
			return this.x;
		},
	
		setLeft: function(left) {
			if (!this._fixW)
				this.width -= left - this.x;
			this.x = left;
			this._fixX = 0;
		},
	
		getTop: function() {
			return this.y;
		},
	
		setTop: function(top) {
			if (!this._fixH)
				this.height -= top - this.y;
			this.y = top;
			this._fixY = 0;
		},
	
		getRight: function() {
			return this.x + this.width;
		},
	
		setRight: function(right) {
			if (this._fixX !== undefined && this._fixX !== 1)
				this._fixW = 0;
			if (this._fixW)
				this.x = right - this.width;
			else
				this.width = right - this.x;
			this._fixX = 1;
		},
	
		getBottom: function() {
			return this.y + this.height;
		},
	
		setBottom: function(bottom) {
			if (this._fixY !== undefined && this._fixY !== 1)
				this._fixH = 0;
			if (this._fixH)
				this.y = bottom - this.height;
			else
				this.height = bottom - this.y;
			this._fixY = 1;
		},
	
		getCenterX: function() {
			return this.x + this.width * 0.5;
		},
	
		setCenterX: function(x) {
			this.x = x - this.width * 0.5;
			this._fixX = 0.5;
		},
	
		getCenterY: function() {
			return this.y + this.height * 0.5;
		},
	
		setCenterY: function(y) {
			this.y = y - this.height * 0.5;
			this._fixY = 0.5;
		},
	
		getCenter: function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
		},
	
		setCenter: function() {
			var point = Point.read(arguments);
			this.setCenterX(point.x);
			this.setCenterY(point.y);
			return this;
		},
	
		getArea: function() {
			return this.width * this.height;
		},
	
		isEmpty: function() {
			return this.width === 0 || this.height === 0;
		},
	
		contains: function(arg) {
			return arg && arg.width !== undefined
					|| (Array.isArray(arg) ? arg : arguments).length == 4
					? this._containsRectangle(Rectangle.read(arguments))
					: this._containsPoint(Point.read(arguments));
		},
	
		_containsPoint: function(point) {
			var x = point.x,
				y = point.y;
			return x >= this.x && y >= this.y
					&& x <= this.x + this.width
					&& y <= this.y + this.height;
		},
	
		_containsRectangle: function(rect) {
			var x = rect.x,
				y = rect.y;
			return x >= this.x && y >= this.y
					&& x + rect.width <= this.x + this.width
					&& y + rect.height <= this.y + this.height;
		},
	
		intersects: function() {
			var rect = Rectangle.read(arguments);
			return rect.x + rect.width > this.x
					&& rect.y + rect.height > this.y
					&& rect.x < this.x + this.width
					&& rect.y < this.y + this.height;
		},
	
		touches: function() {
			var rect = Rectangle.read(arguments);
			return rect.x + rect.width >= this.x
					&& rect.y + rect.height >= this.y
					&& rect.x <= this.x + this.width
					&& rect.y <= this.y + this.height;
		},
	
		intersect: function() {
			var rect = Rectangle.read(arguments),
				x1 = Math.max(this.x, rect.x),
				y1 = Math.max(this.y, rect.y),
				x2 = Math.min(this.x + this.width, rect.x + rect.width),
				y2 = Math.min(this.y + this.height, rect.y + rect.height);
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		unite: function() {
			var rect = Rectangle.read(arguments),
				x1 = Math.min(this.x, rect.x),
				y1 = Math.min(this.y, rect.y),
				x2 = Math.max(this.x + this.width, rect.x + rect.width),
				y2 = Math.max(this.y + this.height, rect.y + rect.height);
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		include: function() {
			var point = Point.read(arguments);
			var x1 = Math.min(this.x, point.x),
				y1 = Math.min(this.y, point.y),
				x2 = Math.max(this.x + this.width, point.x),
				y2 = Math.max(this.y + this.height, point.y);
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		expand: function() {
			var amount = Size.read(arguments),
				hor = amount.width,
				ver = amount.height;
			return new Rectangle(this.x - hor / 2, this.y - ver / 2,
					this.width + hor, this.height + ver);
		},
	
		scale: function(hor, ver) {
			return this.expand(this.width * hor - this.width,
					this.height * (ver === undefined ? hor : ver) - this.height);
		}
	}, Base.each([
			['Top', 'Left'], ['Top', 'Right'],
			['Bottom', 'Left'], ['Bottom', 'Right'],
			['Left', 'Center'], ['Top', 'Center'],
			['Right', 'Center'], ['Bottom', 'Center']
		],
		function(parts, index) {
			var part = parts.join('');
			var xFirst = /^[RL]/.test(part);
			if (index >= 4)
				parts[1] += xFirst ? 'Y' : 'X';
			var x = parts[xFirst ? 0 : 1],
				y = parts[xFirst ? 1 : 0],
				getX = 'get' + x,
				getY = 'get' + y,
				setX = 'set' + x,
				setY = 'set' + y,
				get = 'get' + part,
				set = 'set' + part;
			this[get] = function(_dontLink) {
				var ctor = _dontLink ? Point : LinkedPoint;
				return new ctor(this[getX](), this[getY](), this, set);
			};
			this[set] = function() {
				var point = Point.read(arguments);
				this[setX](point.x);
				this[setY](point.y);
			};
		}, {
			beans: true
		}
	));
	
	var LinkedRectangle = Rectangle.extend({
		initialize: function Rectangle(x, y, width, height, owner, setter) {
			this.set(x, y, width, height, true);
			this._owner = owner;
			this._setter = setter;
		},
	
		set: function(x, y, width, height, _dontNotify) {
			this._x = x;
			this._y = y;
			this._width = width;
			this._height = height;
			if (!_dontNotify)
				this._owner[this._setter](this);
			return this;
		}
	},
	new function() {
		var proto = Rectangle.prototype;
	
		return Base.each(['x', 'y', 'width', 'height'], function(key) {
			var part = Base.capitalize(key);
			var internal = '_' + key;
			this['get' + part] = function() {
				return this[internal];
			};
	
			this['set' + part] = function(value) {
				this[internal] = value;
				if (!this._dontNotify)
					this._owner[this._setter](this);
			};
		}, Base.each(['Point', 'Size', 'Center',
				'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
				'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
				'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
			function(key) {
				var name = 'set' + key;
				this[name] = function() {
					this._dontNotify = true;
					proto[name].apply(this, arguments);
					this._dontNotify = false;
					this._owner[this._setter](this);
				};
			}, {
				isSelected: function() {
					return this._owner._boundsSelected;
				},
	
				setSelected: function(selected) {
					var owner = this._owner;
					if (owner.setSelected) {
						owner._boundsSelected = selected;
						owner.setSelected(selected || owner._selectedSegmentState > 0);
					}
				}
			})
		);
	});
	
	var Matrix = Base.extend({
		_class: 'Matrix',
	
		initialize: function Matrix(arg) {
			var count = arguments.length,
				ok = true;
			if (count === 6) {
				this.set.apply(this, arguments);
			} else if (count === 1) {
				if (arg instanceof Matrix) {
					this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
				} else if (Array.isArray(arg)) {
					this.set.apply(this, arg);
				} else {
					ok = false;
				}
			} else if (count === 0) {
				this.reset();
			} else {
				ok = false;
			}
			if (!ok)
				throw new Error('Unsupported matrix parameters');
		},
	
		set: function(a, c, b, d, tx, ty, _dontNotify) {
			this._a = a;
			this._c = c;
			this._b = b;
			this._d = d;
			this._tx = tx;
			this._ty = ty;
			if (!_dontNotify)
				this._changed();
			return this;
		},
	
		_serialize: function(options) {
			return Base.serialize(this.getValues(), options);
		},
	
		_changed: function() {
			var owner = this._owner;
			if (owner) {
				if (owner._applyMatrix) {
					owner.transform(null, true);
				} else {
					owner._changed(9);
				}
			}
		},
	
		clone: function() {
			return new Matrix(this._a, this._c, this._b, this._d,
					this._tx, this._ty);
		},
	
		equals: function(mx) {
			return mx === this || mx && this._a === mx._a && this._b === mx._b
					&& this._c === mx._c && this._d === mx._d
					&& this._tx === mx._tx && this._ty === mx._ty
					|| false;
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '[[' + [f.number(this._a), f.number(this._b),
						f.number(this._tx)].join(', ') + '], ['
					+ [f.number(this._c), f.number(this._d),
						f.number(this._ty)].join(', ') + ']]';
		},
	
		reset: function(_dontNotify) {
			this._a = this._d = 1;
			this._c = this._b = this._tx = this._ty = 0;
			if (!_dontNotify)
				this._changed();
			return this;
		},
	
		apply: function(recursively, _setApplyMatrix) {
			var owner = this._owner;
			if (owner) {
				owner.transform(null, true, Base.pick(recursively, true),
						_setApplyMatrix);
				return this.isIdentity();
			}
			return false;
		},
	
		translate: function() {
			var point = Point.read(arguments),
				x = point.x,
				y = point.y;
			this._tx += x * this._a + y * this._b;
			this._ty += x * this._c + y * this._d;
			this._changed();
			return this;
		},
	
		scale: function() {
			var scale = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true });
			if (center)
				this.translate(center);
			this._a *= scale.x;
			this._c *= scale.x;
			this._b *= scale.y;
			this._d *= scale.y;
			if (center)
				this.translate(center.negate());
			this._changed();
			return this;
		},
	
		rotate: function(angle ) {
			angle *= Math.PI / 180;
			var center = Point.read(arguments, 1),
				x = center.x,
				y = center.y,
				cos = Math.cos(angle),
				sin = Math.sin(angle),
				tx = x - x * cos + y * sin,
				ty = y - x * sin - y * cos,
				a = this._a,
				b = this._b,
				c = this._c,
				d = this._d;
			this._a = cos * a + sin * b;
			this._b = -sin * a + cos * b;
			this._c = cos * c + sin * d;
			this._d = -sin * c + cos * d;
			this._tx += tx * a + ty * b;
			this._ty += tx * c + ty * d;
			this._changed();
			return this;
		},
	
		shear: function() {
			var shear = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true });
			if (center)
				this.translate(center);
			var a = this._a,
				c = this._c;
			this._a += shear.y * this._b;
			this._c += shear.y * this._d;
			this._b += shear.x * a;
			this._d += shear.x * c;
			if (center)
				this.translate(center.negate());
			this._changed();
			return this;
		},
	
		skew: function() {
			var skew = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true }),
				toRadians = Math.PI / 180,
				shear = new Point(Math.tan(skew.x * toRadians),
					Math.tan(skew.y * toRadians));
			return this.shear(shear, center);
		},
	
		concatenate: function(mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._b,
				c2 = mx._c,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * b1;
			this._b = b2 * a1 + d2 * b1;
			this._c = a2 * c1 + c2 * d1;
			this._d = b2 * c1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * b1;
			this._ty += tx2 * c1 + ty2 * d1;
			this._changed();
			return this;
		},
	
		preConcatenate: function(mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._b,
				c2 = mx._c,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * c1;
			this._b = a2 * b1 + b2 * d1;
			this._c = c2 * a1 + d2 * c1;
			this._d = c2 * b1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			this._changed();
			return this;
		},
	
		chain: function(mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._b,
				c2 = mx._c,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			return new Matrix(
					a2 * a1 + c2 * b1,
					a2 * c1 + c2 * d1,
					b2 * a1 + d2 * b1,
					b2 * c1 + d2 * d1,
					tx1 + tx2 * a1 + ty2 * b1,
					ty1 + tx2 * c1 + ty2 * d1);
		},
	
		isIdentity: function() {
			return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
					&& this._tx === 0 && this._ty === 0;
		},
	
		orNullIfIdentity: function() {
			return this.isIdentity() ? null : this;
		},
	
		isInvertible: function() {
			return !!this._getDeterminant();
		},
	
		isSingular: function() {
			return !this._getDeterminant();
		},
	
		transform: function( src, dst, count) {
			return arguments.length < 3
				? this._transformPoint(Point.read(arguments))
				: this._transformCoordinates(src, dst, count);
		},
	
		_transformPoint: function(point, dest, _dontNotify) {
			var x = point.x,
				y = point.y;
			if (!dest)
				dest = new Point();
			return dest.set(
				x * this._a + y * this._b + this._tx,
				x * this._c + y * this._d + this._ty,
				_dontNotify
			);
		},
	
		_transformCoordinates: function(src, dst, count) {
			var i = 0,
				j = 0,
				max = 2 * count;
			while (i < max) {
				var x = src[i++],
					y = src[i++];
				dst[j++] = x * this._a + y * this._b + this._tx;
				dst[j++] = x * this._c + y * this._d + this._ty;
			}
			return dst;
		},
	
		_transformCorners: function(rect) {
			var x1 = rect.x,
				y1 = rect.y,
				x2 = x1 + rect.width,
				y2 = y1 + rect.height,
				coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
			return this._transformCoordinates(coords, coords, 4);
		},
	
		_transformBounds: function(bounds, dest, _dontNotify) {
			var coords = this._transformCorners(bounds),
				min = coords.slice(0, 2),
				max = min.slice();
			for (var i = 2; i < 8; i++) {
				var val = coords[i],
					j = i & 1;
				if (val < min[j])
					min[j] = val;
				else if (val > max[j])
					max[j] = val;
			}
			if (!dest)
				dest = new Rectangle();
			return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
					_dontNotify);
		},
	
		inverseTransform: function() {
			return this._inverseTransform(Point.read(arguments));
		},
	
		_getDeterminant: function() {
			var det = this._a * this._d - this._b * this._c;
			return isFinite(det) && !Numerical.isZero(det)
					&& isFinite(this._tx) && isFinite(this._ty)
					? det : null;
		},
	
		_inverseTransform: function(point, dest, _dontNotify) {
			var det = this._getDeterminant();
			if (!det)
				return null;
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			return dest.set(
				(x * this._d - y * this._b) / det,
				(y * this._a - x * this._c) / det,
				_dontNotify
			);
		},
	
		decompose: function() {
			var a = this._a, b = this._b, c = this._c, d = this._d;
			if (Numerical.isZero(a * d - b * c))
				return null;
	
			var scaleX = Math.sqrt(a * a + b * b);
			a /= scaleX;
			b /= scaleX;
	
			var shear = a * c + b * d;
			c -= a * shear;
			d -= b * shear;
	
			var scaleY = Math.sqrt(c * c + d * d);
			c /= scaleY;
			d /= scaleY;
			shear /= scaleY;
	
			if (a * d < b * c) {
				a = -a;
				b = -b;
				shear = -shear;
				scaleX = -scaleX;
			}
	
			return {
				scaling: new Point(scaleX, scaleY),
				rotation: -Math.atan2(b, a) * 180 / Math.PI,
				shearing: shear
			};
		},
	
		getValues: function() {
			return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
		},
	
		getTranslation: function() {
			return new Point(this._tx, this._ty);
		},
	
		getScaling: function() {
			return (this.decompose() || {}).scaling;
		},
	
		getRotation: function() {
			return (this.decompose() || {}).rotation;
		},
	
		inverted: function() {
			var det = this._getDeterminant();
			return det && new Matrix(
					this._d / det,
					-this._c / det,
					-this._b / det,
					this._a / det,
					(this._b * this._ty - this._d * this._tx) / det,
					(this._c * this._tx - this._a * this._ty) / det);
		},
	
		shiftless: function() {
			return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
		},
	
		applyToContext: function(ctx) {
			ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
		}
	}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
		var part = Base.capitalize(name),
			prop = '_' + name;
		this['get' + part] = function() {
			return this[prop];
		};
		this['set' + part] = function(value) {
			this[prop] = value;
			this._changed();
		};
	}, {}));
	
	var Line = Base.extend({
		_class: 'Line',
	
		initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
			var asVector = false;
			if (arguments.length >= 4) {
				this._px = arg0;
				this._py = arg1;
				this._vx = arg2;
				this._vy = arg3;
				asVector = arg4;
			} else {
				this._px = arg0.x;
				this._py = arg0.y;
				this._vx = arg1.x;
				this._vy = arg1.y;
				asVector = arg2;
			}
			if (!asVector) {
				this._vx -= this._px;
				this._vy -= this._py;
			}
		},
	
		getPoint: function() {
			return new Point(this._px, this._py);
		},
	
		getVector: function() {
			return new Point(this._vx, this._vy);
		},
	
		getLength: function() {
			return this.getVector().getLength();
		},
	
		intersect: function(line, isInfinite) {
			return Line.intersect(
					this._px, this._py, this._vx, this._vy,
					line._px, line._py, line._vx, line._vy,
					true, isInfinite);
		},
	
		getSide: function(point, isInfinite) {
			return Line.getSide(
					this._px, this._py, this._vx, this._vy,
					point.x, point.y, true, isInfinite);
		},
	
		getDistance: function(point) {
			return Math.abs(Line.getSignedDistance(
					this._px, this._py, this._vx, this._vy,
					point.x, point.y, true));
		},
	
		isCollinear: function(line) {
			return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
		},
	
		isOrthogonal: function(line) {
			return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
		},
	
		statics: {
			intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
					isInfinite) {
				if (!asVector) {
					v1x -= p1x;
					v1y -= p1y;
					v2x -= p2x;
					v2y -= p2y;
				}
				var cross = v1x * v2y - v1y * v2x;
				if (!Numerical.isZero(cross)) {
					var dx = p1x - p2x,
						dy = p1y - p2y,
						u1 = (v2x * dy - v2y * dx) / cross,
						u2 = (v1x * dy - v1y * dx) / cross,
						epsilon = 1e-12,
						uMin = -epsilon,
						uMax = 1 + epsilon;
					if (isInfinite
							|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
						if (!isInfinite) {
							u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
						}
						return new Point(
								p1x + u1 * v1x,
								p1y + u1 * v1y);
					}
				}
			},
	
			getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
				if (!asVector) {
					vx -= px;
					vy -= py;
				}
				var v2x = x - px,
					v2y = y - py,
					ccw = v2x * vy - v2y * vx;
				if (ccw === 0 && !isInfinite) {
					ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
					if (ccw >= 0 && ccw <= 1)
						ccw = 0;
				}
				return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
			},
	
			getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
				if (!asVector) {
					vx -= px;
					vy -= py;
				}
				return vx === 0 ? vy > 0 ? x - px : px - x
					 : vy === 0 ? vx < 0 ? y - py : py - y
					 : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);
			}
		}
	});
	
	var Project = PaperScopeItem.extend({
		_class: 'Project',
		_list: 'projects',
		_reference: 'project',
	
		initialize: function Project(element) {
			PaperScopeItem.call(this, true);
			this.layers = [];
			this._activeLayer = null;
			this.symbols = [];
			this._currentStyle = new Style(null, null, this);
			this._view = View.create(this,
					element || CanvasProvider.getCanvas(1, 1));
			this._selectedItems = {};
			this._selectedItemCount = 0;
			this._updateVersion = 0;
		},
	
		_serialize: function(options, dictionary) {
			return Base.serialize(this.layers, options, true, dictionary);
		},
	
		clear: function() {
			for (var i = this.layers.length - 1; i >= 0; i--)
				this.layers[i].remove();
			this.symbols = [];
		},
	
		isEmpty: function() {
			return this.layers.length === 0;
		},
	
		remove: function remove() {
			if (!remove.base.call(this))
				return false;
			if (this._view)
				this._view.remove();
			return true;
		},
	
		getView: function() {
			return this._view;
		},
	
		getCurrentStyle: function() {
			return this._currentStyle;
		},
	
		setCurrentStyle: function(style) {
			this._currentStyle.initialize(style);
		},
	
		getIndex: function() {
			return this._index;
		},
	
		getOptions: function() {
			return this._scope.settings;
		},
	
		getActiveLayer: function() {
			return this._activeLayer || new Layer({ project: this });
		},
	
		getSelectedItems: function() {
			var items = [];
			for (var id in this._selectedItems) {
				var item = this._selectedItems[id];
				if (item.isInserted())
					items.push(item);
			}
			return items;
		},
	
		insertChild: function(index, item, _preserve) {
			if (item instanceof Layer) {
				item._remove(false, true);
				Base.splice(this.layers, [item], index, 0);
				item._setProject(this, true);
				if (this._changes)
					item._changed(5);
				if (!this._activeLayer)
					this._activeLayer = item;
			} else if (item instanceof Item) {
				(this._activeLayer
					|| this.insertChild(index, new Layer(Item.NO_INSERT)))
						.insertChild(index, item, _preserve);
			} else {
				item = null;
			}
			return item;
		},
	
		addChild: function(item, _preserve) {
			return this.insertChild(undefined, item, _preserve);
		},
	
		_updateSelection: function(item) {
			var id = item._id,
				selectedItems = this._selectedItems;
			if (item._selected) {
				if (selectedItems[id] !== item) {
					this._selectedItemCount++;
					selectedItems[id] = item;
				}
			} else if (selectedItems[id] === item) {
				this._selectedItemCount--;
				delete selectedItems[id];
			}
		},
	
		selectAll: function() {
			var layers = this.layers;
			for (var i = 0, l = layers.length; i < l; i++)
				layers[i].setFullySelected(true);
		},
	
		deselectAll: function() {
			var selectedItems = this._selectedItems;
			for (var i in selectedItems)
				selectedItems[i].setFullySelected(false);
		},
	
		hitTest: function() {
			var point = Point.read(arguments),
				options = HitResult.getOptions(Base.read(arguments));
			for (var i = this.layers.length - 1; i >= 0; i--) {
				var res = this.layers[i]._hitTest(point, options);
				if (res) return res;
			}
			return null;
		},
	
		getItems: function(match) {
			return Item._getItems(this.layers, match);
		},
	
		getItem: function(match) {
			return Item._getItems(this.layers, match, null, null, true)[0] || null;
		},
	
		importJSON: function(json) {
			this.activate();
			var layer = this._activeLayer;
			return Base.importJSON(json, layer && layer.isEmpty() && layer);
		},
	
		draw: function(ctx, matrix, pixelRatio) {
			this._updateVersion++;
			ctx.save();
			matrix.applyToContext(ctx);
			var param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
			for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
				layers[i].draw(ctx, param);
			ctx.restore();
	
			if (this._selectedItemCount > 0) {
				ctx.save();
				ctx.strokeWidth = 1;
				var items = this._selectedItems,
					size = this._scope.settings.handleSize,
					version = this._updateVersion;
				for (var id in items)
					items[id]._drawSelection(ctx, matrix, size, items, version);
				ctx.restore();
			}
		}
	});
	
	var Symbol = Base.extend({
		_class: 'Symbol',
	
		initialize: function Symbol(item, dontCenter) {
			this._id = UID.get();
			this.project = paper.project;
			this.project.symbols.push(this);
			if (item)
				this.setDefinition(item, dontCenter);
		},
	
		_serialize: function(options, dictionary) {
			return dictionary.add(this, function() {
				return Base.serialize([this._class, this._definition],
						options, false, dictionary);
			});
		},
	
		_changed: function(flags) {
			if (flags & 8) {
				Item._clearBoundsCache(this);
			}
			if (flags & 1) {
				this.project._needsUpdate = true;
			}
		},
	
		getDefinition: function() {
			return this._definition;
		},
	
		setDefinition: function(item, _dontCenter) {
			if (item._parentSymbol)
				item = item.clone();
			if (this._definition)
				this._definition._parentSymbol = null;
			this._definition = item;
			item.remove();
			item.setSelected(false);
			if (!_dontCenter)
				item.setPosition(new Point());
			item._parentSymbol = this;
			this._changed(9);
		},
	
		place: function(position) {
			return new PlacedSymbol(this, position);
		},
	
		clone: function() {
			return new Symbol(this._definition.clone(false));
		},
	
		equals: function(symbol) {
			return symbol === this
					|| symbol && this.definition.equals(symbol.definition)
					|| false;
		}
	});
	
	var Item = Base.extend(Emitter, {
		statics: {
			extend: function extend(src) {
				if (src._serializeFields)
					src._serializeFields = new Base(
							this.prototype._serializeFields, src._serializeFields);
				return extend.base.apply(this, arguments);
			},
	
			NO_INSERT: { insert: false }
		},
	
		_class: 'Item',
		_applyMatrix: true,
		_canApplyMatrix: true,
		_boundsSelected: false,
		_selectChildren: false,
		_serializeFields: {
			name: null,
			applyMatrix: null,
			matrix: new Matrix(),
			pivot: null,
			locked: false,
			visible: true,
			blendMode: 'normal',
			opacity: 1,
			guide: false,
			selected: false,
			clipMask: false,
			data: {}
		},
	
		initialize: function Item() {
		},
	
		_initialize: function(props, point) {
			var hasProps = props && Base.isPlainObject(props),
				internal = hasProps && props.internal === true,
				matrix = this._matrix = new Matrix(),
				project = hasProps && props.project || paper.project;
			if (!internal)
				this._id = UID.get();
			this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
			if (point)
				matrix.translate(point);
			matrix._owner = this;
			this._style = new Style(project._currentStyle, this, project);
			if (!this._project) {
				if (internal || hasProps && props.insert === false) {
					this._setProject(project);
				} else if (hasProps && props.parent) {
					this.setParent(props.parent);
				} else {
					(project._activeLayer || new Layer()).addChild(this);
				}
			}
			if (hasProps && props !== Item.NO_INSERT)
				this._set(props, { insert: true, project: true, parent: true },
						true);
			return hasProps;
		},
	
		_events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
				'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = {
					install: function(type) {
						this.getView()._installEvent(type);
					},
	
					uninstall: function(type) {
						this.getView()._uninstallEvent(type);
					}
				};
			}, {
				onFrame: {
					install: function() {
						this.getView()._animateItem(this, true);
					},
	
					uninstall: function() {
						this.getView()._animateItem(this, false);
					}
				},
	
				onLoad: {}
			}
		),
	
		_serialize: function(options, dictionary) {
			var props = {},
				that = this;
	
			function serialize(fields) {
				for (var key in fields) {
					var value = that[key];
					if (!Base.equals(value, key === 'leading'
							? fields.fontSize * 1.2 : fields[key])) {
						props[key] = Base.serialize(value, options,
								key !== 'data', dictionary);
					}
				}
			}
	
			serialize(this._serializeFields);
			if (!(this instanceof Group))
				serialize(this._style._defaults);
			return [ this._class, props ];
		},
	
		_changed: function(flags) {
			var symbol = this._parentSymbol,
				cacheParent = this._parent || symbol,
				project = this._project;
			if (flags & 8) {
				this._bounds = this._position = this._decomposed =
						this._globalMatrix = this._currentPath = undefined;
			}
			if (cacheParent
					&& (flags & 40)) {
				Item._clearBoundsCache(cacheParent);
			}
			if (flags & 2) {
				Item._clearBoundsCache(this);
			}
			if (project) {
				if (flags & 1) {
					project._needsUpdate = true;
				}
				if (project._changes) {
					var entry = project._changesById[this._id];
					if (entry) {
						entry.flags |= flags;
					} else {
						entry = { item: this, flags: flags };
						project._changesById[this._id] = entry;
						project._changes.push(entry);
					}
				}
			}
			if (symbol)
				symbol._changed(flags);
		},
	
		set: function(props) {
			if (props)
				this._set(props);
			return this;
		},
	
		getId: function() {
			return this._id;
		},
	
		getName: function() {
			return this._name;
		},
	
		setName: function(name, unique) {
	
			if (this._name)
				this._removeNamed();
			if (name === (+name) + '')
				throw new Error(
						'Names consisting only of numbers are not supported.');
			var parent = this._parent;
			if (name && parent) {
				var children = parent._children,
					namedChildren = parent._namedChildren,
					orig = name,
					i = 1;
				while (unique && children[name])
					name = orig + ' ' + (i++);
				(namedChildren[name] = namedChildren[name] || []).push(this);
				children[name] = this;
			}
			this._name = name || undefined;
			this._changed(128);
		},
	
		getStyle: function() {
			return this._style;
		},
	
		setStyle: function(style) {
			this.getStyle().set(style);
		}
	}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
		function(name) {
			var part = Base.capitalize(name),
				name = '_' + name;
			this['get' + part] = function() {
				return this[name];
			};
			this['set' + part] = function(value) {
				if (value != this[name]) {
					this[name] = value;
					this._changed(name === '_locked'
							? 128 : 129);
				}
			};
		},
	{}), {
		beans: true,
	
		_locked: false,
	
		_visible: true,
	
		_blendMode: 'normal',
	
		_opacity: 1,
	
		_guide: false,
	
		isSelected: function() {
			if (this._selectChildren) {
				var children = this._children;
				for (var i = 0, l = children.length; i < l; i++)
					if (children[i].isSelected())
						return true;
			}
			return this._selected;
		},
	
		setSelected: function(selected, noChildren) {
			if (!noChildren && this._selectChildren) {
				var children = this._children;
				for (var i = 0, l = children.length; i < l; i++)
					children[i].setSelected(selected);
			}
			if ((selected = !!selected) ^ this._selected) {
				this._selected = selected;
				this._project._updateSelection(this);
				this._changed(129);
			}
		},
	
		_selected: false,
	
		isFullySelected: function() {
			var children = this._children;
			if (children && this._selected) {
				for (var i = 0, l = children.length; i < l; i++)
					if (!children[i].isFullySelected())
						return false;
				return true;
			}
			return this._selected;
		},
	
		setFullySelected: function(selected) {
			var children = this._children;
			if (children) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i].setFullySelected(selected);
			}
			this.setSelected(selected, true);
		},
	
		isClipMask: function() {
			return this._clipMask;
		},
	
		setClipMask: function(clipMask) {
			if (this._clipMask != (clipMask = !!clipMask)) {
				this._clipMask = clipMask;
				if (clipMask) {
					this.setFillColor(null);
					this.setStrokeColor(null);
				}
				this._changed(129);
				if (this._parent)
					this._parent._changed(1024);
			}
		},
	
		_clipMask: false,
	
		getData: function() {
			if (!this._data)
				this._data = {};
			return this._data;
		},
	
		setData: function(data) {
			this._data = data;
		},
	
		getPosition: function(_dontLink) {
			var position = this._position,
				ctor = _dontLink ? Point : LinkedPoint;
			if (!position) {
				var pivot = this._pivot;
				position = this._position = pivot
						? this._matrix._transformPoint(pivot)
						: this.getBounds().getCenter(true);
			}
			return new ctor(position.x, position.y, this, 'setPosition');
		},
	
		setPosition: function() {
			this.translate(Point.read(arguments).subtract(this.getPosition(true)));
		},
	
		getPivot: function(_dontLink) {
			var pivot = this._pivot;
			if (pivot) {
				var ctor = _dontLink ? Point : LinkedPoint;
				pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
			}
			return pivot;
		},
	
		setPivot: function() {
			this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
			this._position = undefined;
		},
	
		_pivot: null,
	}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
			'internalBounds', 'internalRoughBounds'],
		function(key) {
			var getter = 'get' + Base.capitalize(key),
				match = key.match(/^internal(.*)$/),
				internalGetter = match ? 'get' + match[1] : null;
			this[getter] = function(_matrix) {
				var boundsGetter = this._boundsGetter,
					name = !internalGetter && (typeof boundsGetter === 'string'
							? boundsGetter : boundsGetter && boundsGetter[getter])
							|| getter,
					bounds = this._getCachedBounds(name, _matrix, this,
							internalGetter);
				return key === 'bounds'
						? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
								bounds.height, this, 'setBounds')
						: bounds;
			};
		},
	{
		beans: true,
	
		_getBounds: function(getter, matrix, cacheItem) {
			var children = this._children;
			if (!children || children.length == 0)
				return new Rectangle();
			Item._updateBoundsCache(this, cacheItem);
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2;
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i];
				if (child._visible && !child.isEmpty()) {
					var rect = child._getCachedBounds(getter,
							matrix && matrix.chain(child._matrix), cacheItem);
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
				}
			}
			return isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle();
		},
	
		setBounds: function() {
			var rect = Rectangle.read(arguments),
				bounds = this.getBounds(),
				matrix = new Matrix(),
				center = rect.getCenter();
			matrix.translate(center);
			if (rect.width != bounds.width || rect.height != bounds.height) {
				matrix.scale(
						bounds.width != 0 ? rect.width / bounds.width : 1,
						bounds.height != 0 ? rect.height / bounds.height : 1);
			}
			center = bounds.getCenter();
			matrix.translate(-center.x, -center.y);
			this.transform(matrix);
		},
	
		_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
			matrix = matrix && matrix.orNullIfIdentity();
			var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
				cache = (!matrix || matrix.equals(_matrix)) && getter;
			Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
			if (cache && this._bounds && this._bounds[cache])
				return this._bounds[cache].clone();
			var bounds = this._getBounds(internalGetter || getter,
					matrix || _matrix, cacheItem);
			if (cache) {
				if (!this._bounds)
					this._bounds = {};
				var cached = this._bounds[cache] = bounds.clone();
				cached._internal = !!internalGetter;
			}
			return bounds;
		},
	
		statics: {
			_updateBoundsCache: function(parent, item) {
				if (parent) {
					var id = item._id,
						ref = parent._boundsCache = parent._boundsCache || {
							ids: {},
							list: []
						};
					if (!ref.ids[id]) {
						ref.list.push(item);
						ref.ids[id] = item;
					}
				}
			},
	
			_clearBoundsCache: function(item) {
				var cache = item._boundsCache;
				if (cache) {
					item._bounds = item._position = item._boundsCache = undefined;
					for (var i = 0, list = cache.list, l = list.length; i < l; i++){
						var other = list[i];
						if (other !== item) {
							other._bounds = other._position = undefined;
							if (other._boundsCache)
								Item._clearBoundsCache(other);
						}
					}
				}
			}
		}
	
	}), {
		beans: true,
	
		_decompose: function() {
			return this._decomposed = this._matrix.decompose();
		},
	
		getRotation: function() {
			var decomposed = this._decomposed || this._decompose();
			return decomposed && decomposed.rotation;
		},
	
		setRotation: function(rotation) {
			var current = this.getRotation();
			if (current != null && rotation != null) {
				var decomposed = this._decomposed;
				this.rotate(rotation - current);
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		},
	
		getScaling: function(_dontLink) {
			var decomposed = this._decomposed || this._decompose(),
				scaling = decomposed && decomposed.scaling,
				ctor = _dontLink ? Point : LinkedPoint;
			return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
		},
	
		setScaling: function() {
			var current = this.getScaling();
			if (current) {
				var scaling = Point.read(arguments, 0, { clone: true }),
					decomposed = this._decomposed;
				this.scale(scaling.x / current.x, scaling.y / current.y);
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		},
	
		getMatrix: function() {
			return this._matrix;
		},
	
		setMatrix: function() {
			var matrix = this._matrix;
			matrix.initialize.apply(matrix, arguments);
			if (this._applyMatrix) {
				this.transform(null, true);
			} else {
				this._changed(9);
			}
		},
	
		getGlobalMatrix: function(_dontClone) {
			var matrix = this._globalMatrix,
				updateVersion = this._project._updateVersion;
			if (matrix && matrix._updateVersion !== updateVersion)
				matrix = null;
			if (!matrix) {
				matrix = this._globalMatrix = this._matrix.clone();
				var parent = this._parent;
				if (parent)
					matrix.preConcatenate(parent.getGlobalMatrix(true));
				matrix._updateVersion = updateVersion;
			}
			return _dontClone ? matrix : matrix.clone();
		},
	
		getApplyMatrix: function() {
			return this._applyMatrix;
		},
	
		setApplyMatrix: function(apply) {
			if (this._applyMatrix = this._canApplyMatrix && !!apply)
				this.transform(null, true);
		},
	
		getTransformContent: '#getApplyMatrix',
		setTransformContent: '#setApplyMatrix',
	}, {
		getProject: function() {
			return this._project;
		},
	
		_setProject: function(project, installEvents) {
			if (this._project !== project) {
				if (this._project)
					this._installEvents(false);
				this._project = project;
				var children = this._children;
				for (var i = 0, l = children && children.length; i < l; i++)
					children[i]._setProject(project);
				installEvents = true;
			}
			if (installEvents)
				this._installEvents(true);
		},
	
		getView: function() {
			return this._project.getView();
		},
	
		_installEvents: function _installEvents(install) {
			_installEvents.base.call(this, install);
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._installEvents(install);
		},
	
		getLayer: function() {
			var parent = this;
			while (parent = parent._parent) {
				if (parent instanceof Layer)
					return parent;
			}
			return null;
		},
	
		getParent: function() {
			return this._parent;
		},
	
		setParent: function(item) {
			return item.addChild(this);
		},
	
		getChildren: function() {
			return this._children;
		},
	
		setChildren: function(items) {
			this.removeChildren();
			this.addChildren(items);
		},
	
		getFirstChild: function() {
			return this._children && this._children[0] || null;
		},
	
		getLastChild: function() {
			return this._children && this._children[this._children.length - 1]
					|| null;
		},
	
		getNextSibling: function() {
			return this._parent && this._parent._children[this._index + 1] || null;
		},
	
		getPreviousSibling: function() {
			return this._parent && this._parent._children[this._index - 1] || null;
		},
	
		getIndex: function() {
			return this._index;
		},
	
		equals: function(item) {
			return item === this || item && this._class === item._class
					&& this._style.equals(item._style)
					&& this._matrix.equals(item._matrix)
					&& this._locked === item._locked
					&& this._visible === item._visible
					&& this._blendMode === item._blendMode
					&& this._opacity === item._opacity
					&& this._clipMask === item._clipMask
					&& this._guide === item._guide
					&& this._equals(item)
					|| false;
		},
	
		_equals: function(item) {
			return Base.equals(this._children, item._children);
		},
	
		clone: function(insert) {
			return this._clone(new this.constructor(Item.NO_INSERT), insert);
		},
	
		_clone: function(copy, insert, includeMatrix) {
			var keys = ['_locked', '_visible', '_blendMode', '_opacity',
					'_clipMask', '_guide'],
				children = this._children;
			copy.setStyle(this._style);
			for (var i = 0, l = children && children.length; i < l; i++) {
				copy.addChild(children[i].clone(false), true);
			}
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				if (this.hasOwnProperty(key))
					copy[key] = this[key];
			}
			if (includeMatrix !== false)
				copy._matrix.initialize(this._matrix);
			copy.setApplyMatrix(this._applyMatrix);
			copy.setPivot(this._pivot);
			copy.setSelected(this._selected);
			copy._data = this._data ? Base.clone(this._data) : null;
			if (insert || insert === undefined)
				copy.insertAbove(this);
			if (this._name)
				copy.setName(this._name, true);
			return copy;
		},
	
		copyTo: function(itemOrProject) {
			return itemOrProject.addChild(this.clone(false));
		},
	
		rasterize: function(resolution) {
			var bounds = this.getStrokeBounds(),
				scale = (resolution || this.getView().getResolution()) / 72,
				topLeft = bounds.getTopLeft().floor(),
				bottomRight = bounds.getBottomRight().ceil(),
				size = new Size(bottomRight.subtract(topLeft)),
				canvas = CanvasProvider.getCanvas(size.multiply(scale)),
				ctx = canvas.getContext('2d'),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
			var raster = new Raster(Item.NO_INSERT);
			raster.setCanvas(canvas);
			raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
					.scale(1 / scale));
			raster.insertAbove(this);
			return raster;
		},
	
		contains: function() {
			return !!this._contains(
					this._matrix._inverseTransform(Point.read(arguments)));
		},
	
		_contains: function(point) {
			if (this._children) {
				for (var i = this._children.length - 1; i >= 0; i--) {
					if (this._children[i].contains(point))
						return true;
				}
				return false;
			}
			return point.isInside(this.getInternalBounds());
		},
	
		isInside: function() {
			return Rectangle.read(arguments).contains(this.getBounds());
		},
	
		_asPathItem: function() {
			return new Path.Rectangle({
				rectangle: this.getInternalBounds(),
				matrix: this._matrix,
				insert: false,
			});
		},
	
		intersects: function(item, _matrix) {
			if (!(item instanceof Item))
				return false;
			return this._asPathItem().getIntersections(item._asPathItem(), null,
					_matrix || item._matrix, true).length > 0;
		},
	
		hitTest: function() {
			return this._hitTest(
					Point.read(arguments),
					HitResult.getOptions(Base.read(arguments)));
		},
	
		_hitTest: function(point, options) {
			if (this._locked || !this._visible || this._guide && !options.guides
					|| this.isEmpty())
				return null;
	
			var matrix = this._matrix,
				parentTotalMatrix = options._totalMatrix,
				view = this.getView(),
				totalMatrix = options._totalMatrix = parentTotalMatrix
						? parentTotalMatrix.chain(matrix)
						: this.getGlobalMatrix().preConcatenate(view._matrix),
				tolerancePadding = options._tolerancePadding = new Size(
							Path._getPenPadding(1, totalMatrix.inverted())
						).multiply(
							Math.max(options.tolerance, 1e-6)
						);
			point = matrix._inverseTransform(point);
	
			if (!this._children && !this.getInternalRoughBounds()
					.expand(tolerancePadding.multiply(2))._containsPoint(point))
				return null;
			var checkSelf = !(options.guides && !this._guide
					|| options.selected && !this._selected
					|| options.type && options.type !== Base.hyphenate(this._class)
					|| options.class && !(this instanceof options.class)),
				that = this,
				res;
	
			function checkBounds(type, part) {
				var pt = bounds['get' + part]();
				if (point.subtract(pt).divide(tolerancePadding).length <= 1)
					return new HitResult(type, that,
							{ name: Base.hyphenate(part), point: pt });
			}
	
			if (checkSelf && (options.center || options.bounds) && this._parent) {
				var bounds = this.getInternalBounds();
				if (options.center)
					res = checkBounds('center', 'Center');
				if (!res && options.bounds) {
					var points = [
						'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
						'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
					];
					for (var i = 0; i < 8 && !res; i++)
						res = checkBounds('bounds', points[i]);
				}
			}
	
			var children = !res && this._children;
			if (children) {
				var opts = this._getChildHitTestOptions(options);
				for (var i = children.length - 1; i >= 0 && !res; i--)
					res = children[i]._hitTest(point, opts);
			}
			if (!res && checkSelf)
				res = this._hitTestSelf(point, options);
			if (res && res.point)
				res.point = matrix.transform(res.point);
			options._totalMatrix = parentTotalMatrix;
			return res;
		},
	
		_getChildHitTestOptions: function(options) {
			return options;
		},
	
		_hitTestSelf: function(point, options) {
			if (options.fill && this.hasFill() && this._contains(point))
				return new HitResult('fill', this);
		},
	
		matches: function(name, compare) {
			function matchObject(obj1, obj2) {
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)) {
						var val1 = obj1[i],
							val2 = obj2[i];
						if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
							if (!matchObject(val1, val2))
								return false;
						} else if (!Base.equals(val1, val2)) {
							return false;
						}
					}
				}
				return true;
			}
			var type = typeof name;
			if (type === 'object') {
				for (var key in name) {
					if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
						return false;
				}
			} else if (type === 'function') {
				return name(this);
			} else {
				var value = /^(empty|editable)$/.test(name)
						? this['is' + Base.capitalize(name)]()
						: name === 'type'
							? Base.hyphenate(this._class)
							: this[name];
				if (/^(constructor|class)$/.test(name)) {
					if (!(this instanceof compare))
						return false;
				} else if (compare instanceof RegExp) {
					if (!compare.test(value))
						return false;
				} else if (typeof compare === 'function') {
					if (!compare(value))
						return false;
				} else if (Base.isPlainObject(compare)) {
					if (!matchObject(compare, value))
						return false;
				} else if (!Base.equals(value, compare)) {
					return false;
				}
			}
			return true;
		},
	
		getItems: function(match) {
			return Item._getItems(this._children, match, this._matrix);
		},
	
		getItem: function(match) {
			return Item._getItems(this._children, match, this._matrix, null, true)
					[0] || null;
		},
	
		statics: {
			_getItems: function _getItems(children, match, matrix, param,
					firstOnly) {
				if (!param && typeof match === 'object') {
					var overlapping = match.overlapping,
						inside = match.inside,
						bounds = overlapping || inside,
						rect = bounds && Rectangle.read([bounds]);
					param = {
						items: [],
						inside: !!inside,
						overlapping: !!overlapping,
						rect: rect,
						path: overlapping && new Path.Rectangle({
							rectangle: rect,
							insert: false
						})
					};
					if (bounds)
						match = Base.set({}, match,
								{ inside: true, overlapping: true });
				}
				var items = param && param.items,
					rect = param && param.rect;
				matrix = rect && (matrix || new Matrix());
				for (var i = 0, l = children && children.length; i < l; i++) {
					var child = children[i],
						childMatrix = matrix && matrix.chain(child._matrix),
						add = true;
					if (rect) {
						var bounds = child.getBounds(childMatrix);
						if (!rect.intersects(bounds))
							continue;
						if (!(param.inside && rect.contains(bounds))
								&& !(param.overlapping && (bounds.contains(rect)
									|| param.path.intersects(child, childMatrix))))
							add = false;
					}
					if (add && child.matches(match)) {
						items.push(child);
						if (firstOnly)
							break;
					}
					_getItems(child._children, match,
							childMatrix, param,
							firstOnly);
					if (firstOnly && items.length > 0)
						break;
				}
				return items;
			}
		}
	}, {
	
		importJSON: function(json) {
			var res = Base.importJSON(json, this);
			return res !== this
					? this.addChild(res)
					: res;
		},
	
		addChild: function(item, _preserve) {
			return this.insertChild(undefined, item, _preserve);
		},
	
		insertChild: function(index, item, _preserve) {
			var res = item ? this.insertChildren(index, [item], _preserve) : null;
			return res && res[0];
		},
	
		addChildren: function(items, _preserve) {
			return this.insertChildren(this._children.length, items, _preserve);
		},
	
		insertChildren: function(index, items, _preserve, _proto) {
			var children = this._children;
			if (children && items && items.length > 0) {
				items = Array.prototype.slice.apply(items);
				for (var i = items.length - 1; i >= 0; i--) {
					var item = items[i];
					if (_proto && !(item instanceof _proto)) {
						items.splice(i, 1);
					} else {
						var shift = item._parent === this && item._index < index;
						if (item._remove(false, true) && shift)
							index--;
					}
				}
				Base.splice(children, items, index, 0);
				var project = this._project,
					notifySelf = project && project._changes;
				for (var i = 0, l = items.length; i < l; i++) {
					var item = items[i];
					item._parent = this;
					item._setProject(this._project, true);
					if (item._name)
						item.setName(item._name);
					if (notifySelf)
						this._changed(5);
				}
				this._changed(11);
			} else {
				items = null;
			}
			return items;
		},
	
		_insertSibling: function(index, item, _preserve) {
			return this._parent
					? this._parent.insertChild(index, item, _preserve)
					: null;
		},
	
		insertAbove: function(item, _preserve) {
			return item._insertSibling(item._index + 1, this, _preserve);
		},
	
		insertBelow: function(item, _preserve) {
			return item._insertSibling(item._index, this, _preserve);
		},
	
		sendToBack: function() {
			return (this._parent || this instanceof Layer && this._project)
					.insertChild(0, this);
		},
	
		bringToFront: function() {
			return (this._parent || this instanceof Layer && this._project)
					.addChild(this);
		},
	
		appendTop: '#addChild',
	
		appendBottom: function(item) {
			return this.insertChild(0, item);
		},
	
		moveAbove: '#insertAbove',
	
		moveBelow: '#insertBelow',
	
		reduce: function() {
			if (this._children && this._children.length === 1) {
				var child = this._children[0].reduce();
				child.insertAbove(this);
				child.setStyle(this._style);
				this.remove();
				return child;
			}
			return this;
		},
	
		_removeNamed: function() {
			var parent = this._parent;
			if (parent) {
				var children = parent._children,
					namedChildren = parent._namedChildren,
					name = this._name,
					namedArray = namedChildren[name],
					index = namedArray ? namedArray.indexOf(this) : -1;
				if (index !== -1) {
					if (children[name] == this)
						delete children[name];
					namedArray.splice(index, 1);
					if (namedArray.length) {
						children[name] = namedArray[namedArray.length - 1];
					} else {
						delete namedChildren[name];
					}
				}
			}
		},
	
		_remove: function(notifySelf, notifyParent) {
			var parent = this._parent;
			if (parent) {
				if (this._name)
					this._removeNamed();
				if (this._index != null)
					Base.splice(parent._children, null, this._index, 1);
				this._installEvents(false);
				if (notifySelf) {
					var project = this._project;
					if (project && project._changes)
						this._changed(5);
				}
				if (notifyParent)
					parent._changed(11);
				this._parent = null;
				return true;
			}
			return false;
		},
	
		remove: function() {
			return this._remove(true, true);
		},
	
		replaceWith: function(item) {
			var ok = item && item.insertBelow(this);
			if (ok)
				this.remove();
			return ok;
		},
	
		removeChildren: function(from, to) {
			if (!this._children)
				return null;
			from = from || 0;
			to = Base.pick(to, this._children.length);
			var removed = Base.splice(this._children, null, from, to - from);
			for (var i = removed.length - 1; i >= 0; i--) {
				removed[i]._remove(true, false);
			}
			if (removed.length > 0)
				this._changed(11);
			return removed;
		},
	
		clear: '#removeChildren',
	
		reverseChildren: function() {
			if (this._children) {
				this._children.reverse();
				for (var i = 0, l = this._children.length; i < l; i++)
					this._children[i]._index = i;
				this._changed(11);
			}
		},
	
		isEmpty: function() {
			return !this._children || this._children.length === 0;
		},
	
		isEditable: function() {
			var item = this;
			while (item) {
				if (!item._visible || item._locked)
					return false;
				item = item._parent;
			}
			return true;
		},
	
		hasFill: function() {
			return this.getStyle().hasFill();
		},
	
		hasStroke: function() {
			return this.getStyle().hasStroke();
		},
	
		hasShadow: function() {
			return this.getStyle().hasShadow();
		},
	
		_getOrder: function(item) {
			function getList(item) {
				var list = [];
				do {
					list.unshift(item);
				} while (item = item._parent);
				return list;
			}
			var list1 = getList(this),
				list2 = getList(item);
			for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
				if (list1[i] != list2[i]) {
					return list1[i]._index < list2[i]._index ? 1 : -1;
				}
			}
			return 0;
		},
	
		hasChildren: function() {
			return this._children && this._children.length > 0;
		},
	
		isInserted: function() {
			return this._parent ? this._parent.isInserted() : false;
		},
	
		isAbove: function(item) {
			return this._getOrder(item) === -1;
		},
	
		isBelow: function(item) {
			return this._getOrder(item) === 1;
		},
	
		isParent: function(item) {
			return this._parent === item;
		},
	
		isChild: function(item) {
			return item && item._parent === this;
		},
	
		isDescendant: function(item) {
			var parent = this;
			while (parent = parent._parent) {
				if (parent == item)
					return true;
			}
			return false;
		},
	
		isAncestor: function(item) {
			return item ? item.isDescendant(this) : false;
		},
	
		isSibling: function(item) {
			return this._parent === item._parent;
		},
	
		isGroupedWith: function(item) {
			var parent = this._parent;
			while (parent) {
				if (parent._parent
					&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
					&& item.isDescendant(parent))
						return true;
				parent = parent._parent;
			}
			return false;
		},
	
		translate: function() {
			var mx = new Matrix();
			return this.transform(mx.translate.apply(mx, arguments));
		},
	
		rotate: function(angle ) {
			return this.transform(new Matrix().rotate(angle,
					Point.read(arguments, 1, { readNull: true })
						|| this.getPosition(true)));
		}
	}, Base.each(['scale', 'shear', 'skew'], function(name) {
		this[name] = function() {
			var point = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true });
			return this.transform(new Matrix()[name](point,
					center || this.getPosition(true)));
		};
	}, {
	
	}), {
		transform: function(matrix, _applyMatrix, _applyRecursively,
				_setApplyMatrix) {
			if (matrix && matrix.isIdentity())
				matrix = null;
			var _matrix = this._matrix,
				applyMatrix = (_applyMatrix || this._applyMatrix)
						&& ((!_matrix.isIdentity() || matrix)
							|| _applyMatrix && _applyRecursively && this._children);
			if (!matrix && !applyMatrix)
				return this;
			if (matrix)
				_matrix.preConcatenate(matrix);
			if (applyMatrix = applyMatrix && this._transformContent(_matrix,
						_applyRecursively, _setApplyMatrix)) {
				var pivot = this._pivot,
					style = this._style,
					fillColor = style.getFillColor(true),
					strokeColor = style.getStrokeColor(true);
				if (pivot)
					_matrix._transformPoint(pivot, pivot, true);
				if (fillColor)
					fillColor.transform(_matrix);
				if (strokeColor)
					strokeColor.transform(_matrix);
				_matrix.reset(true);
				if (_setApplyMatrix && this._canApplyMatrix)
					this._applyMatrix = true;
			}
			var bounds = this._bounds,
				position = this._position;
			this._changed(9);
			var decomp = bounds && matrix && matrix.decompose();
			if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
				for (var key in bounds) {
					var rect = bounds[key];
					if (applyMatrix || !rect._internal)
						matrix._transformBounds(rect, rect);
				}
				var getter = this._boundsGetter,
					rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
				if (rect)
					this._position = rect.getCenter(true);
				this._bounds = bounds;
			} else if (matrix && position) {
				this._position = matrix._transformPoint(position, position);
			}
			return this;
		},
	
		_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
			var children = this._children;
			if (children) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i].transform(matrix, true, applyRecursively,
							setApplyMatrix);
				return true;
			}
		},
	
		globalToLocal: function() {
			return this.getGlobalMatrix(true)._inverseTransform(
					Point.read(arguments));
		},
	
		localToGlobal: function() {
			return this.getGlobalMatrix(true)._transformPoint(
					Point.read(arguments));
		},
	
		parentToLocal: function() {
			return this._matrix._inverseTransform(Point.read(arguments));
		},
	
		localToParent: function() {
			return this._matrix._transformPoint(Point.read(arguments));
		},
	
		fitBounds: function(rectangle, fill) {
			rectangle = Rectangle.read(arguments);
			var bounds = this.getBounds(),
				itemRatio = bounds.height / bounds.width,
				rectRatio = rectangle.height / rectangle.width,
				scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
						? rectangle.width / bounds.width
						: rectangle.height / bounds.height,
				newBounds = new Rectangle(new Point(),
						new Size(bounds.width * scale, bounds.height * scale));
			newBounds.setCenter(rectangle.getCenter());
			this.setBounds(newBounds);
		},
	
		_setStyles: function(ctx) {
			var style = this._style,
				fillColor = style.getFillColor(),
				strokeColor = style.getStrokeColor(),
				shadowColor = style.getShadowColor();
			if (fillColor)
				ctx.fillStyle = fillColor.toCanvasStyle(ctx);
			if (strokeColor) {
				var strokeWidth = style.getStrokeWidth();
				if (strokeWidth > 0) {
					ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
					ctx.lineWidth = strokeWidth;
					var strokeJoin = style.getStrokeJoin(),
						strokeCap = style.getStrokeCap(),
						miterLimit = style.getMiterLimit();
					if (strokeJoin)
						ctx.lineJoin = strokeJoin;
					if (strokeCap)
						ctx.lineCap = strokeCap;
					if (miterLimit)
						ctx.miterLimit = miterLimit;
					if (paper.support.nativeDash) {
						var dashArray = style.getDashArray(),
							dashOffset = style.getDashOffset();
						if (dashArray && dashArray.length) {
							if ('setLineDash' in ctx) {
								ctx.setLineDash(dashArray);
								ctx.lineDashOffset = dashOffset;
							} else {
								ctx.mozDash = dashArray;
								ctx.mozDashOffset = dashOffset;
							}
						}
					}
				}
			}
			if (shadowColor) {
				var shadowBlur = style.getShadowBlur();
				if (shadowBlur > 0) {
					ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
					ctx.shadowBlur = shadowBlur;
					var offset = this.getShadowOffset();
					ctx.shadowOffsetX = offset.x;
					ctx.shadowOffsetY = offset.y;
				}
			}
		},
	
		draw: function(ctx, param, parentStrokeMatrix) {
			var updateVersion = this._updateVersion = this._project._updateVersion;
			if (!this._visible || this._opacity === 0)
				return;
			var matrices = param.matrices,
				viewMatrix = param.viewMatrix,
				matrix = this._matrix,
				globalMatrix = matrices[matrices.length - 1].chain(matrix);
			if (!globalMatrix.isInvertible())
				return;
	
			function getViewMatrix(matrix) {
				return viewMatrix ? viewMatrix.chain(matrix) : matrix;
			}
	
			matrices.push(globalMatrix);
			if (param.updateMatrix) {
				globalMatrix._updateVersion = updateVersion;
				this._globalMatrix = globalMatrix;
			}
	
			var blendMode = this._blendMode,
				opacity = this._opacity,
				normalBlend = blendMode === 'normal',
				nativeBlend = BlendMode.nativeModes[blendMode],
				direct = normalBlend && opacity === 1
						|| param.dontStart
						|| param.clip
						|| (nativeBlend || normalBlend && opacity < 1)
							&& this._canComposite(),
				pixelRatio = param.pixelRatio || 1,
				mainCtx, itemOffset, prevOffset;
			if (!direct) {
				var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
				if (!bounds.width || !bounds.height)
					return;
				prevOffset = param.offset;
				itemOffset = param.offset = bounds.getTopLeft().floor();
				mainCtx = ctx;
				ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
						.multiply(pixelRatio));
				if (pixelRatio !== 1)
					ctx.scale(pixelRatio, pixelRatio);
			}
			ctx.save();
			var strokeMatrix = parentStrokeMatrix
					? parentStrokeMatrix.chain(matrix)
					: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
				clip = !direct && param.clipItem,
				transform = !strokeMatrix || clip;
			if (direct) {
				ctx.globalAlpha = opacity;
				if (nativeBlend)
					ctx.globalCompositeOperation = blendMode;
			} else if (transform) {
				ctx.translate(-itemOffset.x, -itemOffset.y);
			}
			if (transform)
				(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
			if (clip)
				param.clipItem.draw(ctx, param.extend({ clip: true }));
			if (strokeMatrix) {
				ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
				var offset = param.offset;
				if (offset)
					ctx.translate(-offset.x, -offset.y);
			}
			this._draw(ctx, param, strokeMatrix);
			ctx.restore();
			matrices.pop();
			if (param.clip && !param.dontFinish)
				ctx.clip();
			if (!direct) {
				BlendMode.process(blendMode, ctx, mainCtx, opacity,
						itemOffset.subtract(prevOffset).multiply(pixelRatio));
				CanvasProvider.release(ctx);
				param.offset = prevOffset;
			}
		},
	
		_isUpdated: function(updateVersion) {
			var parent = this._parent;
			if (parent instanceof CompoundPath)
				return parent._isUpdated(updateVersion);
			var updated = this._updateVersion === updateVersion;
			if (!updated && parent && parent._visible
					&& parent._isUpdated(updateVersion)) {
				this._updateVersion = updateVersion;
				updated = true;
			}
			return updated;
		},
	
		_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
			if ((this._drawSelected || this._boundsSelected)
					&& this._isUpdated(updateVersion)) {
				var color = this.getSelectedColor(true)
						|| this.getLayer().getSelectedColor(true),
					mx = matrix.chain(this.getGlobalMatrix(true));
				ctx.strokeStyle = ctx.fillStyle = color
						? color.toCanvasStyle(ctx) : '#009dec';
				if (this._drawSelected)
					this._drawSelected(ctx, mx, selectedItems);
				if (this._boundsSelected) {
					var half = size / 2,
						coords = mx._transformCorners(this.getInternalBounds());
					ctx.beginPath();
					for (var i = 0; i < 8; i++)
						ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
					ctx.closePath();
					ctx.stroke();
					for (var i = 0; i < 8; i++)
						ctx.fillRect(coords[i] - half, coords[++i] - half,
								size, size);
				}
			}
		},
	
		_canComposite: function() {
			return false;
		}
	}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
		this['removeOn' + Base.capitalize(name)] = function() {
			var hash = {};
			hash[name] = true;
			return this.removeOn(hash);
		};
	}, {
	
		removeOn: function(obj) {
			for (var name in obj) {
				if (obj[name]) {
					var key = 'mouse' + name,
						project = this._project,
						sets = project._removeSets = project._removeSets || {};
					sets[key] = sets[key] || {};
					sets[key][this._id] = this;
				}
			}
			return this;
		}
	}));
	
	var Group = Item.extend({
		_class: 'Group',
		_selectChildren: true,
		_serializeFields: {
			children: []
		},
	
		initialize: function Group(arg) {
			this._children = [];
			this._namedChildren = {};
			if (!this._initialize(arg))
				this.addChildren(Array.isArray(arg) ? arg : arguments);
		},
	
		_changed: function _changed(flags) {
			_changed.base.call(this, flags);
			if (flags & 1026) {
				this._clipItem = undefined;
			}
		},
	
		_getClipItem: function() {
			var clipItem = this._clipItem;
			if (clipItem === undefined) {
				clipItem = null;
				for (var i = 0, l = this._children.length; i < l; i++) {
					var child = this._children[i];
					if (child._clipMask) {
						clipItem = child;
						break;
					}
				}
				this._clipItem = clipItem;
			}
			return clipItem;
		},
	
		isClipped: function() {
			return !!this._getClipItem();
		},
	
		setClipped: function(clipped) {
			var child = this.getFirstChild();
			if (child)
				child.setClipMask(clipped);
		},
	
		_draw: function(ctx, param) {
			var clip = param.clip,
				clipItem = !clip && this._getClipItem(),
				draw = true;
			param = param.extend({ clipItem: clipItem, clip: false });
			if (clip) {
				if (this._currentPath) {
					ctx.currentPath = this._currentPath;
					draw = false;
				} else {
					ctx.beginPath();
					param.dontStart = param.dontFinish = true;
				}
			} else if (clipItem) {
				clipItem.draw(ctx, param.extend({ clip: true }));
			}
			if (draw) {
				for (var i = 0, l = this._children.length; i < l; i++) {
					var item = this._children[i];
					if (item !== clipItem)
						item.draw(ctx, param);
				}
			}
			if (clip) {
				this._currentPath = ctx.currentPath;
			}
		}
	});
	
	var Layer = Group.extend({
		_class: 'Layer',
	
		initialize: function Layer(arg) {
			var props = Base.isPlainObject(arg)
					? new Base(arg)
					: { children: Array.isArray(arg) ? arg : arguments },
				insert = props.insert;
			props.insert = false;
			Group.call(this, props);
			if (insert || insert === undefined) {
				this._project.addChild(this);
				this.activate();
			}
		},
	
		_remove: function _remove(notifySelf, notifyParent) {
			if (this._parent)
				return _remove.base.call(this, notifySelf, notifyParent);
			if (this._index != null) {
				var project = this._project;
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(project.layers, null, this._index, 1);
				this._installEvents(false);
				if (notifySelf && project._changes)
					this._changed(5);
				if (notifyParent) {
					project._needsUpdate = true;
				}
				return true;
			}
			return false;
		},
	
		getNextSibling: function getNextSibling() {
			return this._parent ? getNextSibling.base.call(this)
					: this._project.layers[this._index + 1] || null;
		},
	
		getPreviousSibling: function getPreviousSibling() {
			return this._parent ? getPreviousSibling.base.call(this)
					: this._project.layers[this._index - 1] || null;
		},
	
		isInserted: function isInserted() {
			return this._parent ? isInserted.base.call(this) : this._index != null;
		},
	
		activate: function() {
			this._project._activeLayer = this;
		},
	
		_insertSibling: function _insertSibling(index, item, _preserve) {
			return !this._parent
					? this._project.insertChild(index, item, _preserve)
					: _insertSibling.base.call(this, index, item, _preserve);
		}
	});
	
	var Shape = Item.extend({
		_class: 'Shape',
		_applyMatrix: false,
		_canApplyMatrix: false,
		_boundsSelected: true,
		_serializeFields: {
			type: null,
			size: null,
			radius: null
		},
	
		initialize: function Shape(props) {
			this._initialize(props);
		},
	
		_equals: function(item) {
			return this._type === item._type
				&& this._size.equals(item._size)
				&& Base.equals(this._radius, item._radius);
		},
	
		clone: function(insert) {
			var copy = new Shape(Item.NO_INSERT);
			copy.setType(this._type);
			copy.setSize(this._size);
			copy.setRadius(this._radius);
			return this._clone(copy, insert);
		},
	
		getType: function() {
			return this._type;
		},
	
		setType: function(type) {
			this._type = type;
		},
	
		getShape: '#getType',
		setShape: '#setType',
	
		getSize: function() {
			var size = this._size;
			return new LinkedSize(size.width, size.height, this, 'setSize');
		},
	
		setSize: function() {
			var size = Size.read(arguments);
			if (!this._size) {
				this._size = size.clone();
			} else if (!this._size.equals(size)) {
				var type = this._type,
					width = size.width,
					height = size.height;
				if (type === 'rectangle') {
					var radius = Size.min(this._radius, size.divide(2));
					this._radius.set(radius.width, radius.height);
				} else if (type === 'circle') {
					width = height = (width + height) / 2;
					this._radius = width / 2;
				} else if (type === 'ellipse') {
					this._radius.set(width / 2, height / 2);
				}
				this._size.set(width, height);
				this._changed(9);
			}
		},
	
		getRadius: function() {
			var rad = this._radius;
			return this._type === 'circle'
					? rad
					: new LinkedSize(rad.width, rad.height, this, 'setRadius');
		},
	
		setRadius: function(radius) {
			var type = this._type;
			if (type === 'circle') {
				if (radius === this._radius)
					return;
				var size = radius * 2;
				this._radius = radius;
				this._size.set(size, size);
			} else {
				radius = Size.read(arguments);
				if (!this._radius) {
					this._radius = radius.clone();
				} else {
					if (this._radius.equals(radius))
						return;
					this._radius.set(radius.width, radius.height);
					if (type === 'rectangle') {
						var size = Size.max(this._size, radius.multiply(2));
						this._size.set(size.width, size.height);
					} else if (type === 'ellipse') {
						this._size.set(radius.width * 2, radius.height * 2);
					}
				}
			}
			this._changed(9);
		},
	
		isEmpty: function() {
			return false;
		},
	
		toPath: function(insert) {
			var path = this._clone(new Path[Base.capitalize(this._type)]({
				center: new Point(),
				size: this._size,
				radius: this._radius,
				insert: false
			}), insert);
			if (paper.settings.applyMatrix)
				path.setApplyMatrix(true);
			return path;
		},
	
		_draw: function(ctx, param, strokeMatrix) {
			var style = this._style,
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dontPaint = param.dontFinish || param.clip,
				untransformed = !strokeMatrix;
			if (hasFill || hasStroke || dontPaint) {
				var type = this._type,
					radius = this._radius,
					isCircle = type === 'circle';
				if (!param.dontStart)
					ctx.beginPath();
				if (untransformed && isCircle) {
					ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
				} else {
					var rx = isCircle ? radius : radius.width,
						ry = isCircle ? radius : radius.height,
						size = this._size,
						width = size.width,
						height = size.height;
					if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
						ctx.rect(-width / 2, -height / 2, width, height);
					} else {
						var x = width / 2,
							y = height / 2,
							kappa = 1 - 0.5522847498307936,
							cx = rx * kappa,
							cy = ry * kappa,
							c = [
								-x, -y + ry,
								-x, -y + cy,
								-x + cx, -y,
								-x + rx, -y,
								x - rx, -y,
								x - cx, -y,
								x, -y + cy,
								x, -y + ry,
								x, y - ry,
								x, y - cy,
								x - cx, y,
								x - rx, y,
								-x + rx, y,
								-x + cx, y,
								-x, y - cy,
								-x, y - ry
							];
						if (strokeMatrix)
							strokeMatrix.transform(c, c, 32);
						ctx.moveTo(c[0], c[1]);
						ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
						if (x !== rx)
							ctx.lineTo(c[8], c[9]);
						ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
						if (y !== ry)
							ctx.lineTo(c[16], c[17]);
						ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
						if (x !== rx)
							ctx.lineTo(c[24], c[25]);
						ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
					}
				}
				ctx.closePath();
			}
			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke)
					ctx.stroke();
			}
		},
	
		_canComposite: function() {
			return !(this.hasFill() && this.hasStroke());
		},
	
		_getBounds: function(getter, matrix) {
			var rect = new Rectangle(this._size).setCenter(0, 0);
			if (getter !== 'getBounds' && this.hasStroke())
				rect = rect.expand(this.getStrokeWidth());
			return matrix ? matrix._transformBounds(rect) : rect;
		}
	},
	new function() {
		function getCornerCenter(that, point, expand) {
			var radius = that._radius;
			if (!radius.isZero()) {
				var halfSize = that._size.divide(2);
				for (var i = 0; i < 4; i++) {
					var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
						corner = dir.multiply(halfSize),
						center = corner.subtract(dir.multiply(radius)),
						rect = new Rectangle(corner, center);
					if ((expand ? rect.expand(expand) : rect).contains(point))
						return center;
				}
			}
		}
	
		function getEllipseRadius(point, radius) {
			var angle = point.getAngleInRadians(),
				width = radius.width * 2,
				height = radius.height * 2,
				x = width * Math.sin(angle),
				y = height * Math.cos(angle);
			return width * height / (2 * Math.sqrt(x * x + y * y));
		}
	
		return {
			_contains: function _contains(point) {
				if (this._type === 'rectangle') {
					var center = getCornerCenter(this, point);
					return center
							? point.subtract(center).divide(this._radius)
								.getLength() <= 1
							: _contains.base.call(this, point);
				} else {
					return point.divide(this.size).getLength() <= 0.5;
				}
			},
	
			_hitTestSelf: function _hitTestSelf(point, options) {
				var hit = false;
				if (this.hasStroke()) {
					var type = this._type,
						radius = this._radius,
						strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
					if (type === 'rectangle') {
						var center = getCornerCenter(this, point, strokeWidth);
						if (center) {
							var pt = point.subtract(center);
							hit = 2 * Math.abs(pt.getLength()
									- getEllipseRadius(pt, radius)) <= strokeWidth;
						} else {
							var rect = new Rectangle(this._size).setCenter(0, 0),
								outer = rect.expand(strokeWidth),
								inner = rect.expand(-strokeWidth);
							hit = outer._containsPoint(point)
									&& !inner._containsPoint(point);
						}
					} else {
						if (type === 'ellipse')
							radius = getEllipseRadius(point, radius);
						hit = 2 * Math.abs(point.getLength() - radius)
								<= strokeWidth;
					}
				}
				return hit
						? new HitResult('stroke', this)
						: _hitTestSelf.base.apply(this, arguments);
			}
		};
	}, {
	
	statics: new function() {
		function createShape(type, point, size, radius, args) {
			var item = new Shape(Base.getNamed(args));
			item._type = type;
			item._size = size;
			item._radius = radius;
			return item.translate(point);
		}
	
		return {
			Circle: function() {
				var center = Point.readNamed(arguments, 'center'),
					radius = Base.readNamed(arguments, 'radius');
				return createShape('circle', center, new Size(radius * 2), radius,
						arguments);
			},
	
			Rectangle: function() {
				var rect = Rectangle.readNamed(arguments, 'rectangle'),
					radius = Size.min(Size.readNamed(arguments, 'radius'),
							rect.getSize(true).divide(2));
				return createShape('rectangle', rect.getCenter(true),
						rect.getSize(true), radius, arguments);
			},
	
			Ellipse: function() {
				var ellipse = Shape._readEllipse(arguments),
					radius = ellipse.radius;
				return createShape('ellipse', ellipse.center, radius.multiply(2),
						radius, arguments);
			},
	
			_readEllipse: function(args) {
				var center,
					radius;
				if (Base.hasNamed(args, 'radius')) {
					center = Point.readNamed(args, 'center');
					radius = Size.readNamed(args, 'radius');
				} else {
					var rect = Rectangle.readNamed(args, 'rectangle');
					center = rect.getCenter(true);
					radius = rect.getSize(true).divide(2);
				}
				return { center: center, radius: radius };
			}
		};
	}});
	
	var Raster = Item.extend({
		_class: 'Raster',
		_applyMatrix: false,
		_canApplyMatrix: false,
		_boundsGetter: 'getBounds',
		_boundsSelected: true,
		_serializeFields: {
			crossOrigin: null,
			source: null
		},
	
		initialize: function Raster(object, position) {
			if (!this._initialize(object,
					position !== undefined && Point.read(arguments, 1))) {
				if (typeof object === 'string') {
					this.setSource(object);
				} else {
					this.setImage(object);
				}
			}
			if (!this._size) {
				this._size = new Size();
				this._loaded = false;
			}
		},
	
		_equals: function(item) {
			return this.getSource() === item.getSource();
		},
	
		clone: function(insert) {
			var copy = new Raster(Item.NO_INSERT),
				image = this._image,
				canvas = this._canvas;
			if (image) {
				copy.setImage(image);
			} else if (canvas) {
				var copyCanvas = CanvasProvider.getCanvas(this._size);
				copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
				copy.setImage(copyCanvas);
			}
			copy._crossOrigin = this._crossOrigin;
			return this._clone(copy, insert);
		},
	
		getSize: function() {
			var size = this._size;
			return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
					this, 'setSize');
		},
	
		setSize: function() {
			var size = Size.read(arguments);
			if (!size.equals(this._size)) {
				if (size.width > 0 && size.height > 0) {
					var element = this.getElement();
					this.setImage(CanvasProvider.getCanvas(size));
					if (element)
						this.getContext(true).drawImage(element, 0, 0,
								size.width, size.height);
				} else {
					if (this._canvas)
						CanvasProvider.release(this._canvas);
					this._size = size.clone();
				}
			}
		},
	
		getWidth: function() {
			return this._size ? this._size.width : 0;
		},
	
		setWidth: function(width) {
			this.setSize(width, this.getHeight());
		},
	
		getHeight: function() {
			return this._size ? this._size.height : 0;
		},
	
		setHeight: function(height) {
			this.setSize(this.getWidth(), height);
		},
	
		isEmpty: function() {
			var size = this._size;
			return !size || size.width === 0 && size.height === 0;
		},
	
		getResolution: function() {
			var matrix = this._matrix,
				orig = new Point(0, 0).transform(matrix),
				u = new Point(1, 0).transform(matrix).subtract(orig),
				v = new Point(0, 1).transform(matrix).subtract(orig);
			return new Size(
				72 / u.getLength(),
				72 / v.getLength()
			);
		},
	
		getPpi: '#getResolution',
	
		getImage: function() {
			return this._image;
		},
	
		setImage: function(image) {
			if (this._canvas)
				CanvasProvider.release(this._canvas);
			if (image && image.getContext) {
				this._image = null;
				this._canvas = image;
				this._loaded = true;
			} else {
				this._image = image;
				this._canvas = null;
				this._loaded = image && image.complete;
			}
			this._size = new Size(
					image ? image.naturalWidth || image.width : 0,
					image ? image.naturalHeight || image.height : 0);
			this._context = null;
			this._changed(521);
		},
	
		getCanvas: function() {
			if (!this._canvas) {
				var ctx = CanvasProvider.getContext(this._size);
				try {
					if (this._image)
						ctx.drawImage(this._image, 0, 0);
					this._canvas = ctx.canvas;
				} catch (e) {
					CanvasProvider.release(ctx);
				}
			}
			return this._canvas;
		},
	
		setCanvas: '#setImage',
	
		getContext: function(modify) {
			if (!this._context)
				this._context = this.getCanvas().getContext('2d');
			if (modify) {
				this._image = null;
				this._changed(513);
			}
			return this._context;
		},
	
		setContext: function(context) {
			this._context = context;
		},
	
		getSource: function() {
			return this._image && this._image.src || this.toDataURL();
		},
	
		setSource: function(src) {
			var that = this,
				crossOrigin = this._crossOrigin,
				image;
	
			function loaded() {
				var view = that.getView();
				if (view) {
					paper = view._scope;
					that.setImage(image);
					that.emit('load');
					view.update();
				}
			}
	
			image = document.getElementById(src) || new Image();
			if (crossOrigin)
				image.crossOrigin = crossOrigin;
			if (image.naturalWidth && image.naturalHeight) {
				setTimeout(loaded, 0);
			} else {
				DomEvent.add(image, { load: loaded });
				if (!image.src)
					image.src = src;
			}
			this.setImage(image);
		},
	
		getCrossOrigin: function() {
			return this._image && this._image.crossOrigin || this._crossOrigin || '';
		},
	
		setCrossOrigin: function(crossOrigin) {
			this._crossOrigin = crossOrigin;
			if (this._image)
				this._image.crossOrigin = crossOrigin;
		},
	
		getElement: function() {
			return this._canvas || this._loaded && this._image;
		}
	}, {
		beans: false,
	
		getSubCanvas: function() {
			var rect = Rectangle.read(arguments),
				ctx = CanvasProvider.getContext(rect.getSize());
			ctx.drawImage(this.getCanvas(), rect.x, rect.y,
					rect.width, rect.height, 0, 0, rect.width, rect.height);
			return ctx.canvas;
		},
	
		getSubRaster: function() {
			var rect = Rectangle.read(arguments),
				raster = new Raster(Item.NO_INSERT);
			raster.setImage(this.getSubCanvas(rect));
			raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
			raster._matrix.preConcatenate(this._matrix);
			raster.insertAbove(this);
			return raster;
		},
	
		toDataURL: function() {
			var src = this._image && this._image.src;
			if (/^data:/.test(src))
				return src;
			var canvas = this.getCanvas();
			return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
		},
	
		drawImage: function(image ) {
			var point = Point.read(arguments, 1);
			this.getContext(true).drawImage(image, point.x, point.y);
		},
	
		getAverageColor: function(object) {
			var bounds, path;
			if (!object) {
				bounds = this.getBounds();
			} else if (object instanceof PathItem) {
				path = object;
				bounds = object.getBounds();
			} else if (object.width) {
				bounds = new Rectangle(object);
			} else if (object.x) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
			var sampleSize = 32,
				width = Math.min(bounds.width, sampleSize),
				height = Math.min(bounds.height, sampleSize);
			var ctx = Raster._sampleContext;
			if (!ctx) {
				ctx = Raster._sampleContext = CanvasProvider.getContext(
						new Size(sampleSize));
			} else {
				ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
			}
			ctx.save();
			var matrix = new Matrix()
					.scale(width / bounds.width, height / bounds.height)
					.translate(-bounds.x, -bounds.y);
			matrix.applyToContext(ctx);
			if (path)
				path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
			this._matrix.applyToContext(ctx);
			var element = this.getElement(),
				size = this._size;
			if (element)
				ctx.drawImage(element, -size.width / 2, -size.height / 2);
			ctx.restore();
			var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
					Math.ceil(height)).data,
				channels = [0, 0, 0],
				total = 0;
			for (var i = 0, l = pixels.length; i < l; i += 4) {
				var alpha = pixels[i + 3];
				total += alpha;
				alpha /= 255;
				channels[0] += pixels[i] * alpha;
				channels[1] += pixels[i + 1] * alpha;
				channels[2] += pixels[i + 2] * alpha;
			}
			for (var i = 0; i < 3; i++)
				channels[i] /= total;
			return total ? Color.read(channels) : null;
		},
	
		getPixel: function() {
			var point = Point.read(arguments);
			var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
			return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
					data[3] / 255);
		},
	
		setPixel: function() {
			var point = Point.read(arguments),
				color = Color.read(arguments),
				components = color._convert('rgb'),
				alpha = color._alpha,
				ctx = this.getContext(true),
				imageData = ctx.createImageData(1, 1),
				data = imageData.data;
			data[0] = components[0] * 255;
			data[1] = components[1] * 255;
			data[2] = components[2] * 255;
			data[3] = alpha != null ? alpha * 255 : 255;
			ctx.putImageData(imageData, point.x, point.y);
		},
	
		createImageData: function() {
			var size = Size.read(arguments);
			return this.getContext().createImageData(size.width, size.height);
		},
	
		getImageData: function() {
			var rect = Rectangle.read(arguments);
			if (rect.isEmpty())
				rect = new Rectangle(this._size);
			return this.getContext().getImageData(rect.x, rect.y,
					rect.width, rect.height);
		},
	
		setImageData: function(data ) {
			var point = Point.read(arguments, 1);
			this.getContext(true).putImageData(data, point.x, point.y);
		},
	
		_getBounds: function(getter, matrix) {
			var rect = new Rectangle(this._size).setCenter(0, 0);
			return matrix ? matrix._transformBounds(rect) : rect;
		},
	
		_hitTestSelf: function(point) {
			if (this._contains(point)) {
				var that = this;
				return new HitResult('pixel', that, {
					offset: point.add(that._size.divide(2)).round(),
					color: {
						get: function() {
							return that.getPixel(this.offset);
						}
					}
				});
			}
		},
	
		_draw: function(ctx) {
			var element = this.getElement();
			if (element) {
				ctx.globalAlpha = this._opacity;
				ctx.drawImage(element,
						-this._size.width / 2, -this._size.height / 2);
			}
		},
	
		_canComposite: function() {
			return true;
		}
	});
	
	var PlacedSymbol = Item.extend({
		_class: 'PlacedSymbol',
		_applyMatrix: false,
		_canApplyMatrix: false,
		_boundsGetter: { getBounds: 'getStrokeBounds' },
		_boundsSelected: true,
		_serializeFields: {
			symbol: null
		},
	
		initialize: function PlacedSymbol(arg0, arg1) {
			if (!this._initialize(arg0,
					arg1 !== undefined && Point.read(arguments, 1)))
				this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
		},
	
		_equals: function(item) {
			return this._symbol === item._symbol;
		},
	
		getSymbol: function() {
			return this._symbol;
		},
	
		setSymbol: function(symbol) {
			this._symbol = symbol;
			this._changed(9);
		},
	
		clone: function(insert) {
			var copy = new PlacedSymbol(Item.NO_INSERT);
			copy.setSymbol(this._symbol);
			return this._clone(copy, insert);
		},
	
		isEmpty: function() {
			return this._symbol._definition.isEmpty();
		},
	
		_getBounds: function(getter, matrix, cacheItem) {
			var definition = this.symbol._definition;
			return definition._getCachedBounds(getter,
					matrix && matrix.chain(definition._matrix), cacheItem);
		},
	
		_hitTestSelf: function(point, options) {
			var res = this._symbol._definition._hitTest(point, options);
			if (res)
				res.item = this;
			return res;
		},
	
		_draw: function(ctx, param) {
			this.symbol._definition.draw(ctx, param);
		}
	
	});
	
	var HitResult = Base.extend({
		_class: 'HitResult',
	
		initialize: function HitResult(type, item, values) {
			this.type = type;
			this.item = item;
			if (values) {
				values.enumerable = true;
				this.inject(values);
			}
		},
	
		statics: {
			getOptions: function(options) {
				return new Base({
					type: null,
					tolerance: paper.settings.hitTolerance,
					fill: !options,
					stroke: !options,
					segments: !options,
					handles: false,
					ends: false,
					center: false,
					bounds: false,
					guides: false,
					selected: false
				}, options);
			}
		}
	});
	
	var Segment = Base.extend({
		_class: 'Segment',
		beans: true,
	
		initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
			var count = arguments.length,
				point, handleIn, handleOut;
			if (count === 0) {
			} else if (count === 1) {
				if ('point' in arg0) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
				} else {
					point = arg0;
				}
			} else if (count === 2 && typeof arg0 === 'number') {
				point = arguments;
			} else if (count <= 3) {
				point = arg0;
				handleIn = arg1;
				handleOut = arg2;
			} else {
				point = arg0 !== undefined ? [ arg0, arg1 ] : null;
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
			new SegmentPoint(point, this, '_point');
			new SegmentPoint(handleIn, this, '_handleIn');
			new SegmentPoint(handleOut, this, '_handleOut');
		},
	
		_serialize: function(options) {
			return Base.serialize(this.hasHandles()
					? [this._point, this._handleIn, this._handleOut]
					: this._point,
					options, true);
		},
	
		_changed: function(point) {
			var path = this._path;
			if (!path)
				return;
			var curves = path._curves,
				index = this._index,
				curve;
			if (curves) {
				if ((!point || point === this._point || point === this._handleIn)
						&& (curve = index > 0 ? curves[index - 1] : path._closed
							? curves[curves.length - 1] : null))
					curve._changed();
				if ((!point || point === this._point || point === this._handleOut)
						&& (curve = curves[index]))
					curve._changed();
			}
			path._changed(25);
		},
	
		getPoint: function() {
			return this._point;
		},
	
		setPoint: function() {
			var point = Point.read(arguments);
			this._point.set(point.x, point.y);
		},
	
		getHandleIn: function() {
			return this._handleIn;
		},
	
		setHandleIn: function() {
			var point = Point.read(arguments);
			this._handleIn.set(point.x, point.y);
		},
	
		getHandleOut: function() {
			return this._handleOut;
		},
	
		setHandleOut: function() {
			var point = Point.read(arguments);
			this._handleOut.set(point.x, point.y);
		},
	
		hasHandles: function() {
			return !this._handleIn.isZero() || !this._handleOut.isZero();
		},
	
		clearHandles: function() {
			this._handleIn.set(0, 0);
			this._handleOut.set(0, 0);
		},
	
		_selectionState: 0,
	
		isSelected: function(_point) {
			var state = this._selectionState;
			return !_point ? !!(state & 7)
				: _point === this._point ? !!(state & 4)
				: _point === this._handleIn ? !!(state & 1)
				: _point === this._handleOut ? !!(state & 2)
				: false;
		},
	
		setSelected: function(selected, _point) {
			var path = this._path,
				selected = !!selected,
				state = this._selectionState,
				oldState = state,
				flag = !_point ? 7
						: _point === this._point ? 4
						: _point === this._handleIn ? 1
						: _point === this._handleOut ? 2
						: 0;
			if (selected) {
				state |= flag;
			} else {
				state &= ~flag;
			}
			this._selectionState = state;
			if (path && state !== oldState) {
				path._updateSelection(this, oldState, state);
				path._changed(129);
			}
		},
	
		getIndex: function() {
			return this._index !== undefined ? this._index : null;
		},
	
		getPath: function() {
			return this._path || null;
		},
	
		getCurve: function() {
			var path = this._path,
				index = this._index;
			if (path) {
				if (index > 0 && !path._closed
						&& index === path._segments.length - 1)
					index--;
				return path.getCurves()[index] || null;
			}
			return null;
		},
	
		getLocation: function() {
			var curve = this.getCurve();
			return curve
					? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
					: null;
		},
	
		getNext: function() {
			var segments = this._path && this._path._segments;
			return segments && (segments[this._index + 1]
					|| this._path._closed && segments[0]) || null;
		},
	
		getPrevious: function() {
			var segments = this._path && this._path._segments;
			return segments && (segments[this._index - 1]
					|| this._path._closed && segments[segments.length - 1]) || null;
		},
	
		isFirst: function() {
			return this._index === 0;
		},
	
		isLast: function() {
			var path = this._path;
			return path && this._index === path._segments.length - 1 || false;
		},
	
		reverse: function() {
			var handleIn = this._handleIn,
				handleOut = this._handleOut,
				inX = handleIn._x,
				inY = handleIn._y;
			handleIn.set(handleOut._x, handleOut._y);
			handleOut.set(inX, inY);
		},
	
		reversed: function() {
			return new Segment(this._point, this._handleOut, this._handleIn);
		},
	
		remove: function() {
			return this._path ? !!this._path.removeSegment(this._index) : false;
		},
	
		clone: function() {
			return new Segment(this._point, this._handleIn, this._handleOut);
		},
	
		equals: function(segment) {
			return segment === this || segment && this._class === segment._class
					&& this._point.equals(segment._point)
					&& this._handleIn.equals(segment._handleIn)
					&& this._handleOut.equals(segment._handleOut)
					|| false;
		},
	
		toString: function() {
			var parts = [ 'point: ' + this._point ];
			if (!this._handleIn.isZero())
				parts.push('handleIn: ' + this._handleIn);
			if (!this._handleOut.isZero())
				parts.push('handleOut: ' + this._handleOut);
			return '{ ' + parts.join(', ') + ' }';
		},
	
		transform: function(matrix) {
			this._transformCoordinates(matrix, new Array(6), true);
			this._changed();
		},
	
		_transformCoordinates: function(matrix, coords, change) {
			var point = this._point,
				handleIn = !change || !this._handleIn.isZero()
						? this._handleIn : null,
				handleOut = !change || !this._handleOut.isZero()
						? this._handleOut : null,
				x = point._x,
				y = point._y,
				i = 2;
			coords[0] = x;
			coords[1] = y;
			if (handleIn) {
				coords[i++] = handleIn._x + x;
				coords[i++] = handleIn._y + y;
			}
			if (handleOut) {
				coords[i++] = handleOut._x + x;
				coords[i++] = handleOut._y + y;
			}
			if (matrix) {
				matrix._transformCoordinates(coords, coords, i / 2);
				x = coords[0];
				y = coords[1];
				if (change) {
					point._x = x;
					point._y = y;
					i  = 2;
					if (handleIn) {
						handleIn._x = coords[i++] - x;
						handleIn._y = coords[i++] - y;
					}
					if (handleOut) {
						handleOut._x = coords[i++] - x;
						handleOut._y = coords[i++] - y;
					}
				} else {
					if (!handleIn) {
						coords[i++] = x;
						coords[i++] = y;
					}
					if (!handleOut) {
						coords[i++] = x;
						coords[i++] = y;
					}
				}
			}
			return coords;
		}
	});
	
	var SegmentPoint = Point.extend({
		initialize: function SegmentPoint(point, owner, key) {
			var x, y, selected;
			if (!point) {
				x = y = 0;
			} else if ((x = point[0]) !== undefined) {
				y = point[1];
			} else {
				var pt = point;
				if ((x = pt.x) === undefined) {
					pt = Point.read(arguments);
					x = pt.x;
				}
				y = pt.y;
				selected = pt.selected;
			}
			this._x = x;
			this._y = y;
			this._owner = owner;
			owner[key] = this;
			if (selected)
				this.setSelected(true);
		},
	
		set: function(x, y) {
			this._x = x;
			this._y = y;
			this._owner._changed(this);
			return this;
		},
	
		_serialize: function(options) {
			var f = options.formatter,
				x = f.number(this._x),
				y = f.number(this._y);
			return this.isSelected()
					? { x: x, y: y, selected: true }
					: [x, y];
		},
	
		getX: function() {
			return this._x;
		},
	
		setX: function(x) {
			this._x = x;
			this._owner._changed(this);
		},
	
		getY: function() {
			return this._y;
		},
	
		setY: function(y) {
			this._y = y;
			this._owner._changed(this);
		},
	
		isZero: function() {
			return Numerical.isZero(this._x) && Numerical.isZero(this._y);
		},
	
		setSelected: function(selected) {
			this._owner.setSelected(selected, this);
		},
	
		isSelected: function() {
			return this._owner.isSelected(this);
		}
	});
	
	var Curve = Base.extend({
		_class: 'Curve',
	
		initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
			var count = arguments.length,
				seg1, seg2,
				point1, point2,
				handle1, handle2;
			if (count === 3) {
				this._path = arg0;
				seg1 = arg1;
				seg2 = arg2;
			} else if (count === 0) {
				seg1 = new Segment();
				seg2 = new Segment();
			} else if (count === 1) {
				if ('segment1' in arg0) {
					seg1 = new Segment(arg0.segment1);
					seg2 = new Segment(arg0.segment2);
				} else if ('point1' in arg0) {
					point1 = arg0.point1;
					handle1 = arg0.handle1;
					handle2 = arg0.handle2;
					point2 = arg0.point2;
				} else if (Array.isArray(arg0)) {
					point1 = [arg0[0], arg0[1]];
					point2 = [arg0[6], arg0[7]];
					handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
					handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
				}
			} else if (count === 2) {
				seg1 = new Segment(arg0);
				seg2 = new Segment(arg1);
			} else if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = seg1 || new Segment(point1, null, handle1);
			this._segment2 = seg2 || new Segment(point2, handle2, null);
		},
	
		_serialize: function(options) {
			return Base.serialize(this.hasHandles()
					? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
						this.getPoint2()]
					: [this.getPoint1(), this.getPoint2()],
					options, true);
		},
	
		_changed: function() {
			this._length = this._bounds = undefined;
		},
	
		clone: function() {
			return new Curve(this._segment1, this._segment2);
		},
	
		toString: function() {
			var parts = [ 'point1: ' + this._segment1._point ];
			if (!this._segment1._handleOut.isZero())
				parts.push('handle1: ' + this._segment1._handleOut);
			if (!this._segment2._handleIn.isZero())
				parts.push('handle2: ' + this._segment2._handleIn);
			parts.push('point2: ' + this._segment2._point);
			return '{ ' + parts.join(', ') + ' }';
		},
	
		remove: function() {
			var removed = false;
			if (this._path) {
				var segment2 = this._segment2,
					handleOut = segment2._handleOut;
				removed = segment2.remove();
				if (removed)
					this._segment1._handleOut.set(handleOut.x, handleOut.y);
			}
			return removed;
		},
	
		getPoint1: function() {
			return this._segment1._point;
		},
	
		setPoint1: function() {
			var point = Point.read(arguments);
			this._segment1._point.set(point.x, point.y);
		},
	
		getPoint2: function() {
			return this._segment2._point;
		},
	
		setPoint2: function() {
			var point = Point.read(arguments);
			this._segment2._point.set(point.x, point.y);
		},
	
		getHandle1: function() {
			return this._segment1._handleOut;
		},
	
		setHandle1: function() {
			var point = Point.read(arguments);
			this._segment1._handleOut.set(point.x, point.y);
		},
	
		getHandle2: function() {
			return this._segment2._handleIn;
		},
	
		setHandle2: function() {
			var point = Point.read(arguments);
			this._segment2._handleIn.set(point.x, point.y);
		},
	
		getSegment1: function() {
			return this._segment1;
		},
	
		getSegment2: function() {
			return this._segment2;
		},
	
		getPath: function() {
			return this._path;
		},
	
		getIndex: function() {
			return this._segment1._index;
		},
	
		getNext: function() {
			var curves = this._path && this._path._curves;
			return curves && (curves[this._segment1._index + 1]
					|| this._path._closed && curves[0]) || null;
		},
	
		getPrevious: function() {
			var curves = this._path && this._path._curves;
			return curves && (curves[this._segment1._index - 1]
					|| this._path._closed && curves[curves.length - 1]) || null;
		},
	
		isFirst: function() {
			return this._segment1._index === 0;
		},
	
		isLast: function() {
			var path = this._path;
			return path && this._segment1._index === path._curves.length - 1
					|| false;
		},
	
		isSelected: function() {
			return this.getPoint1().isSelected()
					&& this.getHandle2().isSelected()
					&& this.getHandle2().isSelected()
					&& this.getPoint2().isSelected();
		},
	
		setSelected: function(selected) {
			this.getPoint1().setSelected(selected);
			this.getHandle1().setSelected(selected);
			this.getHandle2().setSelected(selected);
			this.getPoint2().setSelected(selected);
		},
	
		getValues: function(matrix) {
			return Curve.getValues(this._segment1, this._segment2, matrix);
		},
	
		getPoints: function() {
			var coords = this.getValues(),
				points = [];
			for (var i = 0; i < 8; i += 2)
				points.push(new Point(coords[i], coords[i + 1]));
			return points;
		},
	
		getLength: function() {
			if (this._length == null)
				this._length = Curve.getLength(this.getValues(), 0, 1);
			return this._length;
		},
	
		getArea: function() {
			return Curve.getArea(this.getValues());
		},
	
		getLine: function() {
			return new Line(this._segment1._point, this._segment2._point);
		},
	
		getPart: function(from, to) {
			return new Curve(Curve.getPart(this.getValues(), from, to));
		},
	
		getPartLength: function(from, to) {
			return Curve.getLength(this.getValues(), from, to);
		},
	
		getIntersections: function(curve) {
			return Curve._getIntersections(this.getValues(),
					curve && curve !== this ? curve.getValues() : null,
					this, curve, [], {});
		},
	
		_getParameter: function(offset, isParameter) {
			return isParameter
					? offset
					: offset && offset.curve === this
						? offset.parameter
						: offset === undefined && isParameter === undefined
							? 0.5
							: this.getParameterAt(offset, 0);
		},
	
		divide: function(offset, isParameter, _setHandles) {
			var parameter = this._getParameter(offset, isParameter),
				tMin = 4e-7,
				tMax = 1 - tMin,
				res = null;
			if (parameter >= tMin && parameter <= tMax) {
				var parts = Curve.subdivide(this.getValues(), parameter),
					left = parts[0],
					right = parts[1],
					setHandles = _setHandles || this.hasHandles(),
					segment1 = this._segment1,
					segment2 = this._segment2,
					path = this._path;
				if (setHandles) {
					segment1._handleOut.set(left[2] - left[0],
							left[3] - left[1]);
					segment2._handleIn.set(right[4] - right[6],
							right[5] - right[7]);
				}
				var x = left[6], y = left[7],
					segment = new Segment(new Point(x, y),
							setHandles && new Point(left[4] - x, left[5] - y),
							setHandles && new Point(right[2] - x, right[3] - y));
				if (path) {
					path.insert(segment1._index + 1, segment);
					res = this.getNext();
				} else {
					this._segment2 = segment;
					res = new Curve(segment, segment2);
				}
			}
			return res;
		},
	
		split: function(offset, isParameter) {
			return this._path
				? this._path.split(this._segment1._index,
						this._getParameter(offset, isParameter))
				: null;
		},
	
		reversed: function() {
			return new Curve(this._segment2.reversed(), this._segment1.reversed());
		},
	
		clearHandles: function() {
			this._segment1._handleOut.set(0, 0);
			this._segment2._handleIn.set(0, 0);
		},
	
	statics: {
		getValues: function(segment1, segment2, matrix) {
			var p1 = segment1._point,
				h1 = segment1._handleOut,
				h2 = segment2._handleIn,
				p2 = segment2._point,
				values = [
					p1._x, p1._y,
					p1._x + h1._x, p1._y + h1._y,
					p2._x + h2._x, p2._y + h2._y,
					p2._x, p2._y
				];
			if (matrix)
				matrix._transformCoordinates(values, values, 4);
			return values;
		},
	
		subdivide: function(v, t) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7];
			if (t === undefined)
				t = 0.5;
			var u = 1 - t,
				p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
				p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
				p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
				p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
				p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
				p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
			return [
				[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
				[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
			];
		},
	
		solveCubic: function (v, coord, val, roots, min, max) {
			var p1 = v[coord],
				c1 = v[coord + 2],
				c2 = v[coord + 4],
				p2 = v[coord + 6],
				c = 3 * (c1 - p1),
				b = 3 * (c2 - c1) - c,
				a = p2 - p1 - c - b;
			return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
		},
	
		getParameterOf: function(v, point) {
			var p1 = new Point(v[0], v[1]),
				p2 = new Point(v[6], v[7]),
				epsilon = 1e-12,
				t = point.isClose(p1, epsilon) ? 0
				  : point.isClose(p2, epsilon) ? 1
				  : null;
			if (t !== null)
				return t;
			var coords = [point.x, point.y],
				roots = [],
				geomEpsilon = 2e-7;
			for (var c = 0; c < 2; c++) {
				var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
				for (var i = 0; i < count; i++) {
					t = roots[i];
					if (point.isClose(Curve.getPoint(v, t), geomEpsilon))
						return t;
				}
			}
			return point.isClose(p1, geomEpsilon) ? 0
				 : point.isClose(p2, geomEpsilon) ? 1
				 : null;
		},
	
		getNearestParameter: function(v, point) {
			if (Curve.isStraight(v)) {
				var p1x = v[0], p1y = v[1],
					p2x = v[6], p2y = v[7],
					vx = p2x - p1x, vy = p2y - p1y,
					det = vx * vx + vy * vy;
				if (det === 0)
					return 0;
				var u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;
				return u < 1e-12 ? 0
					 : u > 0.999999999999 ? 1
					 : Curve.getParameterOf(v,
						new Point(p1x + u * vx, p1y + u * vy));
			}
	
			var count = 100,
				minDist = Infinity,
				minT = 0;
	
			function refine(t) {
				if (t >= 0 && t <= 1) {
					var dist = point.getDistance(Curve.getPoint(v, t), true);
					if (dist < minDist) {
						minDist = dist;
						minT = t;
						return true;
					}
				}
			}
	
			for (var i = 0; i <= count; i++)
				refine(i / count);
	
			var step = 1 / (count * 2);
			while (step > 4e-7) {
				if (!refine(minT - step) && !refine(minT + step))
					step /= 2;
			}
			return minT;
		},
	
		getPart: function(v, from, to) {
			var flip = from > to;
			if (flip) {
				var tmp = from;
				from = to;
				to = tmp;
			}
			if (from > 0)
				v = Curve.subdivide(v, from)[1];
			if (to < 1)
				v = Curve.subdivide(v, (to - from) / (1 - from))[0];
			return flip
					? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
					: v;
		},
	
		hasHandles: function(v) {
			var isZero = Numerical.isZero;
			return !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));
		},
	
		isFlatEnough: function(v, tolerance) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7],
				ux = 3 * c1x - 2 * p1x - p2x,
				uy = 3 * c1y - 2 * p1y - p2y,
				vx = 3 * c2x - 2 * p2x - p1x,
				vy = 3 * c2y - 2 * p2y - p1y;
			return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
					< 10 * tolerance * tolerance;
		},
	
		getArea: function(v) {
			var p1x = v[0], p1y = v[1],
				p2x = v[6], p2y = v[7],
				h1x = (v[2] + p1x) / 2,
				h1y = (v[3] + p1y) / 2,
				h2x = (v[4] + v[6]) / 2,
				h2y = (v[5] + v[7]) / 2;
			return 6 * ((p1x - h1x) * (h1y + p1y)
					  + (h1x - h2x) * (h2y + h1y)
					  + (h2x - p2x) * (p2y + h2y)) / 10;
		},
	
		getBounds: function(v) {
			var min = v.slice(0, 2),
				max = min.slice(),
				roots = [0, 0];
			for (var i = 0; i < 2; i++)
				Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
						i, 0, min, max, roots);
			return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
		},
	
		_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
			function add(value, padding) {
				var left = value - padding,
					right = value + padding;
				if (left < min[coord])
					min[coord] = left;
				if (right > max[coord])
					max[coord] = right;
			}
			var a = 3 * (v1 - v2) - v0 + v3,
				b = 2 * (v0 + v2) - 4 * v1,
				c = v1 - v0,
				count = Numerical.solveQuadratic(a, b, c, roots),
				tMin = 4e-7,
				tMax = 1 - tMin;
			add(v3, 0);
			for (var i = 0; i < count; i++) {
				var t = roots[i],
					u = 1 - t;
				if (tMin < t && t < tMax)
					add(u * u * u * v0
						+ 3 * u * u * t * v1
						+ 3 * u * t * t * v2
						+ t * t * t * v3,
						padding);
			}
		}
	}}, Base.each(
		['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
		function(name) {
			this[name] = function() {
				if (!this._bounds)
					this._bounds = {};
				var bounds = this._bounds[name];
				if (!bounds) {
					var path = this._path;
					bounds = this._bounds[name] = Path[name](
							[this._segment1, this._segment2], false,
							path && path.getStyle());
				}
				return bounds.clone();
			};
		},
	{
	
	}), Base.each({
		isStraight: function(l, h1, h2) {
			if (h1.isZero() && h2.isZero()) {
				return true;
			} else if (l.isZero()) {
				return false;
			} else if (h1.isCollinear(l) && h2.isCollinear(l)) {
				var div = l.dot(l),
					p1 = l.dot(h1) / div,
					p2 = l.dot(h2) / div;
				return p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;
			}
			return false;
		},
	
		isLinear: function(l, h1, h2) {
			var third = l.divide(3);
			return h1.equals(third) && h2.negate().equals(third);
		}
	}, function(test, name) {
		this[name] = function() {
			var seg1 = this._segment1,
				seg2 = this._segment2;
			return test(seg2._point.subtract(seg1._point),
					seg1._handleOut, seg2._handleIn);
		};
	
		this.statics[name] = function(v) {
			var p1x = v[0], p1y = v[1],
				p2x = v[6], p2y = v[7];
			return test(new Point(p2x - p1x, p2y - p1y),
					new Point(v[2] - p1x, v[3] - p1y),
					new Point(v[4] - p2x, v[5] - p2y));
		};
	}, {
		statics: {},
	
		hasHandles: function() {
			return !this._segment1._handleOut.isZero()
					|| !this._segment2._handleIn.isZero();
		},
	
		isCollinear: function(curve) {
			return curve && this.isStraight() && curve.isStraight()
					&& this.getLine().isCollinear(curve.getLine());
		},
	
		isHorizontal: function() {
			return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y)
					< 1e-7;
		},
	
		isVertical: function() {
			return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x)
					< 1e-7;
		}
	}), {
		beans: false,
	
		getParameterAt: function(offset, start) {
			return Curve.getParameterAt(this.getValues(), offset, start);
		},
	
		getParameterOf: function() {
			return Curve.getParameterOf(this.getValues(), Point.read(arguments));
		},
	
		getLocationAt: function(offset, isParameter) {
			var t = isParameter ? offset : this.getParameterAt(offset);
			return t != null && t >= 0 && t <= 1
					? new CurveLocation(this, t)
					: null;
		},
	
		getLocationOf: function() {
			return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
					true);
		},
	
		getOffsetOf: function() {
			var loc = this.getLocationOf.apply(this, arguments);
			return loc ? loc.getOffset() : null;
		},
	
		getNearestLocation: function() {
			var point = Point.read(arguments),
				values = this.getValues(),
				t = Curve.getNearestParameter(values, point),
				pt = Curve.getPoint(values, t);
			return new CurveLocation(this, t, pt, null, point.getDistance(pt));
		},
	
		getNearestPoint: function() {
			return this.getNearestLocation.apply(this, arguments).getPoint();
		}
	
	},
	new function() {
		var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
			'getWeightedNormal', 'getCurvature'];
		return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(offset, isParameter) {
				var values = this.getValues();
				return Curve[name](values, isParameter ? offset
						: Curve.getParameterAt(values, offset, 0));
			};
		}, {
			statics: {
				evaluateMethods: methods
			}
		})
	},
	new function() {
	
		function getLengthIntegrand(v) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7],
	
				ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
				bx = 6 * (p1x + c2x) - 12 * c1x,
				cx = 3 * (c1x - p1x),
	
				ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
				by = 6 * (p1y + c2y) - 12 * c1y,
				cy = 3 * (c1y - p1y);
	
			return function(t) {
				var dx = (ax * t + bx) * t + cx,
					dy = (ay * t + by) * t + cy;
				return Math.sqrt(dx * dx + dy * dy);
			};
		}
	
		function getIterations(a, b) {
			return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
		}
	
		function evaluate(v, t, type, normalized) {
			if (t == null || t < 0 || t > 1)
				return null;
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7],
				tMin = 4e-7,
				tMax = 1 - tMin,
				x, y;
	
			if (type === 0 && (t < tMin || t > tMax)) {
				var isZero = t < tMin;
				x = isZero ? p1x : p2x;
				y = isZero ? p1y : p2y;
			} else {
				var cx = 3 * (c1x - p1x),
					bx = 3 * (c2x - c1x) - cx,
					ax = p2x - p1x - cx - bx,
	
					cy = 3 * (c1y - p1y),
					by = 3 * (c2y - c1y) - cy,
					ay = p2y - p1y - cy - by;
				if (type === 0) {
					x = ((ax * t + bx) * t + cx) * t + p1x;
					y = ((ay * t + by) * t + cy) * t + p1y;
				} else {
					if (t < tMin) {
						x = cx;
						y = cy;
					} else if (t > tMax) {
						x = 3 * (p2x - c2x);
						y = 3 * (p2y - c2y);
					} else {
						x = (3 * ax * t + 2 * bx) * t + cx;
						y = (3 * ay * t + 2 * by) * t + cy;
					}
					if (normalized) {
						if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
							x = c2x - c1x;
							y = c2y - c1y;
						}
						var len = Math.sqrt(x * x + y * y);
						if (len) {
							x /= len;
							y /= len;
						}
					}
					if (type === 3) {
						var x2 = 6 * ax * t + 2 * bx,
							y2 = 6 * ay * t + 2 * by,
							d = Math.pow(x * x + y * y, 3 / 2);
						x = d !== 0 ? (x * y2 - y * x2) / d : 0;
						y = 0;
					}
				}
			}
			return type === 2 ? new Point(y, -x) : new Point(x, y);
		}
	
		return { statics: {
	
			getLength: function(v, a, b) {
				if (a === undefined)
					a = 0;
				if (b === undefined)
					b = 1;
				if (a === 0 && b === 1 && Curve.isStraight(v)) {
					var dx = v[6] - v[0],
						dy = v[7] - v[1];
					return Math.sqrt(dx * dx + dy * dy);
				}
				var ds = getLengthIntegrand(v);
				return Numerical.integrate(ds, a, b, getIterations(a, b));
			},
	
			getParameterAt: function(v, offset, start) {
				if (start === undefined)
					start = offset < 0 ? 1 : 0
				if (offset === 0)
					return start;
				var abs = Math.abs,
					forward = offset > 0,
					a = forward ? start : 0,
					b = forward ? 1 : start,
					ds = getLengthIntegrand(v),
					rangeLength = Numerical.integrate(ds, a, b,
							getIterations(a, b));
				if (abs(offset - rangeLength) < 1e-12) {
					return forward ? b : a;
				} else if (abs(offset) > rangeLength) {
					return null;
				}
				var guess = offset / rangeLength,
					length = 0;
				function f(t) {
					length += Numerical.integrate(ds, start, t,
							getIterations(start, t));
					start = t;
					return length - offset;
				}
				return Numerical.findRoot(f, ds, start + guess, a, b, 32,
						1e-12);
			},
	
			getPoint: function(v, t) {
				return evaluate(v, t, 0, false);
			},
	
			getTangent: function(v, t) {
				return evaluate(v, t, 1, true);
			},
	
			getWeightedTangent: function(v, t) {
				return evaluate(v, t, 1, false);
			},
	
			getNormal: function(v, t) {
				return evaluate(v, t, 2, true);
			},
	
			getWeightedNormal: function(v, t) {
				return evaluate(v, t, 2, false);
			},
	
			getCurvature: function(v, t) {
				return evaluate(v, t, 3, false).x;
			}
		}};
	},
	new function() {
	
		function addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2,
				overlap) {
			var startConnected = param.startConnected,
				endConnected = param.endConnected,
				tMin = 4e-7,
				tMax = 1 - tMin;
			if (t1 == null)
				t1 = Curve.getParameterOf(v1, p1);
			if (t1 !== null && t1 >= (startConnected ? tMin : 0) &&
				t1 <= (endConnected ? tMax : 1)) {
				if (t2 == null)
					t2 = Curve.getParameterOf(v2, p2);
				if (t2 !== null && t2 >= (endConnected ? tMin : 0) &&
					t2 <= (startConnected ? tMax : 1)) {
					var renormalize = param.renormalize;
					if (renormalize) {
						var res = renormalize(t1, t2);
						t1 = res[0];
						t2 = res[1];
					}
					var loc1 = new CurveLocation(c1, t1,
							p1 || Curve.getPoint(v1, t1), overlap),
						loc2 = new CurveLocation(c2, t2,
							p2 || Curve.getPoint(v2, t2), overlap),
						flip = loc1.getPath() === loc2.getPath()
							&& loc1.getIndex() > loc2.getIndex(),
						loc = flip ? loc2 : loc1,
						include = param.include;
					loc1._intersection = loc2;
					loc2._intersection = loc1;
					if (!include || include(loc)) {
						CurveLocation.insert(locations, loc, true);
					}
				}
			}
		}
	
		function addCurveIntersections(v1, v2, c1, c2, locations, param,
				tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
			if (++recursion >= 24)
				return;
			var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
				getSignedDistance = Line.getSignedDistance,
				d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
				d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
				factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
				dMin = factor * Math.min(0, d1, d2),
				dMax = factor * Math.max(0, d1, d2),
				dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
				dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
				dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
				dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
				hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip,
				tMaxClip;
			if ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null ||
				(tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
					dMin, dMax)) == null)
				return;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			var tDiff = tMaxClip - tMinClip,
				tMinNew = tMin + (tMax - tMin) * tMinClip,
				tMaxNew = tMin + (tMax - tMin) * tMaxClip;
			if (oldTDiff > 0.5 && tDiff > 0.5) {
				if (tMaxNew - tMinNew > uMax - uMin) {
					var parts = Curve.subdivide(v1, 0.5),
						t = tMinNew + (tMaxNew - tMinNew) / 2;
					addCurveIntersections(
						v2, parts[0], c2, c1, locations, param,
						uMin, uMax, tMinNew, t, tDiff, !reverse, recursion);
					addCurveIntersections(
						v2, parts[1], c2, c1, locations, param,
						uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						t = uMin + (uMax - uMin) / 2;
					addCurveIntersections(
						parts[0], v1, c2, c1, locations, param,
						uMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);
					addCurveIntersections(
						parts[1], v1, c2, c1, locations, param,
						t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
				}
			} else if (Math.max(uMax - uMin, tMaxNew - tMinNew)
					< 1e-7) {
				var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
					t2 = uMin + (uMax - uMin) / 2;
				v1 = c1.getValues();
				v2 = c2.getValues();
				addLocation(locations, param,
					reverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null,
					reverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);
			} else if (tDiff > 1e-12) {
				addCurveIntersections(v2, v1, c2, c1, locations, param,
						uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		}
	
		function getConvexHull(dq0, dq1, dq2, dq3) {
			var p0 = [ 0, dq0 ],
				p1 = [ 1 / 3, dq1 ],
				p2 = [ 2 / 3, dq2 ],
				p3 = [ 1, dq3 ],
				dist1 = dq1 - (2 * dq0 + dq3) / 3,
				dist2 = dq2 - (dq0 + 2 * dq3) / 3,
				hull;
			if (dist1 * dist2 < 0) {
				hull = [[p0, p1, p3], [p0, p2, p3]];
			} else {
				var distRatio = dist1 / dist2;
				hull = [
					distRatio >= 2 ? [p0, p1, p3]
					: distRatio <= .5 ? [p0, p2, p3]
					: [p0, p1, p2, p3],
					[p0, p3]
				];
			}
			return (dist1 || dist2) < 0 ? hull.reverse() : hull;
		}
	
		function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
			if (hullTop[0][1] < dMin) {
				return clipConvexHullPart(hullTop, true, dMin);
			} else if (hullBottom[0][1] > dMax) {
				return clipConvexHullPart(hullBottom, false, dMax);
			} else {
				return hullTop[0][0];
			}
		}
	
		function clipConvexHullPart(part, top, threshold) {
			var px = part[0][0],
				py = part[0][1];
			for (var i = 1, l = part.length; i < l; i++) {
				var qx = part[i][0],
					qy = part[i][1];
				if (top ? qy >= threshold : qy <= threshold) {
					return qy === threshold ? qx
							: px + (threshold - py) * (qx - px) / (qy - py);
				}
				px = qx;
				py = qy;
			}
			return null;
		}
	
		function addCurveLineIntersections(v1, v2, c1, c2, locations, param) {
			var flip = Curve.isStraight(v1),
				vc = flip ? v2 : v1,
				vl = flip ? v1 : v2,
				lx1 = vl[0], ly1 = vl[1],
				lx2 = vl[6], ly2 = vl[7],
				ldx = lx2 - lx1,
				ldy = ly2 - ly1,
				angle = Math.atan2(-ldy, ldx),
				sin = Math.sin(angle),
				cos = Math.cos(angle),
				rvc = [];
			for(var i = 0; i < 8; i += 2) {
				var x = vc[i] - lx1,
					y = vc[i + 1] - ly1;
				rvc.push(
					x * cos - y * sin,
					x * sin + y * cos);
			}
			var roots = [],
				count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
			for (var i = 0; i < count; i++) {
				var tc = roots[i],
					pc = Curve.getPoint(vc, tc),
					tl = Curve.getParameterOf(vl, pc);
				if (tl !== null) {
					var pl = Curve.getPoint(vl, tl),
						t1 = flip ? tl : tc,
						t2 = flip ? tc : tl;
					if (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {
						addLocation(locations, param,
								v1, c1, t1, flip ? pl : pc,
								v2, c2, t2, flip ? pc : pl);
					}
				}
			}
		}
	
		function addLineIntersection(v1, v2, c1, c2, locations, param) {
			var pt = Line.intersect(
					v1[0], v1[1], v1[6], v1[7],
					v2[0], v2[1], v2[6], v2[7]);
			if (pt) {
				addLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);
			}
		}
	
		return { statics: {
			_getIntersections: function(v1, v2, c1, c2, locations, param) {
				if (!v2) {
					return Curve._getSelfIntersection(v1, c1, locations, param);
				}
				var c1p1x = v1[0], c1p1y = v1[1],
					c1p2x = v1[6], c1p2y = v1[7],
					c2p1x = v2[0], c2p1y = v2[1],
					c2p2x = v2[6], c2p2y = v2[7],
					c1s1x = (3 * v1[2] + c1p1x) / 4,
					c1s1y = (3 * v1[3] + c1p1y) / 4,
					c1s2x = (3 * v1[4] + c1p2x) / 4,
					c1s2y = (3 * v1[5] + c1p2y) / 4,
					c2s1x = (3 * v2[2] + c2p1x) / 4,
					c2s1y = (3 * v2[3] + c2p1y) / 4,
					c2s2x = (3 * v2[4] + c2p2x) / 4,
					c2s2y = (3 * v2[5] + c2p2y) / 4,
					min = Math.min,
					max = Math.max;
				if (!(	max(c1p1x, c1s1x, c1s2x, c1p2x) >=
						min(c2p1x, c2s1x, c2s2x, c2p2x) &&
						min(c1p1x, c1s1x, c1s2x, c1p2x) <=
						max(c2p1x, c2s1x, c2s2x, c2p2x) &&
						max(c1p1y, c1s1y, c1s2y, c1p2y) >=
						min(c2p1y, c2s1y, c2s2y, c2p2y) &&
						min(c1p1y, c1s1y, c1s2y, c1p2y) <=
						max(c2p1y, c2s1y, c2s2y, c2p2y)))
					return locations;
				if (!param.startConnected && !param.endConnected) {
					var overlaps = Curve.getOverlaps(v1, v2);
					if (overlaps) {
						for (var i = 0; i < 2; i++) {
							var overlap = overlaps[i];
							addLocation(locations, param,
								v1, c1, overlap[0], null,
								v2, c2, overlap[1], null, true);
						}
						return locations;
					}
				}
	
				var straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight = straight1 && straight2,
					epsilon = 1e-12,
					before = locations.length;
				(straight
					? addLineIntersection
					: straight1 || straight2
						? addCurveLineIntersections
						: addCurveIntersections)(
							v1, v2, c1, c2, locations, param,
							0, 1, 0, 1, 0, false, 0);
				if (straight && locations.length > before)
					return locations;
				var c1p1 = new Point(c1p1x, c1p1y),
					c1p2 = new Point(c1p2x, c1p2y),
					c2p1 = new Point(c2p1x, c2p1y),
					c2p2 = new Point(c2p2x, c2p2y);
				if (c1p1.isClose(c2p1, epsilon))
					addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);
				if (!param.startConnected && c1p1.isClose(c2p2, epsilon))
					addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);
				if (!param.endConnected && c1p2.isClose(c2p1, epsilon))
					addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);
				if (c1p2.isClose(c2p2, epsilon))
					addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);
				return locations;
			},
	
			_getSelfIntersection: function(v1, c1, locations, param) {
				var p1x = v1[0], p1y = v1[1],
					h1x = v1[2], h1y = v1[3],
					h2x = v1[4], h2y = v1[5],
					p2x = v1[6], p2y = v1[7];
				var line = new Line(p1x, p1y, p2x, p2y, false),
					side1 = line.getSide(new Point(h1x, h1y), true),
					side2 = line.getSide(new Point(h2x, h2y), true);
				if (side1 === side2) {
					var edgeSum = (p1x - h2x) * (h1y - p2y)
								+ (h1x - p2x) * (h2y - p1y);
					if (edgeSum * side1 > 0)
						return locations;
				}
				var ax = p2x - 3 * h2x + 3 * h1x - p1x,
					bx = h2x - 2 * h1x + p1x,
					cx = h1x - p1x,
					ay = p2y - 3 * h2y + 3 * h1y - p1y,
					by = h2y - 2 * h1y + p1y,
					cy = h1y - p1y,
					ac = ay * cx - ax * cy,
					ab = ay * bx - ax * by,
					bc = by * cx - bx * cy;
				if (ac * ac - 4 * ab * bc < 0) {
					var roots = [],
						tSplit,
						count = Numerical.solveCubic(
								ax * ax	 + ay * ay,
								3 * (ax * bx + ay * by),
								2 * (bx * bx + by * by) + ax * cx + ay * cy,
								bx * cx + by * cy,
								roots, 0, 1);
					if (count > 0) {
						for (var i = 0, maxCurvature = 0; i < count; i++) {
							var curvature = Math.abs(
									c1.getCurvatureAt(roots[i], true));
							if (curvature > maxCurvature) {
								maxCurvature = curvature;
								tSplit = roots[i];
							}
						}
						var parts = Curve.subdivide(v1, tSplit);
						param.endConnected = true;
						param.renormalize = function(t1, t2) {
							return [t1 * tSplit, t2 * (1 - tSplit) + tSplit];
						};
						Curve._getIntersections(parts[0], parts[1], c1, c1,
								locations, param);
					}
				}
				return locations;
			},
	
			getOverlaps: function(v1, v2) {
				var abs = Math.abs,
					timeEpsilon = 4e-7,
					geomEpsilon = 2e-7,
					straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight =	straight1 && straight2;
	
				function getLineLengthSquared(v) {
					var x = v[6] - v[0],
						y = v[7] - v[1];
					return x * x + y * y;
				}
	
				if (straight) {
					var flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),
						l1 = flip ? v2 : v1,
						l2 = flip ? v1 : v2,
						line = new Line(l1[0], l1[1], l1[6], l1[7]);
					if (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon ||
						line.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)
						return null;
				} else if (straight1 ^ straight2) {
					return null;
				}
	
				var v = [v1, v2],
					pairs = [];
				for (var i = 0, t1 = 0;
						i < 2 && pairs.length < 2;
						i += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {
					var t2 = Curve.getParameterOf(v[i ^ 1], new Point(
							v[i][t1 === 0 ? 0 : 6],
							v[i][t1 === 0 ? 1 : 7]));
					if (t2 != null) {
						var pair = i === 0 ? [t1, t2] : [t2, t1];
						if (pairs.length === 0 ||
							abs(pair[0] - pairs[0][0]) > timeEpsilon &&
							abs(pair[1] - pairs[0][1]) > timeEpsilon)
							pairs.push(pair);
					}
					if (i === 1 && pairs.length === 0)
						break;
				}
				if (pairs.length !== 2) {
					pairs = null;
				} else if (!straight) {
					var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
						o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
					if (abs(o2[2] - o1[2]) > geomEpsilon ||
						abs(o2[3] - o1[3]) > geomEpsilon ||
						abs(o2[4] - o1[4]) > geomEpsilon ||
						abs(o2[5] - o1[5]) > geomEpsilon)
						pairs = null;
				}
				return pairs;
			}
		}};
	});
	
	var CurveLocation = Base.extend({
		_class: 'CurveLocation',
		beans: true,
	
		initialize: function CurveLocation(curve, parameter, point,
				_overlap, _distance) {
			if (parameter > 0.9999996) {
				var next = curve.getNext();
				if (next) {
					parameter = 0;
					curve = next;
				}
			}
			this._id = UID.get(CurveLocation);
			this._setCurve(curve);
			this._parameter = parameter;
			this._point = point || curve.getPointAt(parameter, true);
			this._overlap = _overlap;
			this._distance = _distance;
			this._intersection = this._next = this._prev = null;
		},
	
		_setCurve: function(curve) {
			var path = curve._path;
			this._version = path ? path._version : 0;
			this._curve = curve;
			this._segment = null;
			this._segment1 = curve._segment1;
			this._segment2 = curve._segment2;
		},
	
		_setSegment: function(segment) {
			this._setCurve(segment.getCurve());
			this._segment = segment;
			this._parameter = segment === this._segment1 ? 0 : 1;
			this._point = segment._point.clone();
		},
	
		getSegment: function() {
			var curve = this.getCurve(),
				segment = this._segment;
			if (!segment) {
				var parameter = this.getParameter();
				if (parameter === 0) {
					segment = curve._segment1;
				} else if (parameter === 1) {
					segment = curve._segment2;
				} else if (parameter != null) {
					segment = curve.getPartLength(0, parameter)
						< curve.getPartLength(parameter, 1)
							? curve._segment1
							: curve._segment2;
				}
				this._segment = segment;
			}
			return segment;
		},
	
		getCurve: function() {
			var curve = this._curve,
				path = curve && curve._path,
				that = this;
			if (path && path._version !== this._version) {
				curve = this._parameter = this._curve = this._offset = null;
			}
	
			function trySegment(segment) {
				var curve = segment && segment.getCurve();
				if (curve && (that._parameter = curve.getParameterOf(that._point))
						!= null) {
					that._setCurve(curve);
					that._segment = segment;
					return curve;
				}
			}
	
			return curve
				|| trySegment(this._segment)
				|| trySegment(this._segment1)
				|| trySegment(this._segment2.getPrevious());
		},
	
		getPath: function() {
			var curve = this.getCurve();
			return curve && curve._path;
		},
	
		getIndex: function() {
			var curve = this.getCurve();
			return curve && curve.getIndex();
		},
	
		getParameter: function() {
			var curve = this.getCurve(),
				parameter = this._parameter;
			return curve && parameter == null
				? this._parameter = curve.getParameterOf(this._point)
				: parameter;
		},
	
		getPoint: function() {
			return this._point;
		},
	
		getOffset: function() {
			var offset = this._offset;
			if (offset == null) {
				offset = 0;
				var path = this.getPath(),
					index = this.getIndex();
				if (path && index != null) {
					var curves = path.getCurves();
					for (var i = 0; i < index; i++)
						offset += curves[i].getLength();
				}
				this._offset = offset += this.getCurveOffset();
			}
			return offset;
		},
	
		getCurveOffset: function() {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			return parameter != null && curve && curve.getPartLength(0, parameter);
		},
	
		getIntersection: function() {
			return this._intersection;
		},
	
		getDistance: function() {
			return this._distance;
		},
	
		divide: function() {
			var curve = this.getCurve(),
				res = null;
			if (curve) {
				res = curve.divide(this.getParameter(), true);
				if (res)
					this._setSegment(res._segment1);
			}
			return res;
		},
	
		split: function() {
			var curve = this.getCurve();
			return curve ? curve.split(this.getParameter(), true) : null;
		},
	
		equals: function(loc, _ignoreOther) {
			var res = this === loc,
				epsilon = 2e-7;
			if (!res && loc instanceof CurveLocation
					&& this.getPath() === loc.getPath()
					&& this.getPoint().isClose(loc.getPoint(), epsilon)) {
				var c1 = this.getCurve(),
					c2 = loc.getCurve(),
					abs = Math.abs,
					diff = abs(
						((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex())
								+ this.getParameter()) -
						((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex())
								+ loc.getParameter()));
				res = (diff < 4e-7
					|| ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon
						|| abs(this.getPath().getLength() - diff) < epsilon))
					&& (_ignoreOther
						|| (!this._intersection && !loc._intersection
							|| this._intersection && this._intersection.equals(
									loc._intersection, true)));
			}
			return res;
		},
	
		toString: function() {
			var parts = [],
				point = this.getPoint(),
				f = Formatter.instance;
			if (point)
				parts.push('point: ' + point);
			var index = this.getIndex();
			if (index != null)
				parts.push('index: ' + index);
			var parameter = this.getParameter();
			if (parameter != null)
				parts.push('parameter: ' + f.number(parameter));
			if (this._distance != null)
				parts.push('distance: ' + f.number(this._distance));
			return '{ ' + parts.join(', ') + ' }';
		},
	
		isTouching: function() {
			var inter = this._intersection;
			if (inter && this.getTangent().isCollinear(inter.getTangent())) {
				var curve1 = this.getCurve(),
					curve2 = inter.getCurve();
				return !(curve1.isStraight() && curve2.isStraight()
						&& curve1.getLine().intersect(curve2.getLine()));
			}
			return false;
		},
	
		isCrossing: function() {
			var inter = this._intersection;
			if (!inter)
				return false;
			var t1 = this.getParameter(),
				t2 = inter.getParameter(),
				tMin = 4e-7,
				tMax = 1 - tMin;
			if (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)
				return !this.isTouching();
			var c2 = this.getCurve(),
				c1 = c2.getPrevious(),
				c4 = inter.getCurve(),
				c3 = c4.getPrevious(),
				PI = Math.PI;
			if (!c1 || !c3)
				return false;
	
			function isInRange(angle, min, max) {
				return min < max
					? angle > min && angle < max
					: angle > min && angle <= PI || angle >= -PI && angle < max;
			}
	
			var a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),
				a2 = c2.getTangentAt(tMin, true).getAngleInRadians(),
				a3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),
				a4 = c4.getTangentAt(tMin, true).getAngleInRadians();
	
			return (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2))
				&& (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
		},
	
		isOverlap: function() {
			return !!this._overlap;
		}
	}, Base.each(Curve.evaluateMethods, function(name) {
		var get = name + 'At';
		this[name] = function() {
			var parameter = this.getParameter(),
				curve = this.getCurve();
			return parameter != null && curve && curve[get](parameter, true);
		};
	}, {
		preserve: true
	}),
	new function() {
	
		function insert(locations, loc, merge) {
			var length = locations.length,
				l = 0,
				r = length - 1;
	
			function search(index, dir) {
				for (var i = index + dir; i >= -1 && i <= length; i += dir) {
					var loc2 = locations[((i % length) + length) % length];
					if (!loc.getPoint().isClose(loc2.getPoint(),
							2e-7))
						break;
					if (loc.equals(loc2))
						return loc2;
				}
				return null;
			}
	
			while (l <= r) {
				var m = (l + r) >>> 1,
					loc2 = locations[m],
					found;
				if (merge && (found = loc.equals(loc2) ? loc2
						: (search(m, -1) || search(m, 1)))) {
					if (loc._overlap) {
						found._overlap = found._intersection._overlap = true;
					}
					return found;
				}
			var path1 = loc.getPath(),
				path2 = loc2.getPath(),
				diff = path1 === path2
					? (loc.getIndex() + loc.getParameter())
					- (loc2.getIndex() + loc2.getParameter())
					: path1._id - path2._id;
				if (diff < 0) {
					r = m - 1;
				} else {
					l = m + 1;
				}
			}
			locations.splice(l, 0, loc);
			return loc;
		}
	
		return { statics: {
			insert: insert,
	
			expand: function(locations) {
				var expanded = locations.slice();
				for (var i = 0, l = locations.length; i < l; i++) {
					insert(expanded, locations[i]._intersection, false);
				}
				return expanded;
			}
		}};
	});
	
	var PathItem = Item.extend({
		_class: 'PathItem',
	
		initialize: function PathItem() {
		},
	
		getIntersections: function(path, include, _matrix, _returnFirst) {
			var self = this === path || !path,
				matrix1 = this._matrix.orNullIfIdentity(),
				matrix2 = self ? matrix1
					: (_matrix || path._matrix).orNullIfIdentity();
			if (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
				return [];
			var curves1 = this.getCurves(),
				curves2 = self ? curves1 : path.getCurves(),
				length1 = curves1.length,
				length2 = self ? length1 : curves2.length,
				values2 = [],
				arrays = [],
				locations,
				path;
			for (var i = 0; i < length2; i++)
				values2[i] = curves2[i].getValues(matrix2);
			for (var i = 0; i < length1; i++) {
				var curve1 = curves1[i],
					values1 = self ? values2[i] : curve1.getValues(matrix1),
					path1 = curve1.getPath();
				if (path1 !== path) {
					path = path1;
					locations = [];
					arrays.push(locations);
				}
				if (self) {
					Curve._getSelfIntersection(values1, curve1, locations, {
						include: include,
						startConnected: length1 === 1 &&
								curve1.getPoint1().equals(curve1.getPoint2())
					});
				}
				for (var j = self ? i + 1 : 0; j < length2; j++) {
					if (_returnFirst && locations.length)
						return locations;
					var curve2 = curves2[j];
					Curve._getIntersections(
						values1, values2[j], curve1, curve2, locations,
						{
							include: include,
							startConnected: self && curve1.getPrevious() === curve2,
							endConnected: self && curve1.getNext() === curve2
						}
					);
				}
			}
			locations = [];
			for (var i = 0, l = arrays.length; i < l; i++) {
				locations.push.apply(locations, arrays[i]);
			}
			return locations;
		},
	
		getCrossings: function(path) {
			return this.getIntersections(path, function(inter) {
				return inter.isCrossing();
			});
		},
	
		_asPathItem: function() {
			return this;
		},
	
		setPathData: function(data) {
	
			var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
				coords,
				relative = false,
				previous,
				control,
				current = new Point(),
				start = new Point();
	
			function getCoord(index, coord) {
				var val = +coords[index];
				if (relative)
					val += current[coord];
				return val;
			}
	
			function getPoint(index) {
				return new Point(
					getCoord(index, 'x'),
					getCoord(index + 1, 'y')
				);
			}
	
			this.clear();
	
			for (var i = 0, l = parts && parts.length; i < l; i++) {
				var part = parts[i],
					command = part[0],
					lower = command.toLowerCase();
				coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
				var length = coords && coords.length;
				relative = command === lower;
				if (previous === 'z' && !/[mz]/.test(lower))
					this.moveTo(current = start);
				switch (lower) {
				case 'm':
				case 'l':
					var move = lower === 'm';
					for (var j = 0; j < length; j += 2)
						this[j === 0 && move ? 'moveTo' : 'lineTo'](
								current = getPoint(j));
					control = current;
					if (move)
						start = current;
					break;
				case 'h':
				case 'v':
					var coord = lower === 'h' ? 'x' : 'y';
					for (var j = 0; j < length; j++) {
						current[coord] = getCoord(j, coord);
						this.lineTo(current);
					}
					control = current;
					break;
				case 'c':
					for (var j = 0; j < length; j += 6) {
						this.cubicCurveTo(
								getPoint(j),
								control = getPoint(j + 2),
								current = getPoint(j + 4));
					}
					break;
				case 's':
					for (var j = 0; j < length; j += 4) {
						this.cubicCurveTo(
								/[cs]/.test(previous)
										? current.multiply(2).subtract(control)
										: current,
								control = getPoint(j),
								current = getPoint(j + 2));
						previous = lower;
					}
					break;
				case 'q':
					for (var j = 0; j < length; j += 4) {
						this.quadraticCurveTo(
								control = getPoint(j),
								current = getPoint(j + 2));
					}
					break;
				case 't':
					for (var j = 0; j < length; j += 2) {
						this.quadraticCurveTo(
								control = (/[qt]/.test(previous)
										? current.multiply(2).subtract(control)
										: current),
								current = getPoint(j));
						previous = lower;
					}
					break;
				case 'a':
					for (var j = 0; j < length; j += 7) {
						this.arcTo(current = getPoint(j + 5),
								new Size(+coords[j], +coords[j + 1]),
								+coords[j + 2], +coords[j + 4], +coords[j + 3]);
					}
					break;
				case 'z':
					this.closePath(true);
					break;
				}
				previous = lower;
			}
		},
	
		_canComposite: function() {
			return !(this.hasFill() && this.hasStroke());
		},
	
		_contains: function(point) {
			var winding = this._getWinding(point, false, true);
			return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
		}
	
	});
	
	var Path = PathItem.extend({
		_class: 'Path',
		_serializeFields: {
			segments: [],
			closed: false
		},
	
		initialize: function Path(arg) {
			this._closed = false;
			this._segments = [];
			this._version = 0;
			var segments = Array.isArray(arg)
				? typeof arg[0] === 'object'
					? arg
					: arguments
				: arg && (arg.size === undefined && (arg.x !== undefined
						|| arg.point !== undefined))
					? arguments
					: null;
			if (segments && segments.length > 0) {
				this.setSegments(segments);
			} else {
				this._curves = undefined;
				this._selectedSegmentState = 0;
				if (!segments && typeof arg === 'string') {
					this.setPathData(arg);
					arg = null;
				}
			}
			this._initialize(!segments && arg);
		},
	
		_equals: function(item) {
			return this._closed === item._closed
					&& Base.equals(this._segments, item._segments);
		},
	
		clone: function(insert) {
			var copy = new Path(Item.NO_INSERT);
			copy.setSegments(this._segments);
			copy._closed = this._closed;
			if (this._clockwise !== undefined)
				copy._clockwise = this._clockwise;
			return this._clone(copy, insert);
		},
	
		_changed: function _changed(flags) {
			_changed.base.call(this, flags);
			if (flags & 8) {
				var parent = this._parent;
				if (parent)
					parent._currentPath = undefined;
				this._length = this._area = this._clockwise = this._monoCurves =
						undefined;
				if (flags & 16) {
					this._version++;
				} else if (this._curves) {
				   for (var i = 0, l = this._curves.length; i < l; i++)
						this._curves[i]._changed();
				}
			} else if (flags & 32) {
				this._bounds = undefined;
			}
		},
	
		getStyle: function() {
			var parent = this._parent;
			return (parent instanceof CompoundPath ? parent : this)._style;
		},
	
		getSegments: function() {
			return this._segments;
		},
	
		setSegments: function(segments) {
			var fullySelected = this.isFullySelected();
			this._segments.length = 0;
			this._selectedSegmentState = 0;
			this._curves = undefined;
			if (segments && segments.length > 0)
				this._add(Segment.readAll(segments));
			if (fullySelected)
				this.setFullySelected(true);
		},
	
		getFirstSegment: function() {
			return this._segments[0];
		},
	
		getLastSegment: function() {
			return this._segments[this._segments.length - 1];
		},
	
		getCurves: function() {
			var curves = this._curves,
				segments = this._segments;
			if (!curves) {
				var length = this._countCurves();
				curves = this._curves = new Array(length);
				for (var i = 0; i < length; i++)
					curves[i] = new Curve(this, segments[i],
						segments[i + 1] || segments[0]);
			}
			return curves;
		},
	
		getFirstCurve: function() {
			return this.getCurves()[0];
		},
	
		getLastCurve: function() {
			var curves = this.getCurves();
			return curves[curves.length - 1];
		},
	
		isClosed: function() {
			return this._closed;
		},
	
		setClosed: function(closed) {
			if (this._closed != (closed = !!closed)) {
				this._closed = closed;
				if (this._curves) {
					var length = this._curves.length = this._countCurves();
					if (closed)
						this._curves[length - 1] = new Curve(this,
							this._segments[length - 1], this._segments[0]);
				}
				this._changed(25);
			}
		}
	}, {
		beans: true,
	
		getPathData: function(_matrix, _precision) {
			var segments = this._segments,
				length = segments.length,
				f = new Formatter(_precision),
				coords = new Array(6),
				first = true,
				curX, curY,
				prevX, prevY,
				inX, inY,
				outX, outY,
				parts = [];
	
			function addSegment(segment, skipLine) {
				segment._transformCoordinates(_matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
				if (first) {
					parts.push('M' + f.pair(curX, curY));
					first = false;
				} else {
					inX = coords[2];
					inY = coords[3];
					if (inX === curX && inY === curY
							&& outX === prevX && outY === prevY) {
						if (!skipLine)
							parts.push('l' + f.pair(curX - prevX, curY - prevY));
					} else {
						parts.push('c' + f.pair(outX - prevX, outY - prevY)
								+ ' ' + f.pair(inX - prevX, inY - prevY)
								+ ' ' + f.pair(curX - prevX, curY - prevY));
					}
				}
				prevX = curX;
				prevY = curY;
				outX = coords[4];
				outY = coords[5];
			}
	
			if (length === 0)
				return '';
	
			for (var i = 0; i < length; i++)
				addSegment(segments[i]);
			if (this._closed && length > 0) {
				addSegment(segments[0], true);
				parts.push('z');
			}
			return parts.join('');
		}
	}, {
	
		isEmpty: function() {
			return this._segments.length === 0;
		},
	
		_transformContent: function(matrix) {
			var coords = new Array(6);
			for (var i = 0, l = this._segments.length; i < l; i++)
				this._segments[i]._transformCoordinates(matrix, coords, true);
			return true;
		},
	
		_add: function(segs, index) {
			var segments = this._segments,
				curves = this._curves,
				amount = segs.length,
				append = index == null,
				index = append ? segments.length : index;
			for (var i = 0; i < amount; i++) {
				var segment = segs[i];
				if (segment._path)
					segment = segs[i] = segment.clone();
				segment._path = this;
				segment._index = index + i;
				if (segment._selectionState)
					this._updateSelection(segment, 0, segment._selectionState);
			}
			if (append) {
				segments.push.apply(segments, segs);
			} else {
				segments.splice.apply(segments, [index, 0].concat(segs));
				for (var i = index + amount, l = segments.length; i < l; i++)
					segments[i]._index = i;
			}
			if (curves) {
				var total = this._countCurves(),
					from = index + amount - 1 === total ? index - 1 : index,
					start = from,
					to = Math.min(from + amount, total);
				if (segs._curves) {
					curves.splice.apply(curves, [from, 0].concat(segs._curves));
					start += segs._curves.length;
				}
				for (var i = start; i < to; i++)
					curves.splice(i, 0, new Curve(this, null, null));
				this._adjustCurves(from, to);
			}
			this._changed(25);
			return segs;
		},
	
		_adjustCurves: function(from, to) {
			var segments = this._segments,
				curves = this._curves,
				curve;
			for (var i = from; i < to; i++) {
				curve = curves[i];
				curve._path = this;
				curve._segment1 = segments[i];
				curve._segment2 = segments[i + 1] || segments[0];
				curve._changed();
			}
			if (curve = curves[this._closed && from === 0 ? segments.length - 1
					: from - 1]) {
				curve._segment2 = segments[from] || segments[0];
				curve._changed();
			}
			if (curve = curves[to]) {
				curve._segment1 = segments[to];
				curve._changed();
			}
		},
	
		_countCurves: function() {
			var length = this._segments.length;
			return !this._closed && length > 0 ? length - 1 : length;
		},
	
		add: function(segment1 ) {
			return arguments.length > 1 && typeof segment1 !== 'number'
				? this._add(Segment.readAll(arguments))
				: this._add([ Segment.read(arguments) ])[0];
		},
	
		insert: function(index, segment1 ) {
			return arguments.length > 2 && typeof segment1 !== 'number'
				? this._add(Segment.readAll(arguments, 1), index)
				: this._add([ Segment.read(arguments, 1) ], index)[0];
		},
	
		addSegment: function() {
			return this._add([ Segment.read(arguments) ])[0];
		},
	
		insertSegment: function(index ) {
			return this._add([ Segment.read(arguments, 1) ], index)[0];
		},
	
		addSegments: function(segments) {
			return this._add(Segment.readAll(segments));
		},
	
		insertSegments: function(index, segments) {
			return this._add(Segment.readAll(segments), index);
		},
	
		removeSegment: function(index) {
			return this.removeSegments(index, index + 1)[0] || null;
		},
	
		removeSegments: function(from, to, _includeCurves) {
			from = from || 0;
			to = Base.pick(to, this._segments.length);
			var segments = this._segments,
				curves = this._curves,
				count = segments.length,
				removed = segments.splice(from, to - from),
				amount = removed.length;
			if (!amount)
				return removed;
			for (var i = 0; i < amount; i++) {
				var segment = removed[i];
				if (segment._selectionState)
					this._updateSelection(segment, segment._selectionState, 0);
				segment._index = segment._path = null;
			}
			for (var i = from, l = segments.length; i < l; i++)
				segments[i]._index = i;
			if (curves) {
				var index = from > 0 && to === count + (this._closed ? 1 : 0)
						? from - 1
						: from,
					curves = curves.splice(index, amount);
				if (_includeCurves)
					removed._curves = curves.slice(1);
				this._adjustCurves(index, index);
			}
			this._changed(25);
			return removed;
		},
	
		clear: '#removeSegments',
	
		hasHandles: function() {
			var segments = this._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				if (segments[i].hasHandles())
					return true;
			}
			return false;
		},
	
		clearHandles: function() {
			var segments = this._segments;
			for (var i = 0, l = segments.length; i < l; i++)
				segments[i].clearHandles();
		},
	
		getLength: function() {
			if (this._length == null) {
				var curves = this.getCurves(),
					length = 0;
				for (var i = 0, l = curves.length; i < l; i++)
					length += curves[i].getLength();
				this._length = length;
			}
			return this._length;
		},
	
		getArea: function() {
			if (this._area == null) {
				var segments = this._segments,
					count = segments.length,
					last = count - 1,
					area = 0;
				for (var i = 0, l = this._closed ? count : last; i < l; i++) {
					area += Curve.getArea(Curve.getValues(
							segments[i], segments[i < last ? i + 1 : 0]));
				}
				this._area = area;
			}
			return this._area;
		},
	
		isClockwise: function() {
			if (this._clockwise !== undefined)
				return this._clockwise;
			return this.getArea() >= 0;
		},
	
		setClockwise: function(clockwise) {
			if (this.isClockwise() != (clockwise = !!clockwise))
				this.reverse();
			this._clockwise = clockwise;
		},
	
		isFullySelected: function() {
			var length = this._segments.length;
			return this._selected && length > 0 && this._selectedSegmentState
					=== length * 7;
		},
	
		setFullySelected: function(selected) {
			if (selected)
				this._selectSegments(true);
			this.setSelected(selected);
		},
	
		setSelected: function setSelected(selected) {
			if (!selected)
				this._selectSegments(false);
			setSelected.base.call(this, selected);
		},
	
		_selectSegments: function(selected) {
			var length = this._segments.length;
			this._selectedSegmentState = selected
					? length * 7 : 0;
			for (var i = 0; i < length; i++)
				this._segments[i]._selectionState = selected
						? 7 : 0;
		},
	
		_updateSelection: function(segment, oldState, newState) {
			segment._selectionState = newState;
			var total = this._selectedSegmentState += newState - oldState;
			if (total > 0)
				this.setSelected(true);
		},
	
		flatten: function(maxDistance) {
			var iterator = new PathIterator(this, 64, 0.1),
				pos = 0,
				step = iterator.length / Math.ceil(iterator.length / maxDistance),
				end = iterator.length + (this._closed ? -step : step) / 2;
			var segments = [];
			while (pos <= end) {
				segments.push(new Segment(iterator.getPointAt(pos)));
				pos += step;
			}
			this.setSegments(segments);
		},
	
		reduce: function() {
			var curves = this.getCurves();
			for (var i = curves.length - 1; i >= 0; i--) {
				var curve = curves[i];
				if (!curve.hasHandles() && (curve.getLength() === 0
						|| curve.isCollinear(curve.getNext())))
					curve.remove();
			}
			return this;
		},
	
		simplify: function(tolerance) {
			if (this._segments.length > 2) {
				var fitter = new PathFitter(this, tolerance || 2.5);
				this.setSegments(fitter.fit());
			}
		},
	
		split: function(index, parameter) {
			if (parameter === null)
				return null;
			if (arguments.length === 1) {
				var arg = index;
				if (typeof arg === 'number')
					arg = this.getLocationAt(arg);
				if (!arg)
					return null
				index = arg.index;
				parameter = arg.parameter;
			}
			var tMin = 4e-7,
				tMax = 1 - tMin;
			if (parameter >= tMax) {
				index++;
				parameter--;
			}
			var curves = this.getCurves();
			if (index >= 0 && index < curves.length) {
				if (parameter >= tMin) {
					curves[index++].divide(parameter, true);
				}
				var segs = this.removeSegments(index, this._segments.length, true),
					path;
				if (this._closed) {
					this.setClosed(false);
					path = this;
				} else {
					path = new Path(Item.NO_INSERT);
					path.insertAbove(this, true);
					this._clone(path);
				}
				path._add(segs, 0);
				this.addSegment(segs[0]);
				return path;
			}
			return null;
		},
	
		reverse: function() {
			this._segments.reverse();
			for (var i = 0, l = this._segments.length; i < l; i++) {
				var segment = this._segments[i];
				var handleIn = segment._handleIn;
				segment._handleIn = segment._handleOut;
				segment._handleOut = handleIn;
				segment._index = i;
			}
			this._curves = null;
			if (this._clockwise !== undefined)
				this._clockwise = !this._clockwise;
			this._changed(9);
		},
	
		join: function(path) {
			if (path) {
				var segments = path._segments,
					last1 = this.getLastSegment(),
					last2 = path.getLastSegment();
				if (!last2)
					return this;
				if (last1 && last1._point.equals(last2._point))
					path.reverse();
				var first2 = path.getFirstSegment();
				if (last1 && last1._point.equals(first2._point)) {
					last1.setHandleOut(first2._handleOut);
					this._add(segments.slice(1));
				} else {
					var first1 = this.getFirstSegment();
					if (first1 && first1._point.equals(first2._point))
						path.reverse();
					last2 = path.getLastSegment();
					if (first1 && first1._point.equals(last2._point)) {
						first1.setHandleIn(last2._handleIn);
						this._add(segments.slice(0, segments.length - 1), 0);
					} else {
						this._add(segments.slice());
					}
				}
				if (path._closed)
					this._add([segments[0]]);
				path.remove();
			}
			var first = this.getFirstSegment(),
				last = this.getLastSegment();
			if (first !== last && first._point.equals(last._point)) {
				first.setHandleIn(last._handleIn);
				last.remove();
				this.setClosed(true);
			}
			return this;
		},
	
		toShape: function(insert) {
			if (!this._closed)
				return null;
	
			var segments = this._segments,
				type,
				size,
				radius,
				topCenter;
	
			function isCollinear(i, j) {
				var seg1 = segments[i],
					seg2 = seg1.getNext(),
					seg3 = segments[j],
					seg4 = seg3.getNext();
				return seg1._handleOut.isZero() && seg2._handleIn.isZero()
						&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
						&& seg2._point.subtract(seg1._point).isCollinear(
							seg4._point.subtract(seg3._point));
			}
	
			function isOrthogonal(i) {
				var seg2 = segments[i],
					seg1 = seg2.getPrevious(),
					seg3 = seg2.getNext();
				return seg1._handleOut.isZero() && seg2._handleIn.isZero()
						&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
						&& seg2._point.subtract(seg1._point).isOrthogonal(
							seg3._point.subtract(seg2._point));
			}
	
			function isArc(i) {
				var seg1 = segments[i],
					seg2 = seg1.getNext(),
					handle1 = seg1._handleOut,
					handle2 = seg2._handleIn,
					kappa = 0.5522847498307936;
				if (handle1.isOrthogonal(handle2)) {
					var pt1 = seg1._point,
						pt2 = seg2._point,
						corner = new Line(pt1, handle1, true).intersect(
								new Line(pt2, handle2, true), true);
					return corner && Numerical.isZero(handle1.getLength() /
							corner.subtract(pt1).getLength() - kappa)
						&& Numerical.isZero(handle2.getLength() /
							corner.subtract(pt2).getLength() - kappa);
				}
				return false;
			}
	
			function getDistance(i, j) {
				return segments[i]._point.getDistance(segments[j]._point);
			}
	
			if (!this.hasHandles() && segments.length === 4
					&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
				type = Shape.Rectangle;
				size = new Size(getDistance(0, 3), getDistance(0, 1));
				topCenter = segments[1]._point.add(segments[2]._point).divide(2);
			} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
					&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
				type = Shape.Rectangle;
				size = new Size(getDistance(1, 6), getDistance(0, 3));
				radius = size.subtract(new Size(getDistance(0, 7),
						getDistance(1, 2))).divide(2);
				topCenter = segments[3]._point.add(segments[4]._point).divide(2);
			} else if (segments.length === 4
					&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
				if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
					type = Shape.Circle;
					radius = getDistance(0, 2) / 2;
				} else {
					type = Shape.Ellipse;
					radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
				}
				topCenter = segments[1]._point;
			}
	
			if (type) {
				var center = this.getPosition(true),
					shape = this._clone(new type({
						center: center,
						size: size,
						radius: radius,
						insert: false
					}), insert, false);
				shape.rotate(topCenter.subtract(center).getAngle() + 90);
				return shape;
			}
			return null;
		},
	
		_hitTestSelf: function(point, options) {
			var that = this,
				style = this.getStyle(),
				segments = this._segments,
				numSegments = segments.length,
				closed = this._closed,
				tolerancePadding = options._tolerancePadding,
				strokePadding = tolerancePadding,
				join, cap, miterLimit,
				area, loc, res,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill(),
				hitCurves = options.curves,
				radius = hitStroke
						? style.getStrokeWidth() / 2
						: hitFill && options.tolerance > 0 || hitCurves
							? 0 : null;
			if (radius !== null) {
				if (radius > 0) {
					join = style.getStrokeJoin();
					cap = style.getStrokeCap();
					miterLimit = radius * style.getMiterLimit();
					strokePadding = tolerancePadding.add(new Point(radius, radius));
				} else {
					join = cap = 'round';
				}
			}
	
			function isCloseEnough(pt, padding) {
				return point.subtract(pt).divide(padding).length <= 1;
			}
	
			function checkSegmentPoint(seg, pt, name) {
				if (!options.selected || pt.isSelected()) {
					var anchor = seg._point;
					if (pt !== anchor)
						pt = pt.add(anchor);
					if (isCloseEnough(pt, strokePadding)) {
						return new HitResult(name, that, {
							segment: seg,
							point: pt
						});
					}
				}
			}
	
			function checkSegmentPoints(seg, ends) {
				return (ends || options.segments)
					&& checkSegmentPoint(seg, seg._point, 'segment')
					|| (!ends && options.handles) && (
						checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
						checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
			}
	
			function addToArea(point) {
				area.add(point);
			}
	
			function checkSegmentStroke(segment) {
				if (join !== 'round' || cap !== 'round') {
					area = new Path({ internal: true, closed: true });
					if (closed || segment._index > 0
							&& segment._index < numSegments - 1) {
						if (join !== 'round' && (segment._handleIn.isZero()
								|| segment._handleOut.isZero()))
							Path._addBevelJoin(segment, join, radius, miterLimit,
									addToArea, true);
					} else if (cap !== 'round') {
						Path._addSquareCap(segment, cap, radius, addToArea, true);
					}
					if (!area.isEmpty()) {
						var loc;
						return area.contains(point)
							|| (loc = area.getNearestLocation(point))
								&& isCloseEnough(loc.getPoint(), tolerancePadding);
					}
				}
				return isCloseEnough(segment._point, strokePadding);
			}
	
			if (options.ends && !options.segments && !closed) {
				if (res = checkSegmentPoints(segments[0], true)
						|| checkSegmentPoints(segments[numSegments - 1], true))
					return res;
			} else if (options.segments || options.handles) {
				for (var i = 0; i < numSegments; i++)
					if (res = checkSegmentPoints(segments[i]))
						return res;
			}
			if (radius !== null) {
				loc = this.getNearestLocation(point);
				if (loc) {
					var parameter = loc.getParameter();
					if (parameter === 0 || parameter === 1 && numSegments > 1) {
						if (!checkSegmentStroke(loc.getSegment()))
							loc = null;
					} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
						loc = null;
					}
				}
				if (!loc && join === 'miter' && numSegments > 1) {
					for (var i = 0; i < numSegments; i++) {
						var segment = segments[i];
						if (point.getDistance(segment._point) <= miterLimit
								&& checkSegmentStroke(segment)) {
							loc = segment.getLocation();
							break;
						}
					}
				}
			}
			return !loc && hitFill && this._contains(point)
					|| loc && !hitStroke && !hitCurves
						? new HitResult('fill', this)
						: loc
							? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
								location: loc,
								point: loc.getPoint()
							})
							: null;
		}
	
	}, Base.each(Curve.evaluateMethods,
		function(name) {
			this[name + 'At'] = function(offset, isParameter) {
				var loc = this.getLocationAt(offset, isParameter);
				return loc && loc[name]();
			};
		},
	{
		beans: false,
	
		getLocationOf: function() {
			var point = Point.read(arguments),
				curves = this.getCurves();
			for (var i = 0, l = curves.length; i < l; i++) {
				var loc = curves[i].getLocationOf(point);
				if (loc)
					return loc;
			}
			return null;
		},
	
		getOffsetOf: function() {
			var loc = this.getLocationOf.apply(this, arguments);
			return loc ? loc.getOffset() : null;
		},
	
		getLocationAt: function(offset, isParameter) {
			var curves = this.getCurves(),
				length = 0;
			if (isParameter) {
				var index = ~~offset,
					curve = curves[index];
				return curve ? curve.getLocationAt(offset - index, true) : null;
			}
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (curves.length > 0 && offset <= this.getLength())
				return new CurveLocation(curves[curves.length - 1], 1);
			return null;
		},
	
		getNearestLocation: function() {
			var point = Point.read(arguments),
				curves = this.getCurves(),
				minDist = Infinity,
				minLoc = null;
			for (var i = 0, l = curves.length; i < l; i++) {
				var loc = curves[i].getNearestLocation(point);
				if (loc._distance < minDist) {
					minDist = loc._distance;
					minLoc = loc;
				}
			}
			return minLoc;
		},
	
		getNearestPoint: function() {
			return this.getNearestLocation.apply(this, arguments).getPoint();
		}
	}),
	new function() {
	
		function drawHandles(ctx, segments, matrix, size) {
			var half = size / 2;
	
			function drawHandle(index) {
				var hX = coords[index],
					hY = coords[index + 1];
				if (pX != hX || pY != hY) {
					ctx.beginPath();
					ctx.moveTo(pX, pY);
					ctx.lineTo(hX, hY);
					ctx.stroke();
					ctx.beginPath();
					ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
					ctx.fill();
				}
			}
	
			var coords = new Array(6);
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i];
				segment._transformCoordinates(matrix, coords, false);
				var state = segment._selectionState,
					pX = coords[0],
					pY = coords[1];
				if (state & 1)
					drawHandle(2);
				if (state & 2)
					drawHandle(4);
				ctx.fillRect(pX - half, pY - half, size, size);
				if (!(state & 4)) {
					var fillStyle = ctx.fillStyle;
					ctx.fillStyle = '#ffffff';
					ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
					ctx.fillStyle = fillStyle;
				}
			}
		}
	
		function drawSegments(ctx, path, matrix) {
			var segments = path._segments,
				length = segments.length,
				coords = new Array(6),
				first = true,
				curX, curY,
				prevX, prevY,
				inX, inY,
				outX, outY;
	
			function drawSegment(segment) {
				if (matrix) {
					segment._transformCoordinates(matrix, coords, false);
					curX = coords[0];
					curY = coords[1];
				} else {
					var point = segment._point;
					curX = point._x;
					curY = point._y;
				}
				if (first) {
					ctx.moveTo(curX, curY);
					first = false;
				} else {
					if (matrix) {
						inX = coords[2];
						inY = coords[3];
					} else {
						var handle = segment._handleIn;
						inX = curX + handle._x;
						inY = curY + handle._y;
					}
					if (inX === curX && inY === curY
							&& outX === prevX && outY === prevY) {
						ctx.lineTo(curX, curY);
					} else {
						ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
					}
				}
				prevX = curX;
				prevY = curY;
				if (matrix) {
					outX = coords[4];
					outY = coords[5];
				} else {
					var handle = segment._handleOut;
					outX = prevX + handle._x;
					outY = prevY + handle._y;
				}
			}
	
			for (var i = 0; i < length; i++)
				drawSegment(segments[i]);
			if (path._closed && length > 0)
				drawSegment(segments[0]);
		}
	
		return {
			_draw: function(ctx, param, strokeMatrix) {
				var dontStart = param.dontStart,
					dontPaint = param.dontFinish || param.clip,
					style = this.getStyle(),
					hasFill = style.hasFill(),
					hasStroke = style.hasStroke(),
					dashArray = style.getDashArray(),
					dashLength = !paper.support.nativeDash && hasStroke
							&& dashArray && dashArray.length;
	
				if (!dontStart)
					ctx.beginPath();
	
				if (!dontStart && this._currentPath) {
					ctx.currentPath = this._currentPath;
				} else if (hasFill || hasStroke && !dashLength || dontPaint) {
					drawSegments(ctx, this, strokeMatrix);
					if (this._closed)
						ctx.closePath();
					if (!dontStart)
						this._currentPath = ctx.currentPath;
				}
	
				function getOffset(i) {
					return dashArray[((i % dashLength) + dashLength) % dashLength];
				}
	
				if (!dontPaint && (hasFill || hasStroke)) {
					this._setStyles(ctx);
					if (hasFill) {
						ctx.fill(style.getWindingRule());
						ctx.shadowColor = 'rgba(0,0,0,0)';
					}
					if (hasStroke) {
						if (dashLength) {
							if (!dontStart)
								ctx.beginPath();
							var iterator = new PathIterator(this, 32, 0.25,
									strokeMatrix),
								length = iterator.length,
								from = -style.getDashOffset(), to,
								i = 0;
							from = from % length;
							while (from > 0) {
								from -= getOffset(i--) + getOffset(i--);
							}
							while (from < length) {
								to = from + getOffset(i++);
								if (from > 0 || to > 0)
									iterator.drawPart(ctx,
											Math.max(from, 0), Math.max(to, 0));
								from = to + getOffset(i++);
							}
						}
						ctx.stroke();
					}
				}
			},
	
			_drawSelected: function(ctx, matrix) {
				ctx.beginPath();
				drawSegments(ctx, this, matrix);
				ctx.stroke();
				drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
			}
		};
	},
	new function() {
		function getFirstControlPoints(rhs) {
			var n = rhs.length,
				x = [],
				tmp = [],
				b = 2;
			x[0] = rhs[0] / b;
			for (var i = 1; i < n; i++) {
				tmp[i] = 1 / b;
				b = (i < n - 1 ? 4 : 2) - tmp[i];
				x[i] = (rhs[i] - x[i - 1]) / b;
			}
			for (var i = 1; i < n; i++) {
				x[n - i - 1] -= tmp[n - i] * x[n - i];
			}
			return x;
		}
	
		return {
			smooth: function() {
				var segments = this._segments,
					size = segments.length,
					closed = this._closed,
					n = size,
					overlap = 0;
				if (size <= 2)
					return;
				if (closed) {
					overlap = Math.min(size, 4);
					n += Math.min(size, overlap) * 2;
				}
				var knots = [];
				for (var i = 0; i < size; i++)
					knots[i + overlap] = segments[i]._point;
				if (closed) {
					for (var i = 0; i < overlap; i++) {
						knots[i] = segments[i + size - overlap]._point;
						knots[i + size + overlap] = segments[i]._point;
					}
				} else {
					n--;
				}
				var rhs = [];
	
				for (var i = 1; i < n - 1; i++)
					rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
				rhs[0] = knots[0]._x + 2 * knots[1]._x;
				rhs[n - 1] = 3 * knots[n - 1]._x;
				var x = getFirstControlPoints(rhs);
	
				for (var i = 1; i < n - 1; i++)
					rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
				rhs[0] = knots[0]._y + 2 * knots[1]._y;
				rhs[n - 1] = 3 * knots[n - 1]._y;
				var y = getFirstControlPoints(rhs);
	
				if (closed) {
					for (var i = 0, j = size; i < overlap; i++, j++) {
						var f1 = i / overlap,
							f2 = 1 - f1,
							ie = i + overlap,
							je = j + overlap;
						x[j] = x[i] * f1 + x[j] * f2;
						y[j] = y[i] * f1 + y[j] * f2;
						x[je] = x[ie] * f2 + x[je] * f1;
						y[je] = y[ie] * f2 + y[je] * f1;
					}
					n--;
				}
				var handleIn = null;
				for (var i = overlap; i <= n - overlap; i++) {
					var segment = segments[i - overlap];
					if (handleIn)
						segment.setHandleIn(handleIn.subtract(segment._point));
					if (i < n) {
						segment.setHandleOut(
								new Point(x[i], y[i]).subtract(segment._point));
						handleIn = i < n - 1
								? new Point(
									2 * knots[i + 1]._x - x[i + 1],
									2 * knots[i + 1]._y - y[i + 1])
								: new Point(
									(knots[n]._x + x[n - 1]) / 2,
									(knots[n]._y + y[n - 1]) / 2);
					}
				}
				if (closed && handleIn) {
					var segment = this._segments[0];
					segment.setHandleIn(handleIn.subtract(segment._point));
				}
			}
		};
	},
	new function() {
		function getCurrentSegment(that) {
			var segments = that._segments;
			if (segments.length === 0)
				throw new Error('Use a moveTo() command first');
			return segments[segments.length - 1];
		}
	
		return {
			moveTo: function() {
				var segments = this._segments;
				if (segments.length === 1)
					this.removeSegment(0);
				if (!segments.length)
					this._add([ new Segment(Point.read(arguments)) ]);
			},
	
			moveBy: function() {
				throw new Error('moveBy() is unsupported on Path items.');
			},
	
			lineTo: function() {
				this._add([ new Segment(Point.read(arguments)) ]);
			},
	
			cubicCurveTo: function() {
				var handle1 = Point.read(arguments),
					handle2 = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this);
				current.setHandleOut(handle1.subtract(current._point));
				this._add([ new Segment(to, handle2.subtract(to)) ]);
			},
	
			quadraticCurveTo: function() {
				var handle = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.cubicCurveTo(
					handle.add(current.subtract(handle).multiply(1 / 3)),
					handle.add(to.subtract(handle).multiply(1 / 3)),
					to
				);
			},
	
			curveTo: function() {
				var through = Point.read(arguments),
					to = Point.read(arguments),
					t = Base.pick(Base.read(arguments), 0.5),
					t1 = 1 - t,
					current = getCurrentSegment(this)._point,
					handle = through.subtract(current.multiply(t1 * t1))
						.subtract(to.multiply(t * t)).divide(2 * t * t1);
				if (handle.isNaN())
					throw new Error(
						'Cannot put a curve through points with parameter = ' + t);
				this.quadraticCurveTo(handle, to);
			},
	
			arcTo: function() {
				var current = getCurrentSegment(this),
					from = current._point,
					to = Point.read(arguments),
					through,
					peek = Base.peek(arguments),
					clockwise = Base.pick(peek, true),
					center, extent, vector, matrix;
				if (typeof clockwise === 'boolean') {
					var middle = from.add(to).divide(2),
					through = middle.add(middle.subtract(from).rotate(
							clockwise ? -90 : 90));
				} else if (Base.remain(arguments) <= 2) {
					through = to;
					to = Point.read(arguments);
				} else {
					var radius = Size.read(arguments);
					if (radius.isZero())
						return this.lineTo(to);
					var rotation = Base.read(arguments),
						clockwise = !!Base.read(arguments),
						large = !!Base.read(arguments),
						middle = from.add(to).divide(2),
						pt = from.subtract(middle).rotate(-rotation),
						x = pt.x,
						y = pt.y,
						abs = Math.abs,
						rx = abs(radius.width),
						ry = abs(radius.height),
						rxSq = rx * rx,
						rySq = ry * ry,
						xSq =  x * x,
						ySq =  y * y;
					var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
					if (factor > 1) {
						rx *= factor;
						ry *= factor;
						rxSq = rx * rx;
						rySq = ry * ry;
					}
					factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
							(rxSq * ySq + rySq * xSq);
					if (abs(factor) < 1e-12)
						factor = 0;
					if (factor < 0)
						throw new Error(
								'Cannot create an arc with the given arguments');
					center = new Point(rx * y / ry, -ry * x / rx)
							.multiply((large === clockwise ? -1 : 1)
								* Math.sqrt(factor))
							.rotate(rotation).add(middle);
					matrix = new Matrix().translate(center).rotate(rotation)
							.scale(rx, ry);
					vector = matrix._inverseTransform(from);
					extent = vector.getDirectedAngle(matrix._inverseTransform(to));
					if (!clockwise && extent > 0)
						extent -= 360;
					else if (clockwise && extent < 0)
						extent += 360;
				}
				if (through) {
					var l1 = new Line(from.add(through).divide(2),
								through.subtract(from).rotate(90), true),
						l2 = new Line(through.add(to).divide(2),
								to.subtract(through).rotate(90), true),
						line = new Line(from, to),
						throughSide = line.getSide(through);
					center = l1.intersect(l2, true);
					if (!center) {
						if (!throughSide)
							return this.lineTo(to);
						throw new Error(
								'Cannot create an arc with the given arguments');
					}
					vector = from.subtract(center);
					extent = vector.getDirectedAngle(to.subtract(center));
					var centerSide = line.getSide(center);
					if (centerSide === 0) {
						extent = throughSide * Math.abs(extent);
					} else if (throughSide === centerSide) {
						extent += extent < 0 ? 360 : -360;
					}
				}
				var ext = Math.abs(extent),
					count = ext >= 360 ? 4 : Math.ceil(ext / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (i === 0) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			},
	
			lineBy: function() {
				var to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.lineTo(current.add(to));
			},
	
			curveBy: function() {
				var through = Point.read(arguments),
					to = Point.read(arguments),
					parameter = Base.read(arguments),
					current = getCurrentSegment(this)._point;
				this.curveTo(current.add(through), current.add(to), parameter);
			},
	
			cubicCurveBy: function() {
				var handle1 = Point.read(arguments),
					handle2 = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.cubicCurveTo(current.add(handle1), current.add(handle2),
						current.add(to));
			},
	
			quadraticCurveBy: function() {
				var handle = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.quadraticCurveTo(current.add(handle), current.add(to));
			},
	
			arcBy: function() {
				var current = getCurrentSegment(this)._point,
					point = current.add(Point.read(arguments)),
					clockwise = Base.pick(Base.peek(arguments), true);
				if (typeof clockwise === 'boolean') {
					this.arcTo(point, clockwise);
				} else {
					this.arcTo(point, current.add(Point.read(arguments)));
				}
			},
	
			closePath: function(join) {
				this.setClosed(true);
				if (join)
					this.join();
			}
		};
	}, {
	
		_getBounds: function(getter, matrix) {
			return Path[getter](this._segments, this._closed, this.getStyle(),
					matrix);
		},
	
	statics: {
		getBounds: function(segments, closed, style, matrix, strokePadding) {
			var first = segments[0];
			if (!first)
				return new Rectangle();
			var coords = new Array(6),
				prevCoords = first._transformCoordinates(matrix, new Array(6), false),
				min = prevCoords.slice(0, 2),
				max = min.slice(),
				roots = new Array(2);
	
			function processSegment(segment) {
				segment._transformCoordinates(matrix, coords, false);
				for (var i = 0; i < 2; i++) {
					Curve._addBounds(
						prevCoords[i],
						prevCoords[i + 4],
						coords[i + 2],
						coords[i],
						i, strokePadding ? strokePadding[i] : 0, min, max, roots);
				}
				var tmp = prevCoords;
				prevCoords = coords;
				coords = tmp;
			}
	
			for (var i = 1, l = segments.length; i < l; i++)
				processSegment(segments[i]);
			if (closed)
				processSegment(first);
			return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
		},
	
		getStrokeBounds: function(segments, closed, style, matrix) {
			if (!style.hasStroke())
				return Path.getBounds(segments, closed, style, matrix);
			var length = segments.length - (closed ? 0 : 1),
				radius = style.getStrokeWidth() / 2,
				padding = Path._getPenPadding(radius, matrix),
				bounds = Path.getBounds(segments, closed, style, matrix, padding),
				join = style.getStrokeJoin(),
				cap = style.getStrokeCap(),
				miterLimit = radius * style.getMiterLimit();
			var joinBounds = new Rectangle(new Size(padding).multiply(2));
	
			function add(point) {
				bounds = bounds.include(matrix
					? matrix._transformPoint(point, point) : point);
			}
	
			function addRound(segment) {
				bounds = bounds.unite(joinBounds.setCenter(matrix
					? matrix._transformPoint(segment._point) : segment._point));
			}
	
			function addJoin(segment, join) {
				var handleIn = segment._handleIn,
					handleOut = segment._handleOut;
				if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
						&& handleIn.isCollinear(handleOut)) {
					addRound(segment);
				} else {
					Path._addBevelJoin(segment, join, radius, miterLimit, add);
				}
			}
	
			function addCap(segment, cap) {
				if (cap === 'round') {
					addRound(segment);
				} else {
					Path._addSquareCap(segment, cap, radius, add);
				}
			}
	
			for (var i = 1; i < length; i++)
				addJoin(segments[i], join);
			if (closed) {
				addJoin(segments[0], join);
			} else if (length > 0) {
				addCap(segments[0], cap);
				addCap(segments[segments.length - 1], cap);
			}
			return bounds;
		},
	
		_getPenPadding: function(radius, matrix) {
			if (!matrix)
				return [radius, radius];
			var mx = matrix.shiftless(),
				hor = mx.transform(new Point(radius, 0)),
				ver = mx.transform(new Point(0, radius)),
				phi = hor.getAngleInRadians(),
				a = hor.getLength(),
				b = ver.getLength();
			var sin = Math.sin(phi),
				cos = Math.cos(phi),
				tan = Math.tan(phi),
				tx = -Math.atan(b * tan / a),
				ty = Math.atan(b / (tan * a));
			return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
					Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
		},
	
		_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
			var curve2 = segment.getCurve(),
				curve1 = curve2.getPrevious(),
				point = curve2.getPointAt(0, true),
				normal1 = curve1.getNormalAt(1, true),
				normal2 = curve2.getNormalAt(0, true),
				step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
			normal1.setLength(step);
			normal2.setLength(step);
			if (area) {
				addPoint(point);
				addPoint(point.add(normal1));
			}
			if (join === 'miter') {
				var corner = new Line(
						point.add(normal1),
						new Point(-normal1.y, normal1.x), true
					).intersect(new Line(
						point.add(normal2),
						new Point(-normal2.y, normal2.x), true
					), true);
				if (corner && point.getDistance(corner) <= miterLimit) {
					addPoint(corner);
					if (!area)
						return;
				}
			}
			if (!area)
				addPoint(point.add(normal1));
			addPoint(point.add(normal2));
		},
	
		_addSquareCap: function(segment, cap, radius, addPoint, area) {
			var point = segment._point,
				loc = segment.getLocation(),
				normal = loc.getNormal().multiply(radius);
			if (area) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			if (cap === 'square')
				point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
			addPoint(point.add(normal));
			addPoint(point.subtract(normal));
		},
	
		getHandleBounds: function(segments, closed, style, matrix, strokePadding,
				joinPadding) {
			var coords = new Array(6),
				x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2;
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i];
				segment._transformCoordinates(matrix, coords, false);
				for (var j = 0; j < 6; j += 2) {
					var padding = j === 0 ? joinPadding : strokePadding,
						paddingX = padding ? padding[0] : 0,
						paddingY = padding ? padding[1] : 0,
						x = coords[j],
						y = coords[j + 1],
						xn = x - paddingX,
						xx = x + paddingX,
						yn = y - paddingY,
						yx = y + paddingY;
					if (xn < x1) x1 = xn;
					if (xx > x2) x2 = xx;
					if (yn < y1) y1 = yn;
					if (yx > y2) y2 = yx;
				}
			}
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		getRoughBounds: function(segments, closed, style, matrix) {
			var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
				joinRadius = strokeRadius;
			if (strokeRadius > 0) {
				if (style.getStrokeJoin() === 'miter')
					joinRadius = strokeRadius * style.getMiterLimit();
				if (style.getStrokeCap() === 'square')
					joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
			}
			return Path.getHandleBounds(segments, closed, style, matrix,
					Path._getPenPadding(strokeRadius, matrix),
					Path._getPenPadding(joinRadius, matrix));
		}
	}});
	
	Path.inject({ statics: new function() {
	
		var kappa = 0.5522847498307936,
			ellipseSegments = [
				new Segment([-1, 0], [0, kappa ], [0, -kappa]),
				new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
				new Segment([1, 0], [0, -kappa], [0, kappa ]),
				new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
			];
	
		function createPath(segments, closed, args) {
			var props = Base.getNamed(args),
				path = new Path(props && props.insert === false && Item.NO_INSERT);
			path._add(segments);
			path._closed = closed;
			return path.set(props);
		}
	
		function createEllipse(center, radius, args) {
			var segments = new Array(4);
			for (var i = 0; i < 4; i++) {
				var segment = ellipseSegments[i];
				segments[i] = new Segment(
					segment._point.multiply(radius).add(center),
					segment._handleIn.multiply(radius),
					segment._handleOut.multiply(radius)
				);
			}
			return createPath(segments, true, args);
		}
	
		return {
			Line: function() {
				return createPath([
					new Segment(Point.readNamed(arguments, 'from')),
					new Segment(Point.readNamed(arguments, 'to'))
				], false, arguments);
			},
	
			Circle: function() {
				var center = Point.readNamed(arguments, 'center'),
					radius = Base.readNamed(arguments, 'radius');
				return createEllipse(center, new Size(radius), arguments);
			},
	
			Rectangle: function() {
				var rect = Rectangle.readNamed(arguments, 'rectangle'),
					radius = Size.readNamed(arguments, 'radius', 0,
							{ readNull: true }),
					bl = rect.getBottomLeft(true),
					tl = rect.getTopLeft(true),
					tr = rect.getTopRight(true),
					br = rect.getBottomRight(true),
					segments;
				if (!radius || radius.isZero()) {
					segments = [
						new Segment(bl),
						new Segment(tl),
						new Segment(tr),
						new Segment(br)
					];
				} else {
					radius = Size.min(radius, rect.getSize(true).divide(2));
					var rx = radius.width,
						ry = radius.height,
						hx = rx * kappa,
						hy = ry * kappa;
					segments = [
						new Segment(bl.add(rx, 0), null, [-hx, 0]),
						new Segment(bl.subtract(0, ry), [0, hy]),
						new Segment(tl.add(0, ry), null, [0, -hy]),
						new Segment(tl.add(rx, 0), [-hx, 0], null),
						new Segment(tr.subtract(rx, 0), null, [hx, 0]),
						new Segment(tr.add(0, ry), [0, -hy], null),
						new Segment(br.subtract(0, ry), null, [0, hy]),
						new Segment(br.subtract(rx, 0), [hx, 0])
					];
				}
				return createPath(segments, true, arguments);
			},
	
			RoundRectangle: '#Rectangle',
	
			Ellipse: function() {
				var ellipse = Shape._readEllipse(arguments);
				return createEllipse(ellipse.center, ellipse.radius, arguments);
			},
	
			Oval: '#Ellipse',
	
			Arc: function() {
				var from = Point.readNamed(arguments, 'from'),
					through = Point.readNamed(arguments, 'through'),
					to = Point.readNamed(arguments, 'to'),
					props = Base.getNamed(arguments),
					path = new Path(props && props.insert === false
							&& Item.NO_INSERT);
				path.moveTo(from);
				path.arcTo(through, to);
				return path.set(props);
			},
	
			RegularPolygon: function() {
				var center = Point.readNamed(arguments, 'center'),
					sides = Base.readNamed(arguments, 'sides'),
					radius = Base.readNamed(arguments, 'radius'),
					step = 360 / sides,
					three = !(sides % 3),
					vector = new Point(0, three ? -radius : radius),
					offset = three ? -1 : 0.5,
					segments = new Array(sides);
				for (var i = 0; i < sides; i++)
					segments[i] = new Segment(center.add(
						vector.rotate((i + offset) * step)));
				return createPath(segments, true, arguments);
			},
	
			Star: function() {
				var center = Point.readNamed(arguments, 'center'),
					points = Base.readNamed(arguments, 'points') * 2,
					radius1 = Base.readNamed(arguments, 'radius1'),
					radius2 = Base.readNamed(arguments, 'radius2'),
					step = 360 / points,
					vector = new Point(0, -1),
					segments = new Array(points);
				for (var i = 0; i < points; i++)
					segments[i] = new Segment(center.add(vector.rotate(step * i)
							.multiply(i % 2 ? radius2 : radius1)));
				return createPath(segments, true, arguments);
			}
		};
	}});
	
	var CompoundPath = PathItem.extend({
		_class: 'CompoundPath',
		_serializeFields: {
			children: []
		},
	
		initialize: function CompoundPath(arg) {
			this._children = [];
			this._namedChildren = {};
			if (!this._initialize(arg)) {
				if (typeof arg === 'string') {
					this.setPathData(arg);
				} else {
					this.addChildren(Array.isArray(arg) ? arg : arguments);
				}
			}
		},
	
		insertChildren: function insertChildren(index, items, _preserve) {
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (item instanceof CompoundPath) {
					items.splice.apply(items, [i, 1].concat(item.removeChildren()));
					item.remove();
				}
			}
			items = insertChildren.base.call(this, index, items, _preserve, Path);
			for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
				var item = items[i];
				if (item._clockwise === undefined)
					item.setClockwise(item._index === 0);
			}
			return items;
		},
	
		reverse: function() {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].reverse();
		},
	
		smooth: function() {
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i].smooth();
		},
	
		reduce: function reduce() {
			var children = this._children;
			for (var i = children.length - 1; i >= 0; i--) {
				var path = children[i].reduce();
				if (path.isEmpty())
					children.splice(i, 1);
			}
			if (children.length === 0) {
				var path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.setStyle(this._style);
				this.remove();
				return path;
			}
			return reduce.base.call(this);
		},
	
		isClockwise: function() {
			var child = this.getFirstChild();
			return child && child.isClockwise();
		},
	
		setClockwise: function(clockwise) {
			if (this.isClockwise() !== !!clockwise)
				this.reverse();
		},
	
		getFirstSegment: function() {
			var first = this.getFirstChild();
			return first && first.getFirstSegment();
		},
	
		getLastSegment: function() {
			var last = this.getLastChild();
			return last && last.getLastSegment();
		},
	
		getCurves: function() {
			var children = this._children,
				curves = [];
			for (var i = 0, l = children.length; i < l; i++)
				curves.push.apply(curves, children[i].getCurves());
			return curves;
		},
	
		getFirstCurve: function() {
			var first = this.getFirstChild();
			return first && first.getFirstCurve();
		},
	
		getLastCurve: function() {
			var last = this.getLastChild();
			return last && last.getFirstCurve();
		},
	
		getArea: function() {
			var children = this._children,
				area = 0;
			for (var i = 0, l = children.length; i < l; i++)
				area += children[i].getArea();
			return area;
		}
	}, {
		beans: true,
	
		getPathData: function(_matrix, _precision) {
			var children = this._children,
				paths = [];
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i],
					mx = child._matrix;
				paths.push(child.getPathData(_matrix && !mx.isIdentity()
						? _matrix.chain(mx) : _matrix, _precision));
			}
			return paths.join(' ');
		}
	}, {
		_getChildHitTestOptions: function(options) {
			return options.class === Path || options.type === 'path'
					? options
					: new Base(options, { fill: false });
		},
	
		_draw: function(ctx, param, strokeMatrix) {
			var children = this._children;
			if (children.length === 0)
				return;
	
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else {
				param = param.extend({ dontStart: true, dontFinish: true });
				ctx.beginPath();
				for (var i = 0, l = children.length; i < l; i++)
					children[i].draw(ctx, param, strokeMatrix);
				this._currentPath = ctx.currentPath;
			}
	
			if (!param.clip) {
				this._setStyles(ctx);
				var style = this._style;
				if (style.hasFill()) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (style.hasStroke())
					ctx.stroke();
			}
		},
	
		_drawSelected: function(ctx, matrix, selectedItems) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i],
					mx = child._matrix;
				if (!selectedItems[child._id])
					child._drawSelected(ctx, mx.isIdentity() ? matrix
							: matrix.chain(mx));
			}
		}
	},
	new function() {
		function getCurrentPath(that, check) {
			var children = that._children;
			if (check && children.length === 0)
				throw new Error('Use a moveTo() command first');
			return children[children.length - 1];
		}
	
		var fields = {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current
							: new Path(Item.NO_INSERT);
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},
	
			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},
	
			closePath: function(join) {
				getCurrentPath(this, true).closePath(join);
			}
		};
	
		Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
				'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
				function(key) {
					fields[key] = function() {
						var path = getCurrentPath(this, true);
						path[key].apply(path, arguments);
					};
				}
		);
	
		return fields;
	});
	
	PathItem.inject(new function() {
		var operators = {
			unite: function(w) {
				return w === 1 || w === 0;
			},
	
			intersect: function(w) {
				return w === 2;
			},
	
			subtract: function(w) {
				return w === 1;
			},
	
			exclude: function(w) {
				return w === 1;
			}
		};
	
		function preparePath(path, resolve) {
			var res = path.clone(false).reduce().transform(null, true, true);
			return resolve ? res.resolveCrossings().reorient() : res;
		}
	
		function finishBoolean(ctor, paths, path1, path2, reduce) {
			var result = new ctor(Item.NO_INSERT);
			result.addChildren(paths, true);
			if (reduce)
				result = result.reduce();
			result.insertAbove(path2 && path1.isSibling(path2)
					&& path1.getIndex() < path2.getIndex()
						? path2 : path1);
			result.setStyle(path1._style);
			return result;
		}
	
		function computeBoolean(path1, path2, operation) {
			if (!path1._children && !path1._closed)
				return computeOpenBoolean(path1, path2, operation);
			var _path1 = preparePath(path1, true),
				_path2 = path2 && path1 !== path2 && preparePath(path2, true);
			if (_path2 && /^(subtract|exclude)$/.test(operation)
					^ (_path2.isClockwise() !== _path1.isClockwise()))
				_path2.reverse();
			var intersections = CurveLocation.expand(
				_path1.getIntersections(_path2, function(inter) {
					return _path2 && inter.isOverlap() || inter.isCrossing();
				})
			);
			divideLocations(intersections);
	
			var segments = [],
				monoCurves = [];
	
			function collect(paths) {
				for (var i = 0, l = paths.length; i < l; i++) {
					var path = paths[i];
					segments.push.apply(segments, path._segments);
					monoCurves.push.apply(monoCurves, path._getMonoCurves());
				}
			}
	
			collect(_path1._children || [_path1]);
			if (_path2)
				collect(_path2._children || [_path2]);
			for (var i = 0, l = intersections.length; i < l; i++) {
				propagateWinding(intersections[i]._segment, _path1, _path2,
						monoCurves, operation);
			}
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i];
				if (segment._winding == null) {
					propagateWinding(segment, _path1, _path2, monoCurves,
							operation);
				}
			}
			return finishBoolean(CompoundPath, tracePaths(segments, operation),
					path1, path2, true);
		}
	
		function computeOpenBoolean(path1, path2, operation) {
			if (!path2 || !path2._children && !path2._closed
					|| !/^(subtract|intersect)$/.test(operation))
				return null;
			var _path1 = preparePath(path1, false),
				_path2 = preparePath(path2, false),
				intersections = _path1.getIntersections(_path2, function(inter) {
					return inter.isOverlap() || inter.isCrossing();
				}),
				sub = operation === 'subtract',
				paths = [];
	
			function addPath(path) {
				if (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {
					paths.unshift(path);
					return true;
				}
			}
	
			for (var i = intersections.length - 1; i >= 0; i--) {
				var path = intersections[i].split();
				if (path) {
					if (addPath(path))
						path.getFirstSegment().setHandleIn(0, 0);
					_path1.getLastSegment().setHandleOut(0, 0);
				}
			}
			addPath(_path1);
			return finishBoolean(Group, paths, path1, path2);
		}
	
		function linkIntersections(from, to) {
			var prev = from;
			while (prev) {
				if (prev === to)
					return;
				prev = prev._prev;
			}
			while (from._next && from._next !== to)
				from = from._next;
			if (!from._next) {
				while (to._prev)
					to = to._prev;
				from._next = to;
				to._prev = from;
			}
		}
	
		function divideLocations(locations) {
			var tMin = 4e-7,
				tMax = 1 - tMin,
				noHandles = false,
				clearSegments = [],
				prevCurve,
				prevT;
	
			for (var i = locations.length - 1; i >= 0; i--) {
				var loc = locations[i],
					curve = loc._curve,
					t = loc._parameter,
					origT = t;
				if (curve !== prevCurve) {
					noHandles = !curve.hasHandles();
				} else if (prevT > 0) {
					t /= prevT;
				}
				var segment;
				if (t < tMin) {
					segment = curve._segment1;
				} else if (t > tMax) {
					segment = curve._segment2;
				} else {
					segment = curve.divide(t, true, true)._segment1;
					if (noHandles)
						clearSegments.push(segment);
				}
				loc._setSegment(segment);
				var inter = segment._intersection,
					dest = loc._intersection;
				if (inter) {
					linkIntersections(inter, dest);
					var other = inter;
					while (other) {
						linkIntersections(other._intersection, inter);
						other = other._next;
					}
				} else {
					segment._intersection = dest;
				}
				prevCurve = curve;
				prevT = origT;
			}
			for (var i = 0, l = clearSegments.length; i < l; i++) {
				clearSegments[i].clearHandles();
			}
		}
	
		function getWinding(point, curves, horizontal, testContains) {
			var epsilon = 2e-7,
				tMin = 4e-7,
				tMax = 1 - tMin,
				px = point.x,
				py = point.y,
				windLeft = 0,
				windRight = 0,
				roots = [],
				abs = Math.abs;
			if (horizontal) {
				var yTop = -Infinity,
					yBottom = Infinity,
					yBefore = py - epsilon,
					yAfter = py + epsilon;
				for (var i = 0, l = curves.length; i < l; i++) {
					var values = curves[i].values;
					if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
						for (var j = roots.length - 1; j >= 0; j--) {
							var y = Curve.getPoint(values, roots[j]).y;
							if (y < yBefore && y > yTop) {
								yTop = y;
							} else if (y > yAfter && y < yBottom) {
								yBottom = y;
							}
						}
					}
				}
				yTop = (yTop + py) / 2;
				yBottom = (yBottom + py) / 2;
				if (yTop > -Infinity)
					windLeft = getWinding(new Point(px, yTop), curves, false,
							testContains);
				if (yBottom < Infinity)
					windRight = getWinding(new Point(px, yBottom), curves, false,
							testContains);
			} else {
				var xBefore = px - epsilon,
					xAfter = px + epsilon;
				var startCounted = false,
					prevCurve,
					prevT;
				for (var i = 0, l = curves.length; i < l; i++) {
					var curve = curves[i],
						values = curve.values,
						winding = curve.winding;
					if (winding && (winding === 1
							&& py >= values[1] && py <= values[7]
							|| py >= values[7] && py <= values[1])
						&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
						var t = roots[0];
						if (!(
							t > tMax && startCounted && curve.next !== curves[i + 1]
							|| t < tMin && prevT > tMax
								&& curve.previous === prevCurve)) {
							var x = Curve.getPoint(values, t).x,
								slope = Curve.getTangent(values, t).y,
								counted = false;
							if (Numerical.isZero(slope) && !Curve.isStraight(values)
									|| t < tMin && slope * Curve.getTangent(
										curve.previous.values, 1).y < 0
									|| t > tMax && slope * Curve.getTangent(
										curve.next.values, 0).y < 0) {
								if (testContains && x >= xBefore && x <= xAfter) {
									++windLeft;
									++windRight;
									counted = true;
								}
							} else if (x <= xBefore) {
								windLeft += winding;
								counted = true;
							} else if (x >= xAfter) {
								windRight += winding;
								counted = true;
							}
							if (curve.previous !== curves[i - 1])
								startCounted = t < tMin && counted;
						}
						prevCurve = curve;
						prevT = t;
					}
				}
			}
			return Math.max(abs(windLeft), abs(windRight));
		}
	
		function propagateWinding(segment, path1, path2, monoCurves, operation) {
			var epsilon = 2e-7,
				chain = [],
				start = segment,
				totalLength = 0,
				windingSum = 0;
			do {
				var curve = segment.getCurve(),
					length = curve.getLength();
				chain.push({ segment: segment, curve: curve, length: length });
				totalLength += length;
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== start);
			for (var i = 0; i < 3; i++) {
				var length = totalLength * (i + 1) / 4;
				for (var k = 0, m = chain.length; k < m; k++) {
					var node = chain[k],
						curveLength = node.length;
					if (length <= curveLength) {
						if (length < epsilon || curveLength - length < epsilon)
							length = curveLength / 2;
						var curve = node.curve,
							path = curve._path,
							parent = path._parent,
							pt = curve.getPointAt(length),
							hor = curve.isHorizontal();
						if (parent instanceof CompoundPath)
							path = parent;
						windingSum += operation === 'subtract' && path2
							&& (path === path1 && path2._getWinding(pt, hor)
							|| path === path2 && !path1._getWinding(pt, hor))
							? 0
							: getWinding(pt, monoCurves, hor);
						break;
					}
					length -= curveLength;
				}
			}
			var winding = Math.round(windingSum / 3);
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j].segment._winding = winding;
		}
	
		function tracePaths(segments, operation) {
			var paths = [],
				start,
				otherStart,
				operator = operators[operation],
				overlapWinding = {
					unite: { 1: 2 },
					intersect: { 2: 1 }
				}[operation];
	
			function isValid(seg, adjusted) {
				if (seg._visited)
					return false;
				if (!operator)
					return true;
				var winding = seg._winding,
					inter = seg._intersection;
				if (inter && adjusted && overlapWinding && inter.isOverlap())
					winding = overlapWinding[winding] || winding;
				return operator(winding);
			}
	
			function isStart(seg) {
				return seg === start || seg === otherStart;
			}
	
			function findBestIntersection(inter, strict) {
				if (!inter._next)
					return inter;
				while (inter) {
					var seg = inter._segment,
						nextSeg = seg.getNext(),
						nextInter = nextSeg._intersection;
					if (isStart(nextSeg)
						|| !seg._visited && !nextSeg._visited
						&& (!operator
							|| (!strict || isValid(seg))
							&& (!(strict && nextInter && nextInter.isOverlap())
								&& isValid(nextSeg)
								|| !strict && nextInter
								&& isValid(nextInter._segment))
						))
						return inter;
					inter = inter._next;
				}
				return null;
			}
	
			function findStartSegment(inter, next) {
				while (inter) {
					var seg = inter._segment;
					if (isStart(seg))
						return seg;
					inter = inter[next ? '_next' : '_prev'];
				}
			}
	
			for (var i = 0, l = segments.length; i < l; i++) {
				var seg = segments[i],
					path = null,
					finished = false;
				if (!isValid(seg, true))
					continue;
				start = otherStart = null;
				while (!finished) {
					var inter = seg._intersection,
						handleIn = path && seg._handleIn;
					inter = inter && (findBestIntersection(inter, true)
							|| findBestIntersection(inter, false)) || inter;
					var other = inter && inter._segment;
					if (other && isValid(other))
						seg = other;
					if (seg._visited) {
						finished = isStart(seg);
						if (!finished && inter) {
							var found = findStartSegment(inter, true)
								|| findStartSegment(inter, false);
							if (found) {
								seg = found;
								finished = true;
							}
						}
						break;
					}
					if (!path) {
						path = new Path(Item.NO_INSERT);
						start = seg;
						otherStart = other;
					}
					path.add(new Segment(seg._point, handleIn, seg._handleOut));
					seg._visited = true;
					seg = seg.getNext();
					finished = isStart(seg);
				}
				if (finished) {
					path.firstSegment.setHandleIn(seg._handleIn);
					path.setClosed(true);
				} else if (path) {
					console.error('Boolean operation resulted in open path',
							'segments =', path._segments.length,
							'length =', path.getLength());
					path = null;
				}
				if (path && (path._segments.length > 8
						|| !Numerical.isZero(path.getArea()))) {
					paths.push(path);
					path = null;
				}
			}
			return paths;
		}
	
		return {
			_getWinding: function(point, horizontal, testContains) {
				return getWinding(point, this._getMonoCurves(),
						horizontal, testContains);
			},
	
			unite: function(path) {
				return computeBoolean(this, path, 'unite');
			},
	
			intersect: function(path) {
				return computeBoolean(this, path, 'intersect');
			},
	
			subtract: function(path) {
				return computeBoolean(this, path, 'subtract');
			},
	
			exclude: function(path) {
				return computeBoolean(this, path, 'exclude');
			},
	
			divide: function(path) {
				return finishBoolean(Group,
						[this.subtract(path), this.intersect(path)],
						this, path, true);
			},
	
			resolveCrossings: function() {
				var crossings = this.getCrossings();
				if (!crossings.length)
					return this;
				divideLocations(CurveLocation.expand(crossings));
				var paths = this._children || [this],
					segments = [];
				for (var i = 0, l = paths.length; i < l; i++) {
					segments.push.apply(segments, paths[i]._segments);
				}
				return finishBoolean(CompoundPath, tracePaths(segments),
						this, null, false);
			}
		};
	});
	
	Path.inject({
		_getMonoCurves: function() {
			var monoCurves = this._monoCurves,
				prevCurve;
	
			function insertCurve(v) {
				var y0 = v[1],
					y1 = v[7],
					curve = {
						values: v,
						winding: y0 === y1
							? 0
							: y0 > y1
								? -1
								: 1,
						previous: prevCurve,
						next: null
					};
				if (prevCurve)
					prevCurve.next = curve;
				monoCurves.push(curve);
				prevCurve = curve;
			}
	
			function handleCurve(v) {
				if (Curve.getLength(v) === 0)
					return;
				var y0 = v[1],
					y1 = v[3],
					y2 = v[5],
					y3 = v[7];
				if (Curve.isStraight(v)) {
					insertCurve(v);
				} else {
					var a = 3 * (y1 - y2) - y0 + y3,
						b = 2 * (y0 + y2) - 4 * y1,
						c = y1 - y0,
						tMin = 4e-7,
						tMax = 1 - tMin,
						roots = [],
						n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
					if (n === 0) {
						insertCurve(v);
					} else {
						roots.sort();
						var t = roots[0],
							parts = Curve.subdivide(v, t);
						insertCurve(parts[0]);
						if (n > 1) {
							t = (roots[1] - t) / (1 - t);
							parts = Curve.subdivide(parts[1], t);
							insertCurve(parts[0]);
						}
						insertCurve(parts[1]);
					}
				}
			}
	
			if (!monoCurves) {
				monoCurves = this._monoCurves = [];
				var curves = this.getCurves(),
					segments = this._segments;
				for (var i = 0, l = curves.length; i < l; i++)
					handleCurve(curves[i].getValues());
				if (!this._closed && segments.length > 1) {
					var p1 = segments[segments.length - 1]._point,
						p2 = segments[0]._point,
						p1x = p1._x, p1y = p1._y,
						p2x = p2._x, p2y = p2._y;
					handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
				}
				if (monoCurves.length > 0) {
					var first = monoCurves[0],
						last = monoCurves[monoCurves.length - 1];
					first.previous = last;
					last.next = first;
				}
			}
			return monoCurves;
		},
	
		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this._getMonoCurves(),
					roots = [],
					y = point.y,
					xIntercepts = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var values = curves[i].values;
					if ((curves[i].winding === 1
							&& y >= values[1] && y <= values[7]
							|| y >= values[7] && y <= values[1])
							&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
						for (var j = roots.length - 1; j >= 0; j--)
							xIntercepts.push(Curve.getPoint(values, roots[j]).x);
					}
					if (xIntercepts.length > 1)
						break;
				}
				point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
			}
			return point;
		},
	
		reorient: function() {
			this.setClockwise(true);
			return this;
		}
	});
	
	CompoundPath.inject({
		_getMonoCurves: function() {
			var children = this._children,
				monoCurves = [];
			for (var i = 0, l = children.length; i < l; i++)
				monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
			return monoCurves;
		},
	
		reorient: function() {
			var children = this.removeChildren().sort(function(a, b) {
				return b.getBounds().getArea() - a.getBounds().getArea();
			});
			if (children.length > 0) {
				this.addChildren(children);
				var clockwise = children[0].isClockwise();
				for (var i = 1, l = children.length; i < l; i++) {
					var point = children[i].getInteriorPoint(),
						counters = 0;
					for (var j = i - 1; j >= 0; j--) {
						if (children[j].contains(point))
							counters++;
					}
					children[i].setClockwise(counters % 2 === 0 && clockwise);
				}
			}
			return this;
		}
	});
	
	var PathIterator = Base.extend({
		_class: 'PathIterator',
	
		initialize: function(path, maxRecursion, tolerance, matrix) {
			var curves = [],
				parts = [],
				length = 0,
				minDifference = 1 / (maxRecursion || 32),
				segments = path._segments,
				segment1 = segments[0],
				segment2;
	
			function addCurve(segment1, segment2) {
				var curve = Curve.getValues(segment1, segment2, matrix);
				curves.push(curve);
				computeParts(curve, segment1._index, 0, 1);
			}
	
			function computeParts(curve, index, minT, maxT) {
				if ((maxT - minT) > minDifference
						&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
					var split = Curve.subdivide(curve, 0.5),
						halfT = (minT + maxT) / 2;
					computeParts(split[0], index, minT, halfT);
					computeParts(split[1], index, halfT, maxT);
				} else {
					var x = curve[6] - curve[0],
						y = curve[7] - curve[1],
						dist = Math.sqrt(x * x + y * y);
					if (dist > 1e-6) {
						length += dist;
						parts.push({
							offset: length,
							value: maxT,
							index: index
						});
					}
				}
			}
	
			for (var i = 1, l = segments.length; i < l; i++) {
				segment2 = segments[i];
				addCurve(segment1, segment2);
				segment1 = segment2;
			}
			if (path._closed)
				addCurve(segment2, segments[0]);
	
			this.curves = curves;
			this.parts = parts;
			this.length = length;
			this.index = 0;
		},
	
		getParameterAt: function(offset) {
			var i, j = this.index;
			for (;;) {
				i = j;
				if (j == 0 || this.parts[--j].offset < offset)
					break;
			}
			for (var l = this.parts.length; i < l; i++) {
				var part = this.parts[i];
				if (part.offset >= offset) {
					this.index = i;
					var prev = this.parts[i - 1];
					var prevVal = prev && prev.index == part.index ? prev.value : 0,
						prevLen = prev ? prev.offset : 0;
					return {
						value: prevVal + (part.value - prevVal)
							* (offset - prevLen) / (part.offset - prevLen),
						index: part.index
					};
				}
			}
			var part = this.parts[this.parts.length - 1];
			return {
				value: 1,
				index: part.index
			};
		},
	
		drawPart: function(ctx, from, to) {
			from = this.getParameterAt(from);
			to = this.getParameterAt(to);
			for (var i = from.index; i <= to.index; i++) {
				var curve = Curve.getPart(this.curves[i],
						i == from.index ? from.value : 0,
						i == to.index ? to.value : 1);
				if (i == from.index)
					ctx.moveTo(curve[0], curve[1]);
				ctx.bezierCurveTo.apply(ctx, curve.slice(2));
			}
		}
	}, Base.each(Curve.evaluateMethods,
		function(name) {
			this[name + 'At'] = function(offset, weighted) {
				var param = this.getParameterAt(offset);
				return Curve[name](this.curves[param.index], param.value, weighted);
			};
		}, {})
	);
	
	var PathFitter = Base.extend({
		initialize: function(path, error) {
			var points = this.points = [],
				segments = path._segments,
				prev;
			for (var i = 0, l = segments.length; i < l; i++) {
				var point = segments[i].point.clone();
				if (!prev || !prev.equals(point)) {
					points.push(point);
					prev = point;
				}
			}
	
			if (path._closed) {
				this.closed = true;
				points.unshift(points[points.length - 1]);
				points.push(points[1]);
			}
	
			this.error = error;
		},
	
		fit: function() {
			var points = this.points,
				length = points.length,
				segments = this.segments = length > 0
						? [new Segment(points[0])] : [];
			if (length > 1)
				this.fitCubic(0, length - 1,
					points[1].subtract(points[0]).normalize(),
					points[length - 2].subtract(points[length - 1]).normalize());
	
			if (this.closed) {
				segments.shift();
				segments.pop();
			}
	
			return segments;
		},
	
		fitCubic: function(first, last, tan1, tan2) {
			if (last - first == 1) {
				var pt1 = this.points[first],
					pt2 = this.points[last],
					dist = pt1.getDistance(pt2) / 3;
				this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
						pt2.add(tan2.normalize(dist)), pt2]);
				return;
			}
			var uPrime = this.chordLengthParameterize(first, last),
				maxError = Math.max(this.error, this.error * this.error),
				split,
				parametersInOrder = true;
			for (var i = 0; i <= 4; i++) {
				var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
				var max = this.findMaxError(first, last, curve, uPrime);
				if (max.error < this.error && parametersInOrder) {
					this.addCurve(curve);
					return;
				}
				split = max.index;
				if (max.error >= maxError)
					break;
				parametersInOrder = this.reparameterize(first, last, uPrime, curve);
				maxError = max.error;
			}
			var V1 = this.points[split - 1].subtract(this.points[split]),
				V2 = this.points[split].subtract(this.points[split + 1]),
				tanCenter = V1.add(V2).divide(2).normalize();
			this.fitCubic(first, split, tan1, tanCenter);
			this.fitCubic(split, last, tanCenter.negate(), tan2);
		},
	
		addCurve: function(curve) {
			var prev = this.segments[this.segments.length - 1];
			prev.setHandleOut(curve[1].subtract(curve[0]));
			this.segments.push(
					new Segment(curve[3], curve[2].subtract(curve[3])));
		},
	
		generateBezier: function(first, last, uPrime, tan1, tan2) {
			var epsilon = 1e-12,
				pt1 = this.points[first],
				pt2 = this.points[last],
				C = [[0, 0], [0, 0]],
				X = [0, 0];
	
			for (var i = 0, l = last - first + 1; i < l; i++) {
				var u = uPrime[i],
					t = 1 - u,
					b = 3 * u * t,
					b0 = t * t * t,
					b1 = b * t,
					b2 = b * u,
					b3 = u * u * u,
					a1 = tan1.normalize(b1),
					a2 = tan2.normalize(b2),
					tmp = this.points[first + i]
						.subtract(pt1.multiply(b0 + b1))
						.subtract(pt2.multiply(b2 + b3));
				C[0][0] += a1.dot(a1);
				C[0][1] += a1.dot(a2);
				C[1][0] = C[0][1];
				C[1][1] += a2.dot(a2);
				X[0] += a1.dot(tmp);
				X[1] += a2.dot(tmp);
			}
	
			var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
				alpha1, alpha2;
			if (Math.abs(detC0C1) > epsilon) {
				var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
					detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
				alpha1 = detXC1 / detC0C1;
				alpha2 = detC0X / detC0C1;
			} else {
				var c0 = C[0][0] + C[0][1],
					c1 = C[1][0] + C[1][1];
				if (Math.abs(c0) > epsilon) {
					alpha1 = alpha2 = X[0] / c0;
				} else if (Math.abs(c1) > epsilon) {
					alpha1 = alpha2 = X[1] / c1;
				} else {
					alpha1 = alpha2 = 0;
				}
			}
	
			var segLength = pt2.getDistance(pt1),
				eps = epsilon * segLength,
				handle1,
				handle2;
			if (alpha1 < eps || alpha2 < eps) {
				alpha1 = alpha2 = segLength / 3;
			} else {
				var line = pt2.subtract(pt1);
				handle1 = tan1.normalize(alpha1);
				handle2 = tan2.normalize(alpha2);
				if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
					alpha1 = alpha2 = segLength / 3;
					handle1 = handle2 = null;
				}
			}
	
			return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),
					pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
		},
	
		reparameterize: function(first, last, u, curve) {
			for (var i = first; i <= last; i++) {
				u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
			}
			for (var i = 1, l = u.length; i < l; i++) {
				if (u[i] <= u[i - 1])
					return false;
			}
			return true;
		},
	
		findRoot: function(curve, point, u) {
			var curve1 = [],
				curve2 = [];
			for (var i = 0; i <= 2; i++) {
				curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
			}
			for (var i = 0; i <= 1; i++) {
				curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
			}
			var pt = this.evaluate(3, curve, u),
				pt1 = this.evaluate(2, curve1, u),
				pt2 = this.evaluate(1, curve2, u),
				diff = pt.subtract(point),
				df = pt1.dot(pt1) + diff.dot(pt2);
			if (Math.abs(df) < 1e-6)
				return u;
			return u - diff.dot(pt1) / df;
		},
	
		evaluate: function(degree, curve, t) {
			var tmp = curve.slice();
			for (var i = 1; i <= degree; i++) {
				for (var j = 0; j <= degree - i; j++) {
					tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
				}
			}
			return tmp[0];
		},
	
		chordLengthParameterize: function(first, last) {
			var u = [0];
			for (var i = first + 1; i <= last; i++) {
				u[i - first] = u[i - first - 1]
						+ this.points[i].getDistance(this.points[i - 1]);
			}
			for (var i = 1, m = last - first; i <= m; i++) {
				u[i] /= u[m];
			}
			return u;
		},
	
		findMaxError: function(first, last, curve, u) {
			var index = Math.floor((last - first + 1) / 2),
				maxDist = 0;
			for (var i = first + 1; i < last; i++) {
				var P = this.evaluate(3, curve, u[i - first]);
				var v = P.subtract(this.points[i]);
				var dist = v.x * v.x + v.y * v.y;
				if (dist >= maxDist) {
					maxDist = dist;
					index = i;
				}
			}
			return {
				error: maxDist,
				index: index
			};
		}
	});
	
	var TextItem = Item.extend({
		_class: 'TextItem',
		_boundsSelected: true,
		_applyMatrix: false,
		_canApplyMatrix: false,
		_serializeFields: {
			content: null
		},
		_boundsGetter: 'getBounds',
	
		initialize: function TextItem(arg) {
			this._content = '';
			this._lines = [];
			var hasProps = arg && Base.isPlainObject(arg)
					&& arg.x === undefined && arg.y === undefined;
			this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
		},
	
		_equals: function(item) {
			return this._content === item._content;
		},
	
		_clone: function _clone(copy, insert, includeMatrix) {
			copy.setContent(this._content);
			return _clone.base.call(this, copy, insert, includeMatrix);
		},
	
		getContent: function() {
			return this._content;
		},
	
		setContent: function(content) {
			this._content = '' + content;
			this._lines = this._content.split(/\r\n|\n|\r/mg);
			this._changed(265);
		},
	
		isEmpty: function() {
			return !this._content;
		},
	
		getCharacterStyle: '#getStyle',
		setCharacterStyle: '#setStyle',
	
		getParagraphStyle: '#getStyle',
		setParagraphStyle: '#setStyle'
	});
	
	var PointText = TextItem.extend({
		_class: 'PointText',
	
		initialize: function PointText() {
			TextItem.apply(this, arguments);
		},
	
		clone: function(insert) {
			return this._clone(new PointText(Item.NO_INSERT), insert);
		},
	
		getPoint: function() {
			var point = this._matrix.getTranslation();
			return new LinkedPoint(point.x, point.y, this, 'setPoint');
		},
	
		setPoint: function() {
			var point = Point.read(arguments);
			this.translate(point.subtract(this._matrix.getTranslation()));
		},
	
		_draw: function(ctx) {
			if (!this._content)
				return;
			this._setStyles(ctx);
			var style = this._style,
				lines = this._lines,
				leading = style.getLeading(),
				shadowColor = ctx.shadowColor;
			ctx.font = style.getFontStyle();
			ctx.textAlign = style.getJustification();
			for (var i = 0, l = lines.length; i < l; i++) {
				ctx.shadowColor = shadowColor;
				var line = lines[i];
				if (style.hasFill()) {
					ctx.fillText(line, 0, 0);
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (style.hasStroke())
					ctx.strokeText(line, 0, 0);
				ctx.translate(0, leading);
			}
		},
	
		_getBounds: function(getter, matrix) {
			var style = this._style,
				lines = this._lines,
				numLines = lines.length,
				justification = style.getJustification(),
				leading = style.getLeading(),
				width = this.getView().getTextWidth(style.getFontStyle(), lines),
				x = 0;
			if (justification !== 'left')
				x -= width / (justification === 'center' ? 2: 1);
			var bounds = new Rectangle(x,
						numLines ? - 0.75 * leading : 0,
						width, numLines * leading);
			return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
		}
	});
	
	var Color = Base.extend(new function() {
		var types = {
			gray: ['gray'],
			rgb: ['red', 'green', 'blue'],
			hsb: ['hue', 'saturation', 'brightness'],
			hsl: ['hue', 'saturation', 'lightness'],
			gradient: ['gradient', 'origin', 'destination', 'highlight']
		};
	
		var componentParsers = {},
			colorCache = {},
			colorCtx;
	
		function fromCSS(string) {
			var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
				components;
			if (match) {
				components = [0, 0, 0];
				for (var i = 0; i < 3; i++) {
					var value = match[i + 1];
					components[i] = parseInt(value.length == 1
							? value + value : value, 16) / 255;
				}
			} else if (match = string.match(/^rgba?\((.*)\)$/)) {
				components = match[1].split(',');
				for (var i = 0, l = components.length; i < l; i++) {
					var value = +components[i];
					components[i] = i < 3 ? value / 255 : value;
				}
			} else {
				var cached = colorCache[string];
				if (!cached) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					cached = colorCache[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				}
				components = cached.slice();
			}
			return components;
		}
	
		var hsbIndices = [
			[0, 3, 1],
			[2, 0, 1],
			[1, 0, 3],
			[1, 2, 0],
			[3, 1, 0],
			[0, 1, 2]
		];
	
		var converters = {
			'rgb-hsb': function(r, g, b) {
				var max = Math.max(r, g, b),
					min = Math.min(r, g, b),
					delta = max - min,
					h = delta === 0 ? 0
						:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
							: max == g ? (b - r) / delta + 2
							:			 (r - g) / delta + 4) * 60;
				return [h, max === 0 ? 0 : delta / max, max];
			},
	
			'hsb-rgb': function(h, s, b) {
				h = (((h / 60) % 6) + 6) % 6;
				var i = Math.floor(h),
					f = h - i,
					i = hsbIndices[i],
					v = [
						b,
						b * (1 - s),
						b * (1 - s * f),
						b * (1 - s * (1 - f))
					];
				return [v[i[0]], v[i[1]], v[i[2]]];
			},
	
			'rgb-hsl': function(r, g, b) {
				var max = Math.max(r, g, b),
					min = Math.min(r, g, b),
					delta = max - min,
					achromatic = delta === 0,
					h = achromatic ? 0
						:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
							: max == g ? (b - r) / delta + 2
							:			 (r - g) / delta + 4) * 60,
					l = (max + min) / 2,
					s = achromatic ? 0 : l < 0.5
							? delta / (max + min)
							: delta / (2 - max - min);
				return [h, s, l];
			},
	
			'hsl-rgb': function(h, s, l) {
				h = (((h / 360) % 1) + 1) % 1;
				if (s === 0)
					return [l, l, l];
				var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
					t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
					t1 = 2 * l - t2,
					c = [];
				for (var i = 0; i < 3; i++) {
					var t3 = t3s[i];
					if (t3 < 0) t3 += 1;
					if (t3 > 1) t3 -= 1;
					c[i] = 6 * t3 < 1
						? t1 + (t2 - t1) * 6 * t3
						: 2 * t3 < 1
							? t2
							: 3 * t3 < 2
								? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
								: t1;
				}
				return c;
			},
	
			'rgb-gray': function(r, g, b) {
				return [r * 0.2989 + g * 0.587 + b * 0.114];
			},
	
			'gray-rgb': function(g) {
				return [g, g, g];
			},
	
			'gray-hsb': function(g) {
				return [0, 0, g];
			},
	
			'gray-hsl': function(g) {
				return [0, 0, g];
			},
	
			'gradient-rgb': function() {
				return [];
			},
	
			'rgb-gradient': function() {
				return [];
			}
	
		};
	
		return Base.each(types, function(properties, type) {
			componentParsers[type] = [];
			Base.each(properties, function(name, index) {
				var part = Base.capitalize(name),
					hasOverlap = /^(hue|saturation)$/.test(name),
					parser = componentParsers[type][index] = name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(Array.isArray(value) ? value
									: arguments, 0, { readNull: true });
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: type === 'gradient'
							? function() {
								return Point.read(arguments, 0, {
										readNull: name === 'highlight',
										clone: true
								});
							}
							: function(value) {
								return value == null || isNaN(value) ? 0 : value;
							};
	
				this['get' + part] = function() {
					return this._type === type
						|| hasOverlap && /^hs[bl]$/.test(this._type)
							? this._components[index]
							: this._convert(type)[index];
				};
	
				this['set' + part] = function(value) {
					if (this._type !== type
							&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
						this._components = this._convert(type);
						this._properties = types[type];
						this._type = type;
					}
					this._components[index] = parser.call(this, value);
					this._changed();
				};
			}, this);
		}, {
			_class: 'Color',
			_readIndex: true,
	
			initialize: function Color(arg) {
				var slice = Array.prototype.slice,
					args = arguments,
					read = 0,
					type,
					components,
					alpha,
					values;
				if (Array.isArray(arg)) {
					args = arg;
					arg = args[0];
				}
				var argType = arg != null && typeof arg;
				if (argType === 'string' && arg in types) {
					type = arg;
					arg = args[1];
					if (Array.isArray(arg)) {
						components = arg;
						alpha = args[2];
					} else {
						if (this.__read)
							read = 1;
						args = slice.call(args, 1);
						argType = typeof arg;
					}
				}
				if (!components) {
					values = argType === 'number'
							? args
							: argType === 'object' && arg.length != null
								? arg
								: null;
					if (values) {
						if (!type)
							type = values.length >= 3
									? 'rgb'
									: 'gray';
						var length = types[type].length;
						alpha = values[length];
						if (this.__read)
							read += values === arguments
								? length + (alpha != null ? 1 : 0)
								: 1;
						if (values.length > length)
							values = slice.call(values, 0, length);
					} else if (argType === 'string') {
						type = 'rgb';
						components = fromCSS(arg);
						if (components.length === 4) {
							alpha = components[3];
							components.length--;
						}
					} else if (argType === 'object') {
						if (arg.constructor === Color) {
							type = arg._type;
							components = arg._components.slice();
							alpha = arg._alpha;
							if (type === 'gradient') {
								for (var i = 1, l = components.length; i < l; i++) {
									var point = components[i];
									if (point)
										components[i] = point.clone();
								}
							}
						} else if (arg.constructor === Gradient) {
							type = 'gradient';
							values = args;
						} else {
							type = 'hue' in arg
								? 'lightness' in arg
									? 'hsl'
									: 'hsb'
								: 'gradient' in arg || 'stops' in arg
										|| 'radial' in arg
									? 'gradient'
									: 'gray' in arg
										? 'gray'
										: 'rgb';
							var properties = types[type],
								parsers = componentParsers[type];
							this._components = components = [];
							for (var i = 0, l = properties.length; i < l; i++) {
								var value = arg[properties[i]];
								if (value == null && i === 0 && type === 'gradient'
										&& 'stops' in arg) {
									value = {
										stops: arg.stops,
										radial: arg.radial
									};
								}
								value = parsers[i].call(this, value);
								if (value != null)
									components[i] = value;
							}
							alpha = arg.alpha;
						}
					}
					if (this.__read && type)
						read = 1;
				}
				this._type = type || 'rgb';
				this._id = UID.get(Color);
				if (!components) {
					this._components = components = [];
					var parsers = componentParsers[this._type];
					for (var i = 0, l = parsers.length; i < l; i++) {
						var value = parsers[i].call(this, values && values[i]);
						if (value != null)
							components[i] = value;
					}
				}
				this._components = components;
				this._properties = types[this._type];
				this._alpha = alpha;
				if (this.__read)
					this.__read = read;
			},
	
			_serialize: function(options, dictionary) {
				var components = this.getComponents();
				return Base.serialize(
						/^(gray|rgb)$/.test(this._type)
							? components
							: [this._type].concat(components),
						options, true, dictionary);
			},
	
			_changed: function() {
				this._canvasStyle = null;
				if (this._owner)
					this._owner._changed(65);
			},
	
			_convert: function(type) {
				var converter;
				return this._type === type
						? this._components.slice()
						: (converter = converters[this._type + '-' + type])
							? converter.apply(this, this._components)
							: converters['rgb-' + type].apply(this,
								converters[this._type + '-rgb'].apply(this,
									this._components));
			},
	
			convert: function(type) {
				return new Color(type, this._convert(type), this._alpha);
			},
	
			getType: function() {
				return this._type;
			},
	
			setType: function(type) {
				this._components = this._convert(type);
				this._properties = types[type];
				this._type = type;
			},
	
			getComponents: function() {
				var components = this._components.slice();
				if (this._alpha != null)
					components.push(this._alpha);
				return components;
			},
	
			getAlpha: function() {
				return this._alpha != null ? this._alpha : 1;
			},
	
			setAlpha: function(alpha) {
				this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
				this._changed();
			},
	
			hasAlpha: function() {
				return this._alpha != null;
			},
	
			equals: function(color) {
				var col = Base.isPlainValue(color, true)
						? Color.read(arguments)
						: color;
				return col === this || col && this._class === col._class
						&& this._type === col._type
						&& this._alpha === col._alpha
						&& Base.equals(this._components, col._components)
						|| false;
			},
	
			toString: function() {
				var properties = this._properties,
					parts = [],
					isGradient = this._type === 'gradient',
					f = Formatter.instance;
				for (var i = 0, l = properties.length; i < l; i++) {
					var value = this._components[i];
					if (value != null)
						parts.push(properties[i] + ': '
								+ (isGradient ? value : f.number(value)));
				}
				if (this._alpha != null)
					parts.push('alpha: ' + f.number(this._alpha));
				return '{ ' + parts.join(', ') + ' }';
			},
	
			toCSS: function(hex) {
				var components = this._convert('rgb'),
					alpha = hex || this._alpha == null ? 1 : this._alpha;
				function convert(val) {
					return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
				}
				components = [
					convert(components[0]),
					convert(components[1]),
					convert(components[2])
				];
				if (alpha < 1)
					components.push(alpha < 0 ? 0 : alpha);
				return hex
						? '#' + ((1 << 24) + (components[0] << 16)
							+ (components[1] << 8)
							+ components[2]).toString(16).slice(1)
						: (components.length == 4 ? 'rgba(' : 'rgb(')
							+ components.join(',') + ')';
			},
	
			toCanvasStyle: function(ctx) {
				if (this._canvasStyle)
					return this._canvasStyle;
				if (this._type !== 'gradient')
					return this._canvasStyle = this.toCSS();
				var components = this._components,
					gradient = components[0],
					stops = gradient._stops,
					origin = components[1],
					destination = components[2],
					canvasGradient;
				if (gradient._radial) {
					var radius = destination.getDistance(origin),
						highlight = components[3];
					if (highlight) {
						var vector = highlight.subtract(origin);
						if (vector.getLength() > radius)
							highlight = origin.add(vector.normalize(radius - 0.1));
					}
					var start = highlight || origin;
					canvasGradient = ctx.createRadialGradient(start.x, start.y,
							0, origin.x, origin.y, radius);
				} else {
					canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
							destination.x, destination.y);
				}
				for (var i = 0, l = stops.length; i < l; i++) {
					var stop = stops[i];
					canvasGradient.addColorStop(stop._rampPoint,
							stop._color.toCanvasStyle());
				}
				return this._canvasStyle = canvasGradient;
			},
	
			transform: function(matrix) {
				if (this._type === 'gradient') {
					var components = this._components;
					for (var i = 1, l = components.length; i < l; i++) {
						var point = components[i];
						matrix._transformPoint(point, point, true);
					}
					this._changed();
				}
			},
	
			statics: {
				_types: types,
	
				random: function() {
					var random = Math.random;
					return new Color(random(), random(), random());
				}
			}
		});
	},
	new function() {
		var operators = {
			add: function(a, b) {
				return a + b;
			},
	
			subtract: function(a, b) {
				return a - b;
			},
	
			multiply: function(a, b) {
				return a * b;
			},
	
			divide: function(a, b) {
				return a / b;
			}
		};
	
		return Base.each(operators, function(operator, name) {
			this[name] = function(color) {
				color = Color.read(arguments);
				var type = this._type,
					components1 = this._components,
					components2 = color._convert(type);
				for (var i = 0, l = components1.length; i < l; i++)
					components2[i] = operator(components1[i], components2[i]);
				return new Color(type, components2,
						this._alpha != null
								? operator(this._alpha, color.getAlpha())
								: null);
			};
		}, {
		});
	});
	
	var Gradient = Base.extend({
		_class: 'Gradient',
	
		initialize: function Gradient(stops, radial) {
			this._id = UID.get();
			if (stops && this._set(stops))
				stops = radial = null;
			if (!this._stops)
				this.setStops(stops || ['white', 'black']);
			if (this._radial == null)
				this.setRadial(typeof radial === 'string' && radial === 'radial'
						|| radial || false);
		},
	
		_serialize: function(options, dictionary) {
			return dictionary.add(this, function() {
				return Base.serialize([this._stops, this._radial],
						options, true, dictionary);
			});
		},
	
		_changed: function() {
			for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
				this._owners[i]._changed();
		},
	
		_addOwner: function(color) {
			if (!this._owners)
				this._owners = [];
			this._owners.push(color);
		},
	
		_removeOwner: function(color) {
			var index = this._owners ? this._owners.indexOf(color) : -1;
			if (index != -1) {
				this._owners.splice(index, 1);
				if (this._owners.length === 0)
					this._owners = undefined;
			}
		},
	
		clone: function() {
			var stops = [];
			for (var i = 0, l = this._stops.length; i < l; i++)
				stops[i] = this._stops[i].clone();
			return new Gradient(stops, this._radial);
		},
	
		getStops: function() {
			return this._stops;
		},
	
		setStops: function(stops) {
			if (this.stops) {
				for (var i = 0, l = this._stops.length; i < l; i++)
					this._stops[i]._owner = undefined;
			}
			if (stops.length < 2)
				throw new Error(
						'Gradient stop list needs to contain at least two stops.');
			this._stops = GradientStop.readAll(stops, 0, { clone: true });
			for (var i = 0, l = this._stops.length; i < l; i++) {
				var stop = this._stops[i];
				stop._owner = this;
				if (stop._defaultRamp)
					stop.setRampPoint(i / (l - 1));
			}
			this._changed();
		},
	
		getRadial: function() {
			return this._radial;
		},
	
		setRadial: function(radial) {
			this._radial = radial;
			this._changed();
		},
	
		equals: function(gradient) {
			if (gradient === this)
				return true;
			if (gradient && this._class === gradient._class
					&& this._stops.length === gradient._stops.length) {
				for (var i = 0, l = this._stops.length; i < l; i++) {
					if (!this._stops[i].equals(gradient._stops[i]))
						return false;
				}
				return true;
			}
			return false;
		}
	});
	
	var GradientStop = Base.extend({
		_class: 'GradientStop',
	
		initialize: function GradientStop(arg0, arg1) {
			if (arg0) {
				var color, rampPoint;
				if (arg1 === undefined && Array.isArray(arg0)) {
					color = arg0[0];
					rampPoint = arg0[1];
				} else if (arg0.color) {
					color = arg0.color;
					rampPoint = arg0.rampPoint;
				} else {
					color = arg0;
					rampPoint = arg1;
				}
				this.setColor(color);
				this.setRampPoint(rampPoint);
			}
		},
	
		clone: function() {
			return new GradientStop(this._color.clone(), this._rampPoint);
		},
	
		_serialize: function(options, dictionary) {
			return Base.serialize([this._color, this._rampPoint], options, true,
					dictionary);
		},
	
		_changed: function() {
			if (this._owner)
				this._owner._changed(65);
		},
	
		getRampPoint: function() {
			return this._rampPoint;
		},
	
		setRampPoint: function(rampPoint) {
			this._defaultRamp = rampPoint == null;
			this._rampPoint = rampPoint || 0;
			this._changed();
		},
	
		getColor: function() {
			return this._color;
		},
	
		setColor: function(color) {
			this._color = Color.read(arguments);
			if (this._color === color)
				this._color = color.clone();
			this._color._owner = this;
			this._changed();
		},
	
		equals: function(stop) {
			return stop === this || stop && this._class === stop._class
					&& this._color.equals(stop._color)
					&& this._rampPoint == stop._rampPoint
					|| false;
		}
	});
	
	var Style = Base.extend(new function() {
		var defaults = {
			fillColor: undefined,
			strokeColor: undefined,
			strokeWidth: 1,
			strokeCap: 'butt',
			strokeJoin: 'miter',
			strokeScaling: true,
			miterLimit: 10,
			dashOffset: 0,
			dashArray: [],
			windingRule: 'nonzero',
			shadowColor: undefined,
			shadowBlur: 0,
			shadowOffset: new Point(),
			selectedColor: undefined,
			fontFamily: 'sans-serif',
			fontWeight: 'normal',
			fontSize: 12,
			font: 'sans-serif',
			leading: null,
			justification: 'left'
		};
	
		var flags = {
			strokeWidth: 97,
			strokeCap: 97,
			strokeJoin: 97,
			strokeScaling: 105,
			miterLimit: 97,
			fontFamily: 9,
			fontWeight: 9,
			fontSize: 9,
			font: 9,
			leading: 9,
			justification: 9
		};
	
		var item = { beans: true },
			fields = {
				_defaults: defaults,
				_textDefaults: new Base(defaults, {
					fillColor: new Color()
				}),
				beans: true
			};
	
		Base.each(defaults, function(value, key) {
			var isColor = /Color$/.test(key),
				isPoint = key === 'shadowOffset',
				part = Base.capitalize(key),
				flag = flags[key],
				set = 'set' + part,
				get = 'get' + part;
	
			fields[set] = function(value) {
				var owner = this._owner,
					children = owner && owner._children;
				if (children && children.length > 0
						&& !(owner instanceof CompoundPath)) {
					for (var i = 0, l = children.length; i < l; i++)
						children[i]._style[set](value);
				} else {
					var old = this._values[key];
					if (old !== value) {
						if (isColor) {
							if (old)
								old._owner = undefined;
							if (value && value.constructor === Color) {
								if (value._owner)
									value = value.clone();
								value._owner = owner;
							}
						}
						this._values[key] = value;
						if (owner)
							owner._changed(flag || 65);
					}
				}
			};
	
			fields[get] = function(_dontMerge) {
				var owner = this._owner,
					children = owner && owner._children,
					value;
				if (!children || children.length === 0 || _dontMerge
						|| owner instanceof CompoundPath) {
					var value = this._values[key];
					if (value === undefined) {
						value = this._defaults[key];
						if (value && value.clone)
							value = value.clone();
					} else {
						var ctor = isColor ? Color : isPoint ? Point : null;
						if (ctor && !(value && value.constructor === ctor)) {
							this._values[key] = value = ctor.read([value], 0,
									{ readNull: true, clone: true });
							if (value && isColor)
								value._owner = owner;
						}
					}
					return value;
				}
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (i === 0) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
				return value;
			};
	
			item[get] = function(_dontMerge) {
				return this._style[get](_dontMerge);
			};
	
			item[set] = function(value) {
				this._style[set](value);
			};
		});
	
		Item.inject(item);
		return fields;
	}, {
		_class: 'Style',
	
		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project || paper.project;
			if (_owner instanceof TextItem)
				this._defaults = this._textDefaults;
			if (style)
				this.set(style);
		},
	
		set: function(style) {
			var isStyle = style instanceof Style,
				values = isStyle ? style._values : style;
			if (values) {
				for (var key in values) {
					if (key in this._defaults) {
						var value = values[key];
						this[key] = value && isStyle && value.clone
								? value.clone() : value;
					}
				}
			}
		},
	
		equals: function(style) {
			return style === this || style && this._class === style._class
					&& Base.equals(this._values, style._values)
					|| false;
		},
	
		hasFill: function() {
			return !!this.getFillColor();
		},
	
		hasStroke: function() {
			return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
		},
	
		hasShadow: function() {
			return !!this.getShadowColor() && this.getShadowBlur() > 0;
		},
	
		getView: function() {
			return this._project.getView();
		},
	
		getFontStyle: function() {
			var fontSize = this.getFontSize();
			return this.getFontWeight()
					+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
					+ this.getFontFamily();
		},
	
		getFont: '#getFontFamily',
		setFont: '#setFontFamily',
	
		getLeading: function getLeading() {
			var leading = getLeading.base.call(this),
				fontSize = this.getFontSize();
			if (/pt|em|%|px/.test(fontSize))
				fontSize = this.getView().getPixelSize(fontSize);
			return leading != null ? leading : fontSize * 1.2;
		}
	
	});
	
	var DomElement = new function() {
		function handlePrefix(el, name, set, value) {
			var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
				suffix = name[0].toUpperCase() + name.substring(1);
			for (var i = 0; i < 6; i++) {
				var prefix = prefixes[i],
					key = prefix ? prefix + suffix : name;
				if (key in el) {
					if (set) {
						el[key] = value;
					} else {
						return el[key];
					}
					break;
				}
			}
		}
	
		return {
			getStyles: function(el) {
				var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
					view = doc && doc.defaultView;
				return view && view.getComputedStyle(el, '');
			},
	
			getBounds: function(el, viewport) {
				var doc = el.ownerDocument,
					body = doc.body,
					html = doc.documentElement,
					rect;
				try {
					rect = el.getBoundingClientRect();
				} catch (e) {
					rect = { left: 0, top: 0, width: 0, height: 0 };
				}
				var x = rect.left - (html.clientLeft || body.clientLeft || 0),
					y = rect.top - (html.clientTop || body.clientTop || 0);
				if (!viewport) {
					var view = doc.defaultView;
					x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
					y += view.pageYOffset || html.scrollTop || body.scrollTop;
				}
				return new Rectangle(x, y, rect.width, rect.height);
			},
	
			getViewportBounds: function(el) {
				var doc = el.ownerDocument,
					view = doc.defaultView,
					html = doc.documentElement;
				return new Rectangle(0, 0,
					view.innerWidth || html.clientWidth,
					view.innerHeight || html.clientHeight
				);
			},
	
			getOffset: function(el, viewport) {
				return DomElement.getBounds(el, viewport).getPoint();
			},
	
			getSize: function(el) {
				return DomElement.getBounds(el, true).getSize();
			},
	
			isInvisible: function(el) {
				return DomElement.getSize(el).equals(new Size(0, 0));
			},
	
			isInView: function(el) {
				return !DomElement.isInvisible(el)
						&& DomElement.getViewportBounds(el).intersects(
							DomElement.getBounds(el, true));
			},
	
			getPrefixed: function(el, name) {
				return handlePrefix(el, name);
			},
	
			setPrefixed: function(el, name, value) {
				if (typeof name === 'object') {
					for (var key in name)
						handlePrefix(el, key, true, name[key]);
				} else {
					handlePrefix(el, name, true, value);
				}
			}
		};
	};
	
	var DomEvent = {
		add: function(el, events) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.addEventListener(parts[i], func, false);
			}
		},
	
		remove: function(el, events) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		},
	
		getPoint: function(event) {
			var pos = event.targetTouches
					? event.targetTouches.length
						? event.targetTouches[0]
						: event.changedTouches[0]
					: event;
			return new Point(
				pos.pageX || pos.clientX + document.documentElement.scrollLeft,
				pos.pageY || pos.clientY + document.documentElement.scrollTop
			);
		},
	
		getTarget: function(event) {
			return event.target || event.srcElement;
		},
	
		getRelatedTarget: function(event) {
			return event.relatedTarget || event.toElement;
		},
	
		getOffset: function(event, target) {
			return DomEvent.getPoint(event).subtract(DomElement.getOffset(
					target || DomEvent.getTarget(event)));
		},
	
		stop: function(event) {
			event.stopPropagation();
			event.preventDefault();
		}
	};
	
	DomEvent.requestAnimationFrame = new function() {
		var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
			requested = false,
			callbacks = [],
			focused = true,
			timer;
	
		DomEvent.add(window, {
			focus: function() {
				focused = true;
			},
			blur: function() {
				focused = false;
			}
		});
	
		function handleCallbacks() {
			for (var i = callbacks.length - 1; i >= 0; i--) {
				var entry = callbacks[i],
					func = entry[0],
					el = entry[1];
				if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
						|| focused) && DomElement.isInView(el)) {
					callbacks.splice(i, 1);
					func();
				}
			}
			if (nativeRequest) {
				if (callbacks.length) {
					nativeRequest(handleCallbacks);
				} else {
					requested = false;
				}
			}
		}
	
		return function(callback, element) {
			callbacks.push([callback, element]);
			if (nativeRequest) {
				if (!requested) {
					nativeRequest(handleCallbacks);
					requested = true;
				}
			} else if (!timer) {
				timer = setInterval(handleCallbacks, 1000 / 60);
			}
		};
	};
	
	var View = Base.extend(Emitter, {
		_class: 'View',
	
		initialize: function View(project, element) {
			this._project = project;
			this._scope = project._scope;
			this._element = element;
			var size;
			if (!this._pixelRatio)
				this._pixelRatio = window.devicePixelRatio || 1;
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userSelect: none,
				touchAction: none,
				touchCallout: none,
				contentZooming: none,
				userDrag: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});
	
			function getSize(name) {
				return element[name] || parseInt(element.getAttribute(name), 10);
			};
	
			function getCanvasSize() {
				var size = DomElement.getSize(element);
				return size.isNaN() || size.isZero()
						? new Size(getSize('width'), getSize('height'))
						: size;
			};
	
			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}
			this._setViewSize(size = getCanvasSize());
			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
			View._views.push(this);
			View._viewsById[this._id] = this;
			this._viewSize = size;
			(this._matrix = new Matrix())._owner = this;
			this._zoom = 1;
			if (!View._focused)
				View._focused = this;
			this._frameItems = {};
			this._frameItemCount = 0;
		},
	
		remove: function() {
			if (!this._project)
				return false;
			if (View._focused === this)
				View._focused = null;
			View._views.splice(View._views.indexOf(this), 1);
			delete View._viewsById[this._id];
			if (this._project._view === this)
				this._project._view = null;
			DomEvent.remove(this._element, this._viewEvents);
			DomEvent.remove(window, this._windowEvents);
			this._element = this._project = null;
			this.off('frame');
			this._animate = false;
			this._frameItems = {};
			return true;
		},
	
		_events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'],
			function(name) {
				this[name] = {
					install: function(type) {
						this._installEvent(type);
					},
	
					uninstall: function(type) {
						this._uninstallEvent(type);
					}
				};
			}, {
				onFrame: {
					install: function() {
						this.play();
					},
	
					uninstall: function() {
						this.pause();
					}
				}
			}
		),
	
		_animate: false,
		_time: 0,
		_count: 0,
	
		_requestFrame: function() {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (!that._animate)
					return;
				that._requestFrame();
				that._handleFrame();
			}, this._element);
			this._requested = true;
		},
	
		_handleFrame: function() {
			paper = this._scope;
			var now = Date.now() / 1000,
				delta = this._before ? now - this._before : 0;
			this._before = now;
			this._handlingFrame = true;
			this.emit('frame', new Base({
				delta: delta,
				time: this._time += delta,
				count: this._count++
			}));
			if (this._stats)
				this._stats.update();
			this._handlingFrame = false;
			this.update();
		},
	
		_animateItem: function(item, animate) {
			var items = this._frameItems;
			if (animate) {
				items[item._id] = {
					item: item,
					time: 0,
					count: 0
				};
				if (++this._frameItemCount === 1)
					this.on('frame', this._handleFrameItems);
			} else {
				delete items[item._id];
				if (--this._frameItemCount === 0) {
					this.off('frame', this._handleFrameItems);
				}
			}
		},
	
		_handleFrameItems: function(event) {
			for (var i in this._frameItems) {
				var entry = this._frameItems[i];
				entry.item.emit('frame', new Base(event, {
					time: entry.time += event.delta,
					count: entry.count++
				}));
			}
		},
	
		_update: function() {
			this._project._needsUpdate = true;
			if (this._handlingFrame)
				return;
			if (this._animate) {
				this._handleFrame();
			} else {
				this.update();
			}
		},
	
		_changed: function(flags) {
			if (flags & 1)
				this._project._needsUpdate = true;
		},
	
		_transform: function(matrix) {
			this._matrix.concatenate(matrix);
			this._bounds = null;
			this._update();
		},
	
		getElement: function() {
			return this._element;
		},
	
		getPixelRatio: function() {
			return this._pixelRatio;
		},
	
		getResolution: function() {
			return this._pixelRatio * 72;
		},
	
		getViewSize: function() {
			var size = this._viewSize;
			return new LinkedSize(size.width, size.height, this, 'setViewSize');
		},
	
		setViewSize: function() {
			var size = Size.read(arguments),
				delta = size.subtract(this._viewSize);
			if (delta.isZero())
				return;
			this._viewSize.set(size.width, size.height);
			this._setViewSize(size);
			this._bounds = null;
			this.emit('resize', {
				size: size,
				delta: delta
			});
			this._update();
		},
	
		_setViewSize: function(size) {
			var element = this._element;
			element.width = size.width;
			element.height = size.height;
		},
	
		getBounds: function() {
			if (!this._bounds)
				this._bounds = this._matrix.inverted()._transformBounds(
						new Rectangle(new Point(), this._viewSize));
			return this._bounds;
		},
	
		getSize: function() {
			return this.getBounds().getSize();
		},
	
		getCenter: function() {
			return this.getBounds().getCenter();
		},
	
		setCenter: function() {
			var center = Point.read(arguments);
			this.scrollBy(center.subtract(this.getCenter()));
		},
	
		getZoom: function() {
			return this._zoom;
		},
	
		setZoom: function(zoom) {
			this._transform(new Matrix().scale(zoom / this._zoom,
				this.getCenter()));
			this._zoom = zoom;
		},
	
		isVisible: function() {
			return DomElement.isInView(this._element);
		},
	
		scrollBy: function() {
			this._transform(new Matrix().translate(Point.read(arguments).negate()));
		},
	
		play: function() {
			this._animate = true;
			if (!this._requested)
				this._requestFrame();
		},
	
		pause: function() {
			this._animate = false;
		},
	
		draw: function() {
			this.update();
		},
	
		projectToView: function() {
			return this._matrix._transformPoint(Point.read(arguments));
		},
	
		viewToProject: function() {
			return this._matrix._inverseTransform(Point.read(arguments));
		}
	
	}, {
		statics: {
			_views: [],
			_viewsById: {},
			_id: 0,
	
			create: function(project, element) {
				if (typeof element === 'string')
					element = document.getElementById(element);
				return new CanvasView(project, element);
			}
		}
	},
	new function() {
		var tool,
			prevFocus,
			tempFocus,
			dragging = false;
	
		function getView(event) {
			var target = DomEvent.getTarget(event);
			return target.getAttribute && View._viewsById[target.getAttribute('id')];
		}
	
		function viewToProject(view, event) {
			return view.viewToProject(DomEvent.getOffset(event, view._element));
		}
	
		function updateFocus() {
			if (!View._focused || !View._focused.isVisible()) {
				for (var i = 0, l = View._views.length; i < l; i++) {
					var view = View._views[i];
					if (view && view.isVisible()) {
						View._focused = tempFocus = view;
						break;
					}
				}
			}
		}
	
		function handleMouseMove(view, point, event) {
			view._handleEvent('mousemove', point, event);
			var tool = view._scope.tool;
			if (tool) {
				tool._handleEvent(dragging && tool.responds('mousedrag')
						? 'mousedrag' : 'mousemove', point, event);
			}
			view.update();
			return tool;
		}
	
		var navigator = window.navigator,
			mousedown, mousemove, mouseup;
		if (navigator.pointerEnabled || navigator.msPointerEnabled) {
			mousedown = 'pointerdown MSPointerDown';
			mousemove = 'pointermove MSPointerMove';
			mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
		} else {
			mousedown = 'touchstart';
			mousemove = 'touchmove';
			mouseup = 'touchend touchcancel';
			if (!('ontouchstart' in window && navigator.userAgent.match(
					/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
				mousedown += ' mousedown';
				mousemove += ' mousemove';
				mouseup += ' mouseup';
			}
		}
	
		var viewEvents = {
			'selectstart dragstart': function(event) {
				if (dragging)
					event.preventDefault();
			}
		};
	
		var docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML'))
					handleMouseMove(view, viewToProject(view, event), event);
			},
	
			scroll: updateFocus
		};
	
		viewEvents[mousedown] = function(event) {
			var view = View._focused = getView(event),
				point = viewToProject(view, event);
			dragging = true;
			view._handleEvent('mousedown', point, event);
			if (tool = view._scope.tool)
				tool._handleEvent('mousedown', point, event);
			view.update();
		};
	
		docEvents[mousemove] = function(event) {
			var view = View._focused;
			if (!dragging) {
				var target = getView(event);
				if (target) {
					if (view !== target)
						handleMouseMove(view, viewToProject(view, event), event);
					prevFocus = view;
					view = View._focused = tempFocus = target;
				} else if (tempFocus && tempFocus === view) {
					view = View._focused = prevFocus;
					updateFocus();
				}
			}
			if (view) {
				var point = viewToProject(view, event);
				if (dragging || view.getBounds().contains(point))
					tool = handleMouseMove(view, point, event);
			}
		};
	
		docEvents[mouseup] = function(event) {
			var view = View._focused;
			if (!view || !dragging)
				return;
			var point = viewToProject(view, event);
			dragging = false;
			view._handleEvent('mouseup', point, event);
			if (tool)
				tool._handleEvent('mouseup', point, event);
			view.update();
		};
	
		DomEvent.add(document, docEvents);
	
		DomEvent.add(window, {
			load: updateFocus
		});
	
		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};
	
		return {
			_viewEvents: viewEvents,
	
			_handleEvent: function() {},
	
			_installEvent: function(type) {
				var counters = this._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
	
			_uninstallEvent: function(type) {
				var counters = this._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			},
	
			statics: {
				updateFocus: updateFocus
			}
		};
	});
	
	var CanvasView = View.extend({
		_class: 'CanvasView',
	
		initialize: function CanvasView(project, canvas) {
			if (!(canvas instanceof HTMLCanvasElement)) {
				var size = Size.read(arguments, 1);
				if (size.isZero())
					throw new Error(
							'Cannot create CanvasView with the provided argument: '
							+ [].slice.call(arguments, 1));
				canvas = CanvasProvider.getCanvas(size);
			}
			this._context = canvas.getContext('2d');
			this._eventCounters = {};
			this._pixelRatio = 1;
			if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
				var deviceRatio = window.devicePixelRatio || 1,
					backingStoreRatio = DomElement.getPrefixed(this._context,
							'backingStorePixelRatio') || 1;
				this._pixelRatio = deviceRatio / backingStoreRatio;
			}
			View.call(this, project, canvas);
		},
	
		_setViewSize: function(size) {
			var element = this._element,
				pixelRatio = this._pixelRatio,
				width = size.width,
				height = size.height;
			element.width = width * pixelRatio;
			element.height = height * pixelRatio;
			if (pixelRatio !== 1) {
				if (!PaperScope.hasAttribute(element, 'resize')) {
					var style = element.style;
					style.width = width + 'px';
					style.height = height + 'px';
				}
				this._context.scale(pixelRatio, pixelRatio);
			}
		},
	
		getPixelSize: function(size) {
			var browser = paper.browser,
				pixels;
			if (browser && browser.firefox) {
				var parent = this._element.parentNode,
					temp = document.createElement('div');
				temp.style.fontSize = size;
				parent.appendChild(temp);
				pixels = parseFloat(DomElement.getStyles(temp).fontSize);
				parent.removeChild(temp);
			} else {
				var ctx = this._context,
					prevFont = ctx.font;
				ctx.font = size + ' serif';
				pixels = parseFloat(ctx.font);
				ctx.font = prevFont;
			}
			return pixels;
		},
	
		getTextWidth: function(font, lines) {
			var ctx = this._context,
				prevFont = ctx.font,
				width = 0;
			ctx.font = font;
			for (var i = 0, l = lines.length; i < l; i++)
				width = Math.max(width, ctx.measureText(lines[i]).width);
			ctx.font = prevFont;
			return width;
		},
	
		update: function(force) {
			var project = this._project;
			if (!project || !force && !project._needsUpdate)
				return false;
			var ctx = this._context,
				size = this._viewSize;
			ctx.clearRect(0, 0, size.width + 1, size.height + 1);
			project.draw(ctx, this._matrix, this._pixelRatio);
			project._needsUpdate = false;
			return true;
		}
	},
	new function() {
		var downPoint,
			lastPoint,
			overPoint,
			downItem,
			lastItem,
			overItem,
			dragItem,
			dblClick,
			clickTime;
	
		function callEvent(view, type, event, point, target, lastPoint) {
			var item = target,
				mouseEvent;
	
			function call(obj) {
				if (obj.responds(type)) {
					if (!mouseEvent) {
						mouseEvent = new MouseEvent(type, event, point, target,
								lastPoint ? point.subtract(lastPoint) : null);
					}
					if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
						event.preventDefault();
						return true;
					}
				}
			}
	
			while (item) {
				if (call(item))
					return true;
				item = item.getParent();
			}
			if (call(view))
				return true;
			return false;
		}
	
		return {
			_handleEvent: function(type, point, event) {
				if (!this._eventCounters[type])
					return;
				var project = this._project,
					hit = project.hitTest(point, {
						tolerance: 0,
						fill: true,
						stroke: true
					}),
					item = hit && hit.item,
					stopped = false;
				switch (type) {
				case 'mousedown':
					stopped = callEvent(this, type, event, point, item);
					dblClick = lastItem == item && (Date.now() - clickTime < 300);
					downItem = lastItem = item;
					downPoint = lastPoint = overPoint = point;
					dragItem = !stopped && item;
					while (dragItem && !dragItem.responds('mousedrag'))
						dragItem = dragItem._parent;
					break;
				case 'mouseup':
					stopped = callEvent(this, type, event, point, item, downPoint);
					if (dragItem) {
						if (lastPoint && !lastPoint.equals(point))
							callEvent(this, 'mousedrag', event, point, dragItem,
									lastPoint);
						if (item !== dragItem) {
							overPoint = point;
							callEvent(this, 'mousemove', event, point, item,
									overPoint);
						}
					}
					if (!stopped && item && item === downItem) {
						clickTime = Date.now();
						callEvent(this, dblClick && downItem.responds('doubleclick')
								? 'doubleclick' : 'click', event, downPoint, item);
						dblClick = false;
					}
					downItem = dragItem = null;
					break;
				case 'mousemove':
					if (dragItem)
						stopped = callEvent(this, 'mousedrag', event, point,
								dragItem, lastPoint);
					if (!stopped) {
						if (item !== overItem)
							overPoint = point;
						stopped = callEvent(this, type, event, point, item,
								overPoint);
					}
					lastPoint = overPoint = point;
					if (item !== overItem) {
						callEvent(this, 'mouseleave', event, point, overItem);
						overItem = item;
						callEvent(this, 'mouseenter', event, point, item);
					}
					break;
				}
				return stopped;
			}
		};
	});
	
	var Event = Base.extend({
		_class: 'Event',
	
		initialize: function Event(event) {
			this.event = event;
		},
	
		isPrevented: false,
		isStopped: false,
	
		preventDefault: function() {
			this.isPrevented = true;
			this.event.preventDefault();
		},
	
		stopPropagation: function() {
			this.isStopped = true;
			this.event.stopPropagation();
		},
	
		stop: function() {
			this.stopPropagation();
			this.preventDefault();
		},
	
		getModifiers: function() {
			return Key.modifiers;
		}
	});
	
	var KeyEvent = Event.extend({
		_class: 'KeyEvent',
	
		initialize: function KeyEvent(down, key, character, event) {
			Event.call(this, event);
			this.type = down ? 'keydown' : 'keyup';
			this.key = key;
			this.character = character;
		},
	
		toString: function() {
			return "{ type: '" + this.type
					+ "', key: '" + this.key
					+ "', character: '" + this.character
					+ "', modifiers: " + this.getModifiers()
					+ " }";
		}
	});
	
	var Key = new function() {
	
		var specialKeys = {
			8: 'backspace',
			9: 'tab',
			13: 'enter',
			16: 'shift',
			17: 'control',
			18: 'option',
			19: 'pause',
			20: 'caps-lock',
			27: 'escape',
			32: 'space',
			35: 'end',
			36: 'home',
			37: 'left',
			38: 'up',
			39: 'right',
			40: 'down',
			46: 'delete',
			91: 'command',
			93: 'command',
			224: 'command'
		},
	
		specialChars = {
			9: true,
			13: true,
			32: true
		},
	
		modifiers = new Base({
			shift: false,
			control: false,
			option: false,
			command: false,
			capsLock: false,
			space: false
		}),
	
		charCodeMap = {},
		keyMap = {},
		commandFixMap,
		downCode;
	
		function handleKey(down, keyCode, charCode, event) {
			var character = charCode ? String.fromCharCode(charCode) : '',
				specialKey = specialKeys[keyCode],
				key = specialKey || character.toLowerCase(),
				type = down ? 'keydown' : 'keyup',
				view = View._focused,
				scope = view && view.isVisible() && view._scope,
				tool = scope && scope.tool,
				name;
			keyMap[key] = down;
			if (down) {
				charCodeMap[keyCode] = charCode;
			} else {
				delete charCodeMap[keyCode];
			}
			if (specialKey && (name = Base.camelize(specialKey)) in modifiers) {
				modifiers[name] = down;
				var browser = paper.browser;
				if (name === 'command' && browser && browser.mac) {
					if (down) {
						commandFixMap = {};
					} else {
						for (var code in commandFixMap) {
							if (code in charCodeMap)
								handleKey(false, code, commandFixMap[code], event);
						}
						commandFixMap = null;
					}
				}
			} else if (down && commandFixMap) {
				commandFixMap[keyCode] = charCode;
			}
			if (tool && tool.responds(type)) {
				paper = scope;
				tool.emit(type, new KeyEvent(down, key, character, event));
				if (view)
					view.update();
			}
		}
	
		DomEvent.add(document, {
			keydown: function(event) {
				var code = event.which || event.keyCode;
				if (code in specialKeys || modifiers.command) {
					handleKey(true, code,
							code in specialChars || modifiers.command ? code : 0,
							event);
				} else {
					downCode = code;
				}
			},
	
			keypress: function(event) {
				if (downCode != null) {
					handleKey(true, downCode, event.which || event.keyCode, event);
					downCode = null;
				}
			},
	
			keyup: function(event) {
				var code = event.which || event.keyCode;
				if (code in charCodeMap)
					handleKey(false, code, charCodeMap[code], event);
			}
		});
	
		DomEvent.add(window, {
			blur: function(event) {
				for (var code in charCodeMap)
					handleKey(false, code, charCodeMap[code], event);
			}
		});
	
		return {
			modifiers: modifiers,
	
			isDown: function(key) {
				return !!keyMap[key];
			}
		};
	};
	
	var MouseEvent = Event.extend({
		_class: 'MouseEvent',
	
		initialize: function MouseEvent(type, event, point, target, delta) {
			Event.call(this, event);
			this.type = type;
			this.point = point;
			this.target = target;
			this.delta = delta;
		},
	
		toString: function() {
			return "{ type: '" + this.type
					+ "', point: " + this.point
					+ ', target: ' + this.target
					+ (this.delta ? ', delta: ' + this.delta : '')
					+ ', modifiers: ' + this.getModifiers()
					+ ' }';
		}
	});
	
	var ToolEvent = Event.extend({
		_class: 'ToolEvent',
		_item: null,
	
		initialize: function ToolEvent(tool, type, event) {
			this.tool = tool;
			this.type = type;
			this.event = event;
		},
	
		_choosePoint: function(point, toolPoint) {
			return point ? point : toolPoint ? toolPoint.clone() : null;
		},
	
		getPoint: function() {
			return this._choosePoint(this._point, this.tool._point);
		},
	
		setPoint: function(point) {
			this._point = point;
		},
	
		getLastPoint: function() {
			return this._choosePoint(this._lastPoint, this.tool._lastPoint);
		},
	
		setLastPoint: function(lastPoint) {
			this._lastPoint = lastPoint;
		},
	
		getDownPoint: function() {
			return this._choosePoint(this._downPoint, this.tool._downPoint);
		},
	
		setDownPoint: function(downPoint) {
			this._downPoint = downPoint;
		},
	
		getMiddlePoint: function() {
			if (!this._middlePoint && this.tool._lastPoint) {
				return this.tool._point.add(this.tool._lastPoint).divide(2);
			}
			return this._middlePoint;
		},
	
		setMiddlePoint: function(middlePoint) {
			this._middlePoint = middlePoint;
		},
	
		getDelta: function() {
			return !this._delta && this.tool._lastPoint
					? this.tool._point.subtract(this.tool._lastPoint)
					: this._delta;
		},
	
		setDelta: function(delta) {
			this._delta = delta;
		},
	
		getCount: function() {
			return /^mouse(down|up)$/.test(this.type)
					? this.tool._downCount
					: this.tool._count;
		},
	
		setCount: function(count) {
			this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
				= count;
		},
	
		getItem: function() {
			if (!this._item) {
				var result = this.tool._scope.project.hitTest(this.getPoint());
				if (result) {
					var item = result.item,
						parent = item._parent;
					while (/^(Group|CompoundPath)$/.test(parent._class)) {
						item = parent;
						parent = parent._parent;
					}
					this._item = item;
				}
			}
			return this._item;
		},
	
		setItem: function(item) {
			this._item = item;
		},
	
		toString: function() {
			return '{ type: ' + this.type
					+ ', point: ' + this.getPoint()
					+ ', count: ' + this.getCount()
					+ ', modifiers: ' + this.getModifiers()
					+ ' }';
		}
	});
	
	var Tool = PaperScopeItem.extend({
		_class: 'Tool',
		_list: 'tools',
		_reference: 'tool',
		_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
				'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
				'onKeyDown', 'onKeyUp' ],
	
		initialize: function Tool(props) {
			PaperScopeItem.call(this);
			this._firstMove = true;
			this._count = 0;
			this._downCount = 0;
			this._set(props);
		},
	
		getMinDistance: function() {
			return this._minDistance;
		},
	
		setMinDistance: function(minDistance) {
			this._minDistance = minDistance;
			if (minDistance != null && this._maxDistance != null
					&& minDistance > this._maxDistance) {
				this._maxDistance = minDistance;
			}
		},
	
		getMaxDistance: function() {
			return this._maxDistance;
		},
	
		setMaxDistance: function(maxDistance) {
			this._maxDistance = maxDistance;
			if (this._minDistance != null && maxDistance != null
					&& maxDistance < this._minDistance) {
				this._minDistance = maxDistance;
			}
		},
	
		getFixedDistance: function() {
			return this._minDistance == this._maxDistance
				? this._minDistance : null;
		},
	
		setFixedDistance: function(distance) {
			this._minDistance = this._maxDistance = distance;
		},
	
		_updateEvent: function(type, point, minDistance, maxDistance, start,
				needsChange, matchMaxDistance) {
			if (!start) {
				if (minDistance != null || maxDistance != null) {
					var minDist = minDistance != null ? minDistance : 0,
						vector = point.subtract(this._point),
						distance = vector.getLength();
					if (distance < minDist)
						return false;
					if (maxDistance != null && maxDistance != 0) {
						if (distance > maxDistance) {
							point = this._point.add(vector.normalize(maxDistance));
						} else if (matchMaxDistance) {
							return false;
						}
					}
				}
				if (needsChange && point.equals(this._point))
					return false;
			}
			this._lastPoint = start && type == 'mousemove' ? point : this._point;
			this._point = point;
			switch (type) {
			case 'mousedown':
				this._lastPoint = this._downPoint;
				this._downPoint = this._point;
				this._downCount++;
				break;
			case 'mouseup':
				this._lastPoint = this._downPoint;
				break;
			}
			this._count = start ? 0 : this._count + 1;
			return true;
		},
	
		_fireEvent: function(type, event) {
			var sets = paper.project._removeSets;
			if (sets) {
				if (type === 'mouseup')
					sets.mousedrag = null;
				var set = sets[type];
				if (set) {
					for (var id in set) {
						var item = set[id];
						for (var key in sets) {
							var other = sets[key];
							if (other && other != set)
								delete other[item._id];
						}
						item.remove();
					}
					sets[type] = null;
				}
			}
			return this.responds(type)
					&& this.emit(type, new ToolEvent(this, type, event));
		},
	
		_handleEvent: function(type, point, event) {
			paper = this._scope;
			var called = false;
			switch (type) {
			case 'mousedown':
				this._updateEvent(type, point, null, null, true, false, false);
				called = this._fireEvent(type, event);
				break;
			case 'mousedrag':
				var needsChange = false,
					matchMaxDistance = false;
				while (this._updateEvent(type, point, this.minDistance,
						this.maxDistance, false, needsChange, matchMaxDistance)) {
					called = this._fireEvent(type, event) || called;
					needsChange = true;
					matchMaxDistance = true;
				}
				break;
			case 'mouseup':
				if (!point.equals(this._point)
						&& this._updateEvent('mousedrag', point, this.minDistance,
								this.maxDistance, false, false, false)) {
					called = this._fireEvent('mousedrag', event);
				}
				this._updateEvent(type, point, null, this.maxDistance, false,
						false, false);
				called = this._fireEvent(type, event) || called;
				this._updateEvent(type, point, null, null, true, false, false);
				this._firstMove = true;
				break;
			case 'mousemove':
				while (this._updateEvent(type, point, this.minDistance,
						this.maxDistance, this._firstMove, true, false)) {
					called = this._fireEvent(type, event) || called;
					this._firstMove = false;
				}
				break;
			}
			if (called)
				event.preventDefault();
			return called;
		}
	
	});
	
	var Http = {
		request: function(method, url, callback, async) {
			async = (async === undefined) ? true : async;
			var xhr = new (window.ActiveXObject || XMLHttpRequest)(
						'Microsoft.XMLHTTP');
			xhr.open(method.toUpperCase(), url, async);
			if ('overrideMimeType' in xhr)
				xhr.overrideMimeType('text/plain');
			xhr.onreadystatechange = function() {
				if (xhr.readyState === 4) {
					var status = xhr.status;
					if (status === 0 || status === 200) {
						callback.call(xhr, xhr.responseText);
					} else {
						throw new Error('Could not load ' + url + ' (Error '
								+ status + ')');
					}
				}
			};
			return xhr.send(null);
		}
	};
	
	var CanvasProvider = {
		canvases: [],
	
		getCanvas: function(width, height) {
			var canvas,
				clear = true;
			if (typeof width === 'object') {
				height = width.height;
				width = width.width;
			}
			if (this.canvases.length) {
				canvas = this.canvases.pop();
			} else {
				canvas = document.createElement('canvas');
			}
			var ctx = canvas.getContext('2d');
			if (canvas.width === width && canvas.height === height) {
				if (clear)
					ctx.clearRect(0, 0, width + 1, height + 1);
			} else {
				canvas.width = width;
				canvas.height = height;
			}
			ctx.save();
			return canvas;
		},
	
		getContext: function(width, height) {
			return this.getCanvas(width, height).getContext('2d');
		},
	
		release: function(obj) {
			var canvas = obj.canvas ? obj.canvas : obj;
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	};
	
	var BlendMode = new function() {
		var min = Math.min,
			max = Math.max,
			abs = Math.abs,
			sr, sg, sb, sa,
			br, bg, bb, ba,
			dr, dg, db;
	
		function getLum(r, g, b) {
			return 0.2989 * r + 0.587 * g + 0.114 * b;
		}
	
		function setLum(r, g, b, l) {
			var d = l - getLum(r, g, b);
			dr = r + d;
			dg = g + d;
			db = b + d;
			var l = getLum(dr, dg, db),
				mn = min(dr, dg, db),
				mx = max(dr, dg, db);
			if (mn < 0) {
				var lmn = l - mn;
				dr = l + (dr - l) * l / lmn;
				dg = l + (dg - l) * l / lmn;
				db = l + (db - l) * l / lmn;
			}
			if (mx > 255) {
				var ln = 255 - l,
					mxl = mx - l;
				dr = l + (dr - l) * ln / mxl;
				dg = l + (dg - l) * ln / mxl;
				db = l + (db - l) * ln / mxl;
			}
		}
	
		function getSat(r, g, b) {
			return max(r, g, b) - min(r, g, b);
		}
	
		function setSat(r, g, b, s) {
			var col = [r, g, b],
				mx = max(r, g, b),
				mn = min(r, g, b),
				md;
			mn = mn === r ? 0 : mn === g ? 1 : 2;
			mx = mx === r ? 0 : mx === g ? 1 : 2;
			md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
			if (col[mx] > col[mn]) {
				col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
				col[mx] = s;
			} else {
				col[md] = col[mx] = 0;
			}
			col[mn] = 0;
			dr = col[0];
			dg = col[1];
			db = col[2];
		}
	
		var modes = {
			multiply: function() {
				dr = br * sr / 255;
				dg = bg * sg / 255;
				db = bb * sb / 255;
			},
	
			screen: function() {
				dr = br + sr - (br * sr / 255);
				dg = bg + sg - (bg * sg / 255);
				db = bb + sb - (bb * sb / 255);
			},
	
			overlay: function() {
				dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
				dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
				db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
			},
	
			'soft-light': function() {
				var t = sr * br / 255;
				dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
				t = sg * bg / 255;
				dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
				t = sb * bb / 255;
				db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
			},
	
			'hard-light': function() {
				dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
				dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
				db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
			},
	
			'color-dodge': function() {
				dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
				dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
				db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
			},
	
			'color-burn': function() {
				dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
				dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
				db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
			},
	
			darken: function() {
				dr = br < sr ? br : sr;
				dg = bg < sg ? bg : sg;
				db = bb < sb ? bb : sb;
			},
	
			lighten: function() {
				dr = br > sr ? br : sr;
				dg = bg > sg ? bg : sg;
				db = bb > sb ? bb : sb;
			},
	
			difference: function() {
				dr = br - sr;
				if (dr < 0)
					dr = -dr;
				dg = bg - sg;
				if (dg < 0)
					dg = -dg;
				db = bb - sb;
				if (db < 0)
					db = -db;
			},
	
			exclusion: function() {
				dr = br + sr * (255 - br - br) / 255;
				dg = bg + sg * (255 - bg - bg) / 255;
				db = bb + sb * (255 - bb - bb) / 255;
			},
	
			hue: function() {
				setSat(sr, sg, sb, getSat(br, bg, bb));
				setLum(dr, dg, db, getLum(br, bg, bb));
			},
	
			saturation: function() {
				setSat(br, bg, bb, getSat(sr, sg, sb));
				setLum(dr, dg, db, getLum(br, bg, bb));
			},
	
			luminosity: function() {
				setLum(br, bg, bb, getLum(sr, sg, sb));
			},
	
			color: function() {
				setLum(sr, sg, sb, getLum(br, bg, bb));
			},
	
			add: function() {
				dr = min(br + sr, 255);
				dg = min(bg + sg, 255);
				db = min(bb + sb, 255);
			},
	
			subtract: function() {
				dr = max(br - sr, 0);
				dg = max(bg - sg, 0);
				db = max(bb - sb, 0);
			},
	
			average: function() {
				dr = (br + sr) / 2;
				dg = (bg + sg) / 2;
				db = (bb + sb) / 2;
			},
	
			negation: function() {
				dr = 255 - abs(255 - sr - br);
				dg = 255 - abs(255 - sg - bg);
				db = 255 - abs(255 - sb - bb);
			}
		};
	
		var nativeModes = this.nativeModes = Base.each([
			'source-over', 'source-in', 'source-out', 'source-atop',
			'destination-over', 'destination-in', 'destination-out',
			'destination-atop', 'lighter', 'darker', 'copy', 'xor'
		], function(mode) {
			this[mode] = true;
		}, {});
	
		var ctx = CanvasProvider.getContext(1, 1);
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	
		this.process = function(mode, srcContext, dstContext, alpha, offset) {
			var srcCanvas = srcContext.canvas,
				normal = mode === 'normal';
			if (normal || nativeModes[mode]) {
				dstContext.save();
				dstContext.setTransform(1, 0, 0, 1, 0, 0);
				dstContext.globalAlpha = alpha;
				if (!normal)
					dstContext.globalCompositeOperation = mode;
				dstContext.drawImage(srcCanvas, offset.x, offset.y);
				dstContext.restore();
			} else {
				var process = modes[mode];
				if (!process)
					return;
				var dstData = dstContext.getImageData(offset.x, offset.y,
						srcCanvas.width, srcCanvas.height),
					dst = dstData.data,
					src = srcContext.getImageData(0, 0,
						srcCanvas.width, srcCanvas.height).data;
				for (var i = 0, l = dst.length; i < l; i += 4) {
					sr = src[i];
					br = dst[i];
					sg = src[i + 1];
					bg = dst[i + 1];
					sb = src[i + 2];
					bb = dst[i + 2];
					sa = src[i + 3];
					ba = dst[i + 3];
					process();
					var a1 = sa * alpha / 255,
						a2 = 1 - a1;
					dst[i] = a1 * dr + a2 * br;
					dst[i + 1] = a1 * dg + a2 * bg;
					dst[i + 2] = a1 * db + a2 * bb;
					dst[i + 3] = sa * alpha + a2 * ba;
				}
				dstContext.putImageData(dstData, offset.x, offset.y);
			}
		};
	};
	
	var SVGStyles = Base.each({
		fillColor: ['fill', 'color'],
		strokeColor: ['stroke', 'color'],
		strokeWidth: ['stroke-width', 'number'],
		strokeCap: ['stroke-linecap', 'string'],
		strokeJoin: ['stroke-linejoin', 'string'],
		strokeScaling: ['vector-effect', 'lookup', {
			true: 'none',
			false: 'non-scaling-stroke'
		}, function(item, value) {
			return !value
					&& (item instanceof PathItem
						|| item instanceof Shape
						|| item instanceof TextItem);
		}],
		miterLimit: ['stroke-miterlimit', 'number'],
		dashArray: ['stroke-dasharray', 'array'],
		dashOffset: ['stroke-dashoffset', 'number'],
		fontFamily: ['font-family', 'string'],
		fontWeight: ['font-weight', 'string'],
		fontSize: ['font-size', 'number'],
		justification: ['text-anchor', 'lookup', {
			left: 'start',
			center: 'middle',
			right: 'end'
		}],
		opacity: ['opacity', 'number'],
		blendMode: ['mix-blend-mode', 'string']
	}, function(entry, key) {
		var part = Base.capitalize(key),
			lookup = entry[2];
		this[key] = {
			type: entry[1],
			property: key,
			attribute: entry[0],
			toSVG: lookup,
			fromSVG: lookup && Base.each(lookup, function(value, name) {
				this[value] = name;
			}, {}),
			exportFilter: entry[3],
			get: 'get' + part,
			set: 'set' + part
		};
	}, {});
	
	var SVGNamespaces = {
		href: 'http://www.w3.org/1999/xlink',
		xlink: 'http://www.w3.org/2000/xmlns'
	};
	
	new function() {
		var formatter;
	
		function setAttributes(node, attrs) {
			for (var key in attrs) {
				var val = attrs[key],
					namespace = SVGNamespaces[key];
				if (typeof val === 'number')
					val = formatter.number(val);
				if (namespace) {
					node.setAttributeNS(namespace, key, val);
				} else {
					node.setAttribute(key, val);
				}
			}
			return node;
		}
	
		function createElement(tag, attrs) {
			return setAttributes(
				document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
		}
	
		function getTransform(matrix, coordinates, center) {
			var attrs = new Base(),
				trans = matrix.getTranslation();
			if (coordinates) {
				matrix = matrix.shiftless();
				var point = matrix._inverseTransform(trans);
				attrs[center ? 'cx' : 'x'] = point.x;
				attrs[center ? 'cy' : 'y'] = point.y;
				trans = null;
			}
			if (!matrix.isIdentity()) {
				var decomposed = matrix.decompose();
				if (decomposed && !decomposed.shearing) {
					var parts = [],
						angle = decomposed.rotation,
						scale = decomposed.scaling;
					if (trans && !trans.isZero())
						parts.push('translate(' + formatter.point(trans) + ')');
					if (!Numerical.isZero(scale.x - 1)
							|| !Numerical.isZero(scale.y - 1))
						parts.push('scale(' + formatter.point(scale) +')');
					if (angle)
						parts.push('rotate(' + formatter.number(angle) + ')');
					attrs.transform = parts.join(' ');
				} else {
					attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
				}
			}
			return attrs;
		}
	
		function exportGroup(item, options) {
			var attrs = getTransform(item._matrix),
				children = item._children;
			var node = createElement('g', attrs);
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i];
				var childNode = exportSVG(child, options);
				if (childNode) {
					if (child.isClipMask()) {
						var clip = createElement('clipPath');
						clip.appendChild(childNode);
						setDefinition(child, clip, 'clip');
						setAttributes(node, {
							'clip-path': 'url(#' + clip.id + ')'
						});
					} else {
						node.appendChild(childNode);
					}
				}
			}
			return node;
		}
	
		function exportRaster(item, options) {
			var attrs = getTransform(item._matrix, true),
				size = item.getSize(),
				image = item.getImage();
			attrs.x -= size.width / 2;
			attrs.y -= size.height / 2;
			attrs.width = size.width;
			attrs.height = size.height;
			attrs.href = options.embedImages === false && image && image.src
					|| item.toDataURL();
			return createElement('image', attrs);
		}
	
		function exportPath(item, options) {
			var matchShapes = options.matchShapes;
			if (matchShapes) {
				var shape = item.toShape(false);
				if (shape)
					return exportShape(shape, options);
			}
			var segments = item._segments,
				type,
				attrs = getTransform(item._matrix);
			if (segments.length === 0)
				return null;
			if (matchShapes && !item.hasHandles()) {
				if (segments.length >= 3) {
					type = item._closed ? 'polygon' : 'polyline';
					var parts = [];
					for(var i = 0, l = segments.length; i < l; i++)
						parts.push(formatter.point(segments[i]._point));
					attrs.points = parts.join(' ');
				} else {
					type = 'line';
					var first = segments[0]._point,
						last = segments[segments.length - 1]._point;
					attrs.set({
						x1: first.x,
						y1: first.y,
						x2: last.x,
						y2: last.y
					});
				}
			} else {
				type = 'path';
				attrs.d = item.getPathData(null, options.precision);
			}
			return createElement(type, attrs);
		}
	
		function exportShape(item) {
			var type = item._type,
				radius = item._radius,
				attrs = getTransform(item._matrix, true, type !== 'rectangle');
			if (type === 'rectangle') {
				type = 'rect';
				var size = item._size,
					width = size.width,
					height = size.height;
				attrs.x -= width / 2;
				attrs.y -= height / 2;
				attrs.width = width;
				attrs.height = height;
				if (radius.isZero())
					radius = null;
			}
			if (radius) {
				if (type === 'circle') {
					attrs.r = radius;
				} else {
					attrs.rx = radius.width;
					attrs.ry = radius.height;
				}
			}
			return createElement(type, attrs);
		}
	
		function exportCompoundPath(item, options) {
			var attrs = getTransform(item._matrix);
			var data = item.getPathData(null, options.precision);
			if (data)
				attrs.d = data;
			return createElement('path', attrs);
		}
	
		function exportPlacedSymbol(item, options) {
			var attrs = getTransform(item._matrix, true),
				symbol = item.getSymbol(),
				symbolNode = getDefinition(symbol, 'symbol'),
				definition = symbol.getDefinition(),
				bounds = definition.getBounds();
			if (!symbolNode) {
				symbolNode = createElement('symbol', {
					viewBox: formatter.rectangle(bounds)
				});
				symbolNode.appendChild(exportSVG(definition, options));
				setDefinition(symbol, symbolNode, 'symbol');
			}
			attrs.href = '#' + symbolNode.id;
			attrs.x += bounds.x;
			attrs.y += bounds.y;
			attrs.width = formatter.number(bounds.width);
			attrs.height = formatter.number(bounds.height);
			attrs.overflow = 'visible';
			return createElement('use', attrs);
		}
	
		function exportGradient(color) {
			var gradientNode = getDefinition(color, 'color');
			if (!gradientNode) {
				var gradient = color.getGradient(),
					radial = gradient._radial,
					origin = color.getOrigin().transform(),
					destination = color.getDestination().transform(),
					attrs;
				if (radial) {
					attrs = {
						cx: origin.x,
						cy: origin.y,
						r: origin.getDistance(destination)
					};
					var highlight = color.getHighlight();
					if (highlight) {
						highlight = highlight.transform();
						attrs.fx = highlight.x;
						attrs.fy = highlight.y;
					}
				} else {
					attrs = {
						x1: origin.x,
						y1: origin.y,
						x2: destination.x,
						y2: destination.y
					};
				}
				attrs.gradientUnits = 'userSpaceOnUse';
				gradientNode = createElement(
						(radial ? 'radial' : 'linear') + 'Gradient', attrs);
				var stops = gradient._stops;
				for (var i = 0, l = stops.length; i < l; i++) {
					var stop = stops[i],
						stopColor = stop._color,
						alpha = stopColor.getAlpha();
					attrs = {
						offset: stop._rampPoint,
						'stop-color': stopColor.toCSS(true)
					};
					if (alpha < 1)
						attrs['stop-opacity'] = alpha;
					gradientNode.appendChild(createElement('stop', attrs));
				}
				setDefinition(color, gradientNode, 'color');
			}
			return 'url(#' + gradientNode.id + ')';
		}
	
		function exportText(item) {
			var node = createElement('text', getTransform(item._matrix, true));
			node.textContent = item._content;
			return node;
		}
	
		var exporters = {
			Group: exportGroup,
			Layer: exportGroup,
			Raster: exportRaster,
			Path: exportPath,
			Shape: exportShape,
			CompoundPath: exportCompoundPath,
			PlacedSymbol: exportPlacedSymbol,
			PointText: exportText
		};
	
		function applyStyle(item, node, isRoot) {
			var attrs = {},
				parent = !isRoot && item.getParent();
	
			if (item._name != null)
				attrs.id = item._name;
	
			Base.each(SVGStyles, function(entry) {
				var get = entry.get,
					type = entry.type,
					value = item[get]();
				if (entry.exportFilter
						? entry.exportFilter(item, value)
						: !parent || !Base.equals(parent[get](), value)) {
					if (type === 'color' && value != null) {
						var alpha = value.getAlpha();
						if (alpha < 1)
							attrs[entry.attribute + '-opacity'] = alpha;
					}
					attrs[entry.attribute] = value == null
						? 'none'
						: type === 'number'
							? formatter.number(value)
							: type === 'color'
								? value.gradient
									? exportGradient(value, item)
									: value.toCSS(true)
								: type === 'array'
									? value.join(',')
									: type === 'lookup'
										? entry.toSVG[value]
										: value;
				}
			});
	
			if (attrs.opacity === 1)
				delete attrs.opacity;
	
			if (!item._visible)
				attrs.visibility = 'hidden';
	
			return setAttributes(node, attrs);
		}
	
		var definitions;
		function getDefinition(item, type) {
			if (!definitions)
				definitions = { ids: {}, svgs: {} };
			return item && definitions.svgs[type + '-' + item._id];
		}
	
		function setDefinition(item, node, type) {
			if (!definitions)
				getDefinition();
			var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
			node.id = type + '-' + id;
			definitions.svgs[type + '-' + item._id] = node;
		}
	
		function exportDefinitions(node, options) {
			var svg = node,
				defs = null;
			if (definitions) {
				svg = node.nodeName.toLowerCase() === 'svg' && node;
				for (var i in definitions.svgs) {
					if (!defs) {
						if (!svg) {
							svg = createElement('svg');
							svg.appendChild(node);
						}
						defs = svg.insertBefore(createElement('defs'),
								svg.firstChild);
					}
					defs.appendChild(definitions.svgs[i]);
				}
				definitions = null;
			}
			return options.asString
					? new XMLSerializer().serializeToString(svg)
					: svg;
		}
	
		function exportSVG(item, options, isRoot) {
			var exporter = exporters[item._class],
				node = exporter && exporter(item, options);
			if (node) {
				var onExport = options.onExport;
				if (onExport)
					node = onExport(item, node, options) || node;
				var data = JSON.stringify(item._data);
				if (data && data !== '{}' && data !== 'null')
					node.setAttribute('data-paper-data', data);
			}
			return node && applyStyle(item, node, isRoot);
		}
	
		function setOptions(options) {
			if (!options)
				options = {};
			formatter = new Formatter(options.precision);
			return options;
		}
	
		Item.inject({
			exportSVG: function(options) {
				options = setOptions(options);
				return exportDefinitions(exportSVG(this, options, true), options);
			}
		});
	
		Project.inject({
			exportSVG: function(options) {
				options = setOptions(options);
				var layers = this.layers,
					view = this.getView(),
					size = view.getViewSize(),
					node = createElement('svg', {
						x: 0,
						y: 0,
						width: size.width,
						height: size.height,
						version: '1.1',
						xmlns: 'http://www.w3.org/2000/svg',
						'xmlns:xlink': 'http://www.w3.org/1999/xlink'
					}),
					parent = node,
					matrix = view._matrix;
				if (!matrix.isIdentity())
					parent = node.appendChild(
							createElement('g', getTransform(matrix)));
				for (var i = 0, l = layers.length; i < l; i++)
					parent.appendChild(exportSVG(layers[i], options, true));
				return exportDefinitions(node, options);
			}
		});
	};
	
	new function() {
	
		function getValue(node, name, isString, allowNull) {
			var namespace = SVGNamespaces[name],
				value = namespace
					? node.getAttributeNS(namespace, name)
					: node.getAttribute(name);
			if (value === 'null')
				value = null;
			return value == null
					? allowNull
						? null
						: isString
							? ''
							: 0
					: isString
						? value
						: parseFloat(value);
		}
	
		function getPoint(node, x, y, allowNull) {
			x = getValue(node, x, false, allowNull);
			y = getValue(node, y, false, allowNull);
			return allowNull && (x == null || y == null) ? null
					: new Point(x, y);
		}
	
		function getSize(node, w, h, allowNull) {
			w = getValue(node, w, false, allowNull);
			h = getValue(node, h, false, allowNull);
			return allowNull && (w == null || h == null) ? null
					: new Size(w, h);
		}
	
		function convertValue(value, type, lookup) {
			return value === 'none'
					? null
					: type === 'number'
						? parseFloat(value)
						: type === 'array'
							? value ? value.split(/[\s,]+/g).map(parseFloat) : []
							: type === 'color'
								? getDefinition(value) || value
								: type === 'lookup'
									? lookup[value]
									: value;
		}
	
		function importGroup(node, type, options, isRoot) {
			var nodes = node.childNodes,
				isClip = type === 'clippath',
				item = new Group(),
				project = item._project,
				currentStyle = project._currentStyle,
				children = [];
			if (!isClip) {
				item = applyAttributes(item, node, isRoot);
				project._currentStyle = item._style.clone();
			}
			if (isRoot) {
				var defs = node.querySelectorAll('defs');
				for (var i = 0, l = defs.length; i < l; i++) {
					importSVG(defs[i], options, false);
				}
			}
			for (var i = 0, l = nodes.length; i < l; i++) {
				var childNode = nodes[i],
					child;
				if (childNode.nodeType === 1
						&& childNode.nodeName.toLowerCase() !== 'defs'
						&& (child = importSVG(childNode, options, false))
						&& !(child instanceof Symbol))
					children.push(child);
			}
			item.addChildren(children);
			if (isClip)
				item = applyAttributes(item.reduce(), node, isRoot);
			project._currentStyle = currentStyle;
			if (isClip || type === 'defs') {
				item.remove();
				item = null;
			}
			return item;
		}
	
		function importPoly(node, type) {
			var coords = node.getAttribute('points').match(
						/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
				points = [];
			for (var i = 0, l = coords.length; i < l; i += 2)
				points.push(new Point(
						parseFloat(coords[i]),
						parseFloat(coords[i + 1])));
			var path = new Path(points);
			if (type === 'polygon')
				path.closePath();
			return path;
		}
	
		function importPath(node) {
			var data = node.getAttribute('d'),
				param = { pathData: data };
			return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
					? new CompoundPath(param)
					: new Path(param);
		}
	
		function importGradient(node, type) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				isRadial = type === 'radialgradient',
				gradient;
			if (id) {
				gradient = definitions[id].getGradient();
			} else {
				var nodes = node.childNodes,
					stops = [];
				for (var i = 0, l = nodes.length; i < l; i++) {
					var child = nodes[i];
					if (child.nodeType === 1)
						stops.push(applyAttributes(new GradientStop(), child));
				}
				gradient = new Gradient(stops, isRadial);
			}
			var origin, destination, highlight;
			if (isRadial) {
				origin = getPoint(node, 'cx', 'cy');
				destination = origin.add(getValue(node, 'r'), 0);
				highlight = getPoint(node, 'fx', 'fy', true);
			} else {
				origin = getPoint(node, 'x1', 'y1');
				destination = getPoint(node, 'x2', 'y2');
			}
			applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
			return null;
		}
	
		var importers = {
			'#document': function (node, type, options, isRoot) {
				var nodes = node.childNodes;
				for (var i = 0, l = nodes.length; i < l; i++) {
					var child = nodes[i];
					if (child.nodeType === 1) {
						var next = child.nextSibling;
						document.body.appendChild(child);
						var item = importSVG(child, options, isRoot);
						if (next) {
							node.insertBefore(child, next);
						} else {
							node.appendChild(child);
						}
						return item;
					}
				}
			},
			g: importGroup,
			svg: importGroup,
			clippath: importGroup,
			polygon: importPoly,
			polyline: importPoly,
			path: importPath,
			lineargradient: importGradient,
			radialgradient: importGradient,
	
			image: function (node) {
				var raster = new Raster(getValue(node, 'href', true));
				raster.on('load', function() {
					var size = getSize(node, 'width', 'height');
					this.setSize(size);
					var center = this._matrix._transformPoint(
							getPoint(node, 'x', 'y').add(size.divide(2)));
					this.translate(center);
				});
				return raster;
			},
	
			symbol: function(node, type, options, isRoot) {
				return new Symbol(importGroup(node, type, options, isRoot), true);
			},
	
			defs: importGroup,
	
			use: function(node) {
				var id = (getValue(node, 'href', true) || '').substring(1),
					definition = definitions[id],
					point = getPoint(node, 'x', 'y');
				return definition
						? definition instanceof Symbol
							? definition.place(point)
							: definition.clone().translate(point)
						: null;
			},
	
			circle: function(node) {
				return new Shape.Circle(getPoint(node, 'cx', 'cy'),
						getValue(node, 'r'));
			},
	
			ellipse: function(node) {
				return new Shape.Ellipse({
					center: getPoint(node, 'cx', 'cy'),
					radius: getSize(node, 'rx', 'ry')
				});
			},
	
			rect: function(node) {
				var point = getPoint(node, 'x', 'y'),
					size = getSize(node, 'width', 'height'),
					radius = getSize(node, 'rx', 'ry');
				return new Shape.Rectangle(new Rectangle(point, size), radius);
			},
	
			line: function(node) {
				return new Path.Line(getPoint(node, 'x1', 'y1'),
						getPoint(node, 'x2', 'y2'));
			},
	
			text: function(node) {
				var text = new PointText(getPoint(node, 'x', 'y')
						.add(getPoint(node, 'dx', 'dy')));
				text.setContent(node.textContent.trim() || '');
				return text;
			}
		};
	
		function applyTransform(item, value, name, node) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.concatenate(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1], v[2]);
					break;
				case 'translate':
					matrix.translate(v[0], v[1]);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	
		function applyOpacity(item, value, name) {
			var color = item[name === 'fill-opacity' ? 'getFillColor'
					: 'getStrokeColor']();
			if (color)
				color.setAlpha(parseFloat(value));
		}
	
		var attributes = Base.set(Base.each(SVGStyles, function(entry) {
			this[entry.attribute] = function(item, value) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color' && item instanceof Shape) {
					var color = item[entry.get]();
					if (color)
						color.transform(new Matrix().translate(
								item.getPosition(true).negate()));
				}
			};
		}, {}), {
			id: function(item, value) {
				definitions[value] = item;
				if (item.setName)
					item.setName(value);
			},
	
			'clip-path': function(item, value) {
				var clip = getDefinition(value);
				if (clip) {
					clip = clip.clone();
					clip.setClipMask(true);
					if (item instanceof Group) {
						item.insertChild(0, clip);
					} else {
						return new Group(clip, item);
					}
				}
			},
	
			gradientTransform: applyTransform,
			transform: applyTransform,
	
			'fill-opacity': applyOpacity,
			'stroke-opacity': applyOpacity,
	
			visibility: function(item, value) {
				item.setVisible(value === 'visible');
			},
	
			display: function(item, value) {
				item.setVisible(value !== null);
			},
	
			'stop-color': function(item, value) {
				if (item.setColor)
					item.setColor(value);
			},
	
			'stop-opacity': function(item, value) {
				if (item._color)
					item._color.setAlpha(parseFloat(value));
			},
	
			offset: function(item, value) {
				var percentage = value.match(/(.*)%$/);
				item.setRampPoint(percentage
						? percentage[1] / 100
						: parseFloat(value));
			},
	
			viewBox: function(item, value, name, node, styles) {
				var rect = new Rectangle(convertValue(value, 'array')),
					size = getSize(node, 'width', 'height', true);
				if (item instanceof Group) {
					var scale = size ? rect.getSize().divide(size) : 1,
						matrix = new Matrix().translate(rect.getPoint()).scale(scale);
					item.transform(matrix.inverted());
				} else if (item instanceof Symbol) {
					if (size)
						rect.setSize(size);
					var clip = getAttribute(node, 'overflow', styles) != 'visible',
						group = item._definition;
					if (clip && !rect.contains(group.getBounds())) {
						clip = new Shape.Rectangle(rect).transform(group._matrix);
						clip.setClipMask(true);
						group.addChild(clip);
					}
				}
			}
		});
	
		function getAttribute(node, name, styles) {
			var attr = node.attributes[name],
				value = attr && attr.value;
			if (!value) {
				var style = Base.camelize(name);
				value = node.style[style];
				if (!value && styles.node[style] !== styles.parent[style])
					value = styles.node[style];
			}
			return !value
					? undefined
					: value === 'none'
						? null
						: value;
		}
	
		function applyAttributes(item, node, isRoot) {
			var styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
			};
			Base.each(attributes, function(apply, name) {
				var value = getAttribute(node, name, styles);
				if (value !== undefined)
					item = Base.pick(apply(item, value, name, node, styles), item);
			});
			return item;
		}
	
		var definitions = {};
		function getDefinition(value) {
			var match = value && value.match(/\((?:#|)([^)']+)/);
			return match && definitions[match[1]];
		}
	
		function importSVG(source, options, isRoot) {
			if (!source)
				return null;
			if (!options) {
				options = {};
			} else if (typeof options === 'function') {
				options = { onLoad: options };
			}
	
			var node = source,
				scope = paper;
	
			function onLoadCallback(svg) {
				paper = scope;
				var item = importSVG(svg, options, isRoot),
					onLoad = options.onLoad,
					view = scope.project && scope.getView();
				if (onLoad)
					onLoad.call(this, item);
				view.update();
			}
	
			if (isRoot) {
				if (typeof source === 'string' && !/^.*</.test(source)) {
					node = document.getElementById(source);
					if (node) {
						source = null;
					} else {
						return Http.request('get', source, onLoadCallback);
					}
				} else if (typeof File !== 'undefined' && source instanceof File) {
					var reader = new FileReader();
					reader.onload = function() {
						onLoadCallback(reader.result);
					};
					return reader.readAsText(source);
				}
			}
	
			if (typeof source === 'string')
				node = new DOMParser().parseFromString(source, 'image/svg+xml');
			if (!node.nodeName)
				throw new Error('Unsupported SVG source: ' + source);
			var type = node.nodeName.toLowerCase(),
				importer = importers[type],
				item,
				data = node.getAttribute && node.getAttribute('data-paper-data'),
				settings = scope.settings,
				applyMatrix = settings.applyMatrix;
			settings.applyMatrix = false;
			item = importer && importer(node, type, options, isRoot) || null;
			settings.applyMatrix = applyMatrix;
			if (item) {
				if (type !== '#document' && !(item instanceof Group))
					item = applyAttributes(item, node, isRoot);
				var onImport = options.onImport;
				if (onImport)
					item = onImport(node, item, options) || item;
				if (options.expandShapes && item instanceof Shape) {
					item.remove();
					item = item.toPath();
				}
				if (data)
					item._data = JSON.parse(data);
			}
			if (isRoot) {
				definitions = {};
				if (item && Base.pick(options.applyMatrix, applyMatrix))
					item.matrix.apply(true, true);
			}
			return item;
		}
	
		Item.inject({
			importSVG: function(node, options) {
				return this.addChild(importSVG(node, options, true));
			}
		});
	
		Project.inject({
			importSVG: function(node, options) {
				this.activate();
				return importSVG(node, options, true);
			}
		});
	};
	
	Base.exports.PaperScript = (function() {
		var exports, define,
			scope = this;
	!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=pr&&t(a,"Unterminated regular expression");var o=dr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=pr&&t(yr,"Unterminated string constant");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Tr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Tr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,"Program")}function J(){(wr===wt||wr===Et&&"/="==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,"VariableDeclaration"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Vr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),G(r),M(),j(r,"VariableDeclaration");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,"WhileStatement");case nt:return Tr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case pt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,d=K();if(e===Fr&&"Identifier"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,"Label '"+f+"' is already declared");var p=wr.isLoop?"loop":wr===Yr?"switch":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,"LabeledStatement")}return r.expression=d,M(),j(r,"ExpressionStatement")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,"MemberExpression"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,"ArrayExpression");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Tr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,"Identifier")}e.version="0.4.0";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:"num"},jr={type:"regexp"},Dr={type:"string"},Fr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},dt={type:"]"},pt={type:"{",beforeExpr:!0},ht={type:"}"},mt={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes["_"+Ft]=lt[Ft];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});
	
		var binaryOperators = {
			'+': '__add',
			'-': '__subtract',
			'*': '__multiply',
			'/': '__divide',
			'%': '__modulo',
			'==': 'equals',
			'!=': 'equals'
		};
	
		var unaryOperators = {
			'-': '__negate',
			'+': null
		};
	
		var fields = Base.each(
			['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
			function(name) {
				this['__' + name] = '#' + name;
			},
			{}
		);
		Point.inject(fields);
		Size.inject(fields);
		Color.inject(fields);
	
		function __$__(left, operator, right) {
			var handler = binaryOperators[operator];
			if (left && left[handler]) {
				var res = left[handler](right);
				return operator === '!=' ? !res : res;
			}
			switch (operator) {
			case '+': return left + right;
			case '-': return left - right;
			case '*': return left * right;
			case '/': return left / right;
			case '%': return left % right;
			case '==': return left == right;
			case '!=': return left != right;
			}
		}
	
		function $__(operator, value) {
			var handler = unaryOperators[operator];
			if (handler && value && value[handler])
				return value[handler]();
			switch (operator) {
			case '+': return +value;
			case '-': return -value;
			}
		}
	
		function parse(code, options) {
			return scope.acorn.parse(code, options);
		}
	
		function compile(code, url, options) {
			if (!code)
				return '';
			options = options || {};
			url = url || '';
	
			var insertions = [];
	
			function getOffset(offset) {
				for (var i = 0, l = insertions.length; i < l; i++) {
					var insertion = insertions[i];
					if (insertion[0] >= offset)
						break;
					offset += insertion[1];
				}
				return offset;
			}
	
			function getCode(node) {
				return code.substring(getOffset(node.range[0]),
						getOffset(node.range[1]));
			}
	
			function getBetween(left, right) {
				return code.substring(getOffset(left.range[1]),
						getOffset(right.range[0]));
			}
	
			function replaceCode(node, str) {
				var start = getOffset(node.range[0]),
					end = getOffset(node.range[1]),
					insert = 0;
				for (var i = insertions.length - 1; i >= 0; i--) {
					if (start > insertions[i][0]) {
						insert = i + 1;
						break;
					}
				}
				insertions.splice(insert, 0, [start, str.length - end + start]);
				code = code.substring(0, start) + str + code.substring(end);
			}
	
			function walkAST(node, parent) {
				if (!node)
					return;
				for (var key in node) {
					if (key === 'range' || key === 'loc')
						continue;
					var value = node[key];
					if (Array.isArray(value)) {
						for (var i = 0, l = value.length; i < l; i++)
							walkAST(value[i], node);
					} else if (value && typeof value === 'object') {
						walkAST(value, node);
					}
				}
				switch (node.type) {
				case 'UnaryExpression':
					if (node.operator in unaryOperators
							&& node.argument.type !== 'Literal') {
						var arg = getCode(node.argument);
						replaceCode(node, '$__("' + node.operator + '", '
								+ arg + ')');
					}
					break;
				case 'BinaryExpression':
					if (node.operator in binaryOperators
							&& node.left.type !== 'Literal') {
						var left = getCode(node.left),
							right = getCode(node.right),
							between = getBetween(node.left, node.right),
							operator = node.operator;
						replaceCode(node, '__$__(' + left + ','
								+ between.replace(new RegExp('\\' + operator),
									'"' + operator + '"')
								+ ', ' + right + ')');
					}
					break;
				case 'UpdateExpression':
				case 'AssignmentExpression':
					var parentType = parent && parent.type;
					if (!(
							parentType === 'ForStatement'
							|| parentType === 'BinaryExpression'
								&& /^[=!<>]/.test(parent.operator)
							|| parentType === 'MemberExpression' && parent.computed
					)) {
						if (node.type === 'UpdateExpression') {
							var arg = getCode(node.argument),
								exp = '__$__(' + arg + ', "' + node.operator[0]
										+ '", 1)',
								str = arg + ' = ' + exp;
							if (!node.prefix
									&& (parentType === 'AssignmentExpression'
										|| parentType === 'VariableDeclarator')) {
								if (getCode(parent.left || parent.id) === arg)
									str = exp;
								str = arg + '; ' + str;
							}
							replaceCode(node, str);
						} else {
							if (/^.=$/.test(node.operator)
									&& node.left.type !== 'Literal') {
								var left = getCode(node.left),
									right = getCode(node.right);
								replaceCode(node, left + ' = __$__(' + left + ', "'
										+ node.operator[0] + '", ' + right + ')');
							}
						}
					}
					break;
				}
			}
			var sourceMap = null,
				browser = paper.browser,
				version = browser.versionNumber,
				lineBreaks = /\r\n|\n|\r/mg;
			if (browser.chrome && version >= 30
					|| browser.webkit && version >= 537.76
					|| browser.firefox && version >= 23) {
				var offset = 0;
				if (window.location.href.indexOf(url) === 0) {
					var html = document.getElementsByTagName('html')[0].innerHTML;
					offset = html.substr(0, html.indexOf(code) + 1).match(
							lineBreaks).length + 1;
				}
				var mappings = ['AAAA'];
				mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
				sourceMap = {
					version: 3,
					file: url,
					names:[],
					mappings: mappings.join(';AACA'),
					sourceRoot: '',
					sources: [url]
				};
				var source = options.source || !url && code;
				if (source)
					sourceMap.sourcesContent = [source];
			}
			walkAST(parse(code, { ranges: true }));
			if (sourceMap) {
				code = new Array(offset + 1).join('\n') + code
						+ "\n//# sourceMappingURL=data:application/json;base64,"
						+ (btoa(unescape(encodeURIComponent(
							JSON.stringify(sourceMap)))))
						+ "\n//# sourceURL=" + (url || 'paperscript');
			}
			return code;
		}
	
		function execute(code, scope, url, options) {
			paper = scope;
			var view = scope.getView(),
				tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
						? new Tool()
						: null,
				toolHandlers = tool ? tool._events : [],
				handlers = ['onFrame', 'onResize'].concat(toolHandlers),
				params = [],
				args = [],
				func;
			code = compile(code, url, options);
			function expose(scope, hidden) {
				for (var key in scope) {
					if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
							+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
						params.push(key);
						args.push(scope[key]);
					}
				}
			}
			expose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },
					true);
			expose(scope);
			handlers = Base.each(handlers, function(key) {
				if (new RegExp('\\s+' + key + '\\b').test(code)) {
					params.push(key);
					this.push(key + ': ' + key);
				}
			}, []).join(', ');
			if (handlers)
				code += '\nreturn { ' + handlers + ' };';
			var browser = paper.browser;
			if (browser.chrome || browser.firefox) {
				var script = document.createElement('script'),
					head = document.head || document.getElementsByTagName('head')[0];
				if (browser.firefox)
					code = '\n' + code;
				script.appendChild(document.createTextNode(
					'paper._execute = function(' + params + ') {' + code + '\n}'
				));
				head.appendChild(script);
				func = paper._execute;
				delete paper._execute;
				head.removeChild(script);
			} else {
				func = Function(params, code);
			}
			var res = func.apply(scope, args) || {};
			Base.each(toolHandlers, function(key) {
				var value = res[key];
				if (value)
					tool[key] = value;
			});
			if (view) {
				if (res.onResize)
					view.setOnResize(res.onResize);
				view.emit('resize', {
					size: view.size,
					delta: new Point()
				});
				if (res.onFrame)
					view.setOnFrame(res.onFrame);
				view.update();
			}
		}
	
		function loadScript(script) {
			if (/^text\/(?:x-|)paperscript$/.test(script.type)
					&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
				var canvasId = PaperScope.getAttribute(script, 'canvas'),
					canvas = document.getElementById(canvasId),
					src = script.src || script.getAttribute('data-src'),
					async = PaperScope.hasAttribute(script, 'async'),
					scopeAttribute = 'data-paper-scope';
				if (!canvas)
					throw new Error('Unable to find canvas with id "'
							+ canvasId + '"');
				var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
							|| new PaperScope().setup(canvas);
				canvas.setAttribute(scopeAttribute, scope._id);
				if (src) {
					Http.request('get', src, function(code) {
						execute(code, scope, src);
					}, async);
				} else {
					execute(script.innerHTML, scope, script.baseURI);
				}
				script.setAttribute('data-paper-ignore', 'true');
				return scope;
			}
		}
	
		function loadAll() {
			Base.each(document.getElementsByTagName('script'), loadScript);
		}
	
		function load(script) {
			return script ? loadScript(script) : loadAll();
		}
	
		if (document.readyState === 'complete') {
			setTimeout(loadAll);
		} else {
			DomEvent.add(window, { load: loadAll });
		}
	
		return {
			compile: compile,
			execute: execute,
			load: load,
			parse: parse
		};
	
	}).call(this);
	
	paper = new (PaperScope.inject(Base.exports, {
		enumerable: true,
		Base: Base,
		Numerical: Numerical,
		Key: Key
	}))();
	
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === 'object' && module) {
		module.exports = paper;
	}
	
	return paper;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.changeCenter = changeCenter;
	exports.changeZoom = changeZoom;
	var Paper = __webpack_require__(6);
	
	function changeCenter(oldCenter, offset, factor) {
	  offset = offset.multiply(factor);
	  return offset;
	}
	
	function changeZoom(oldZoom, delta, center, position) {
	  var factor = 1.05;
	  var newZoom = delta < 0 ? oldZoom * factor : oldZoom / factor;
	  var beta = oldZoom / newZoom;
	  var pc = position.subtract(center);
	  var offset = position.subtract(pc.multiply(beta)).subtract(center);
	  return { newZoom: newZoom, offset: offset };
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.init = init;
	exports.add = add;
	var Paper = __webpack_require__(6);
	
	var animations = [];
	
	function _remove(animation) {
	  animations = animations.filter(function (a) {
	    return a !== animation;
	  });
	}
	
	function onFrame(event) {
	  if (event.delta === 0) return;
	  animations.forEach(function (animation) {
	    animation.elapsedTime += event.delta;
	    var continueAnimation = animation.callback(animation.elapsedTime);
	    if (continueAnimation === false) {
	      _remove(animation);
	    }
	  });
	}
	
	function init() {
	  Paper.view.onFrame = onFrame;
	}
	
	function add(callback) {
	  var animation = {
	    callback: callback,
	    elapsedTime: 0
	  };
	  animations.push(animation);
	  return {
	    remove: function remove() {
	      return _remove(animation);
	    }
	  };
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.GetMaps = GetMaps;
	exports.AddMap = AddMap;
	exports.RemoveMap = RemoveMap;
	exports.SetNbrOfPlayers = SetNbrOfPlayers;
	exports.GetNbrOfPlayers = GetNbrOfPlayers;
	exports.GetIsMuted = GetIsMuted;
	exports.SetIsMuted = SetIsMuted;
	exports.GetEnableStars = GetEnableStars;
	exports.SetEnableStars = SetEnableStars;
	function GetUserConfig() {
	  var config = localStorage.getItem('UserConfig');
	  if (!config) {
	    config = {};
	    SetUserConfig(config);
	  }
	  return JSON.parse(config);
	}
	
	function SetUserConfig(config) {
	  localStorage.setItem('UserConfig', JSON.stringify(config));;
	}
	
	function GetUserConfigValue(key, defaultValue) {
	  var config = GetUserConfig();
	
	  if (config[key] === undefined) {
	    config[key] = defaultValue;
	    SetUserConfig(config);
	  }
	
	  return config[key];
	}
	
	function SetUserConfigValue(key, value) {
	  var config = GetUserConfig();
	  config[key] = value;
	  SetUserConfig(config);
	}
	
	function GetMaps() {
	  var maps = [];
	  for (var i = 0; i < localStorage.length; i++) {
	    var key = localStorage.key(i);
	    if (key.indexOf('map') === 0) {
	      maps.push(JSON.parse(localStorage.getItem(key)));
	    }
	  }
	
	  return maps;
	}
	
	function AddMap(map) {
	  localStorage.setItem(map.key, JSON.stringify(map));
	}
	
	function RemoveMap(map) {
	  localStorage.removeItem(map.key);
	}
	
	function SetNbrOfPlayers(nbrOfPlayers) {
	  SetUserConfigValue('nbrOfPlayers', nbrOfPlayers);
	}
	
	function GetNbrOfPlayers() {
	  return GetUserConfigValue('nbrOfPlayers', 2);
	}
	
	function GetIsMuted() {
	  return GetUserConfigValue('isMuted', false);
	}
	
	function SetIsMuted(isMuted) {
	  SetUserConfigValue('isMuted', isMuted);
	}
	
	function GetEnableStars() {
	  return GetUserConfigValue('enableStars', true);
	}
	
	function SetEnableStars(enableStars) {
	  SetUserConfigValue('enableStars', enableStars);
	}

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	__webpack_require__(11);
	var ClickListenerHandler = __webpack_require__(13);
	
	var MainMenu = (function () {
	  function MainMenu(onDone, params) {
	    _classCallCheck(this, MainMenu);
	
	    this.mainMenu = document.querySelector('#mainMenu');
	    this.mainMenu.style.visibility = 'visible';
	
	    this.clickListenerHandler = new ClickListenerHandler();
	    this.clickListenerHandler.add(document.querySelector('#puzzleModeButton'), function () {
	      return onDone({ view: 'Puzzle menu' });
	    });
	    this.clickListenerHandler.add(document.querySelector('#freeModeButton'), function () {
	      return onDone({ view: 'Freeplay menu' });
	    });
	  }
	
	  _createClass(MainMenu, [{
	    key: 'dispose',
	    value: function dispose() {
	      this.clickListenerHandler.dispose();
	      this.mainMenu.style.visibility = '';
	    }
	  }]);
	
	  return MainMenu;
	})();
	
	exports['default'] = MainMenu;
	module.exports = exports['default'];

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(12);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./mainMenu.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./mainMenu.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, ".mainMenu {\n  text-align: center;\n  padding-top: 23vw;\n  top: 0;\n  bottom: 0;\n}\n\n.titleText {\n  font-size: 10vw;\n  margin-bottom: 5vw;\n}\n\n.mainMenuButton {\n  font-size: 2vw;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n\n.mainMenuButton .icon{\n  display: inline;\n  opacity: 1;\n  fill: currentColor;\n}\n\n.mainMenuButton-puzzle{\n  position: absolute;\n  bottom: 5vw;\n  left: 30vw;\n}\n\n.mainMenuButton-puzzle .icon{\n  margin-right: 1vw;\n}\n\n.mainMenuButton-free{\n  position: absolute;\n  bottom: 5vw;\n  left: 54vw;\n}\n\n.mainMenuButton-free svg {\n  margin-right: 2.5vw;\n  -webkit-transform: rotate(30deg);\n      -ms-transform: rotate(30deg);\n          transform: rotate(30deg);\n}\n\n.mainMenuButton svg{\n  width: 7vw;\n  height: 7vw;\n}\n", ""]);
	
	// exports


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var audio = __webpack_require__(14);
	
	var ClickListenerHandler = (function () {
	  function ClickListenerHandler() {
	    _classCallCheck(this, ClickListenerHandler);
	
	    this.clickListeners = [];
	  }
	
	  _createClass(ClickListenerHandler, [{
	    key: 'add',
	    value: function add(element, onclick) {
	      var callback = function callback(event) {
	        audio.playClick();
	        onclick(event);
	      };
	      element.addEventListener('click', callback);
	      this.clickListeners.push({ element: element, callback: callback });
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.clickListeners.forEach(function (listener) {
	        return listener.element.removeEventListener('click', listener.callback);
	      });
	    }
	  }]);
	
	  return ClickListenerHandler;
	})();
	
	exports['default'] = ClickListenerHandler;
	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.ToggleIsMuted = ToggleIsMuted;
	exports.playClick = playClick;
	var storage = __webpack_require__(9);
	
	window.AudioContext = window.AudioContext || window.webkitAudioContext;
	var context = new AudioContext();
	var masterGain = context.createGain();
	masterGain.connect(context.destination);
	masterGain.gain.value = storage.GetIsMuted() ? 0 : 0.5;
	
	function ToggleIsMuted() {
	  var isMuted = !storage.GetIsMuted();
	  storage.SetIsMuted(isMuted);
	  masterGain.gain.value = isMuted ? 0 : 0.5;
	  return isMuted;
	}
	
	var click;
	loadArrayBuffer('sounds/click2.wav', context, function (buffer) {
	  return click = buffer;
	});
	
	function playClick() {
	  var sound = createSourceAndGain(click);
	  sound.gainNode.gain.value = 0.5;
	  sound.source.start(0);
	}
	
	var ambientSounds = [];
	var ambientSoundUrls = ['sounds/sirens-of-amygdala.wav', //http://freesound.org/people/ERH/sounds/31041/
	'sounds/blaster-1.wav', //http://freesound.org/people/ERH/sounds/30304/
	'sounds/boom-2.wav', //http://freesound.org/people/ERH/sounds/30261/
	'sounds/boom-3.wav', //http://freesound.org/people/ERH/sounds/30262/
	'sounds/wind.ogg'];
	//http://freesound.org/people/Black%20Boe/sounds/22331/
	ambientSoundUrls.forEach(function (url, index) {
	  return loadArrayBuffer(url, context, function (buffer) {
	    ambientSounds.push(buffer);
	    if (index === 0) scheduleAmbientSound();
	  });
	});
	
	function scheduleAmbientSound() {
	  var buffer = ambientSounds[Math.floor(Math.random() * ambientSounds.length)];
	  var duration = buffer.duration;
	  var fadeTime = randomInt(5, 15);
	  var silence = randomInt(5, 25);
	
	  var gain = random(0.2, 0.5);
	  var sound = createSourceAndGain(buffer);
	  var source = sound.source;
	  var gainNode = sound.gainNode;
	  var currTime = context.currentTime;
	  gainNode.gain.linearRampToValueAtTime(0, currTime);
	  gainNode.gain.linearRampToValueAtTime(gain, currTime + fadeTime);
	  source.start(0);
	  gainNode.gain.linearRampToValueAtTime(gain, currTime + duration - fadeTime);
	  gainNode.gain.linearRampToValueAtTime(0, currTime + duration);
	
	  setTimeout(function () {
	    return scheduleAmbientSound();
	  }, (duration - fadeTime + silence) * 1000);
	}
	
	function loadArrayBuffer(url, context, callback) {
	  var request = new XMLHttpRequest();
	  request.open('GET', url, true);
	  request.responseType = 'arraybuffer';
	  request.onload = function () {
	    return context.decodeAudioData(request.response, function (buffer) {
	      return callback(buffer);
	    }, function (error) {
	      return console.log(error);
	    });
	  };
	  request.send();
	}
	
	function createSourceAndGain(buffer) {
	  var gainNode = context.createGain();
	  gainNode.connect(masterGain);
	
	  var source = context.createBufferSource();
	  source.buffer = buffer;
	  source.connect(gainNode);
	  source.connect(masterGain);
	  return { source: source, gainNode: gainNode };
	}
	
	function randomInt(min, max) {
	  return Math.floor(random(min, max));
	}
	
	function random(min, max) {
	  return Math.random() * (max - min) + min;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	__webpack_require__(16);
	var view = __webpack_require__(5);
	var audio = __webpack_require__(14);
	var storage = __webpack_require__(9);
	var prepop = __webpack_require__(18);
	var ClickListenerHandler = __webpack_require__(13);
	
	var FreeplayMenu = (function () {
	  function FreeplayMenu(onDone, params) {
	    var _this = this;
	
	    _classCallCheck(this, FreeplayMenu);
	
	    this.clickListenerHandler = new ClickListenerHandler();
	    this.selectedMapImage = document.querySelector('#selectedMapImage');
	    this.maps = document.querySelector('#maps');
	
	    view.reset();
	    this.onDone = onDone;
	
	    var maps = storage.GetMaps();
	    if (!maps.length) {
	      prepop.prepopulateMaps(function (maps) {
	        return _this.setMaps(maps);
	      });
	    } else {
	      this.setMaps(maps);
	    }
	
	    this.nbrOfPlayersElement = document.querySelector('#nbrOfPlayers');
	    this.nbrOfPlayersElement.innerText = this.nbrOfPlayers;
	
	    this.muteButton = document.querySelector('#muteButton');
	    if (storage.GetIsMuted()) {
	      this.muteButton.classList.add('selected');
	    }
	    this.clickListenerHandler.add(this.muteButton, function () {
	      return _this.toggleIsMuted();
	    });
	
	    this.starsButton = document.querySelector('#starsButton');
	    if (storage.GetEnableStars()) {
	      this.starsButton.classList.add('selected');
	    }
	    this.clickListenerHandler.add(this.starsButton, function () {
	      return _this.toggleStarsVisibility();
	    });
	
	    this.freeplayMenu = document.querySelector('#freeplayMenu');
	    this.freeplayMenu.style.visibility = 'initial';
	
	    var createMapButton = document.querySelector('#createMapButton');
	    this.clickListenerHandler.add(createMapButton, function () {
	      return _this.onDone({ view: 'Create map' });
	    });
	
	    var fewerPlayersButton = document.querySelector('#fewerPlayersButton');
	    this.clickListenerHandler.add(fewerPlayersButton, function () {
	      return _this.nbrOfPlayers--;
	    });
	
	    var morePlayersButton = document.querySelector('#morePlayersButton');
	    this.clickListenerHandler.add(morePlayersButton, function () {
	      return _this.nbrOfPlayers++;
	    });
	
	    var editMapButton = document.querySelector('#editMapButton');
	    this.clickListenerHandler.add(editMapButton, function () {
	      return _this.onDone({ view: 'Create map', params: _this.selectedMap });
	    });
	
	    var deleteMapButton = document.querySelector('#deleteMapButton');
	    this.clickListenerHandler.add(deleteMapButton, function () {
	      return _this.removeCurrentMap();
	    });
	
	    this.clickListenerHandler.add(selectedMapImage, function () {
	      _this.onDone({
	        view: 'Game',
	        params: {
	          map: _this.selectedMap.map,
	          nrbOfPlayers: _this.nbrOfPlayers
	        }
	      });
	    });
	  }
	
	  _createClass(FreeplayMenu, [{
	    key: 'setMaps',
	    value: function setMaps(maps) {
	      this.savedMaps = maps;
	      this.selectedMap = this.savedMaps[0];
	      this.renderMapsList();
	    }
	  }, {
	    key: 'toggleIsMuted',
	    value: function toggleIsMuted() {
	      var isMuted = audio.ToggleIsMuted();
	      if (isMuted) {
	        this.muteButton.classList.add('selected');
	      } else {
	        this.muteButton.classList.remove('selected');
	      }
	    }
	  }, {
	    key: 'toggleStarsVisibility',
	    value: function toggleStarsVisibility() {
	      var newStarsVisibility = view.toggleStarsVisibility();
	      if (newStarsVisibility) {
	        this.starsButton.classList.add('selected');
	      } else {
	        this.starsButton.classList.remove('selected');
	      }
	    }
	  }, {
	    key: 'removeCurrentMap',
	    value: function removeCurrentMap() {
	      if (this.selectedMap) storage.RemoveMap(this.selectedMap);
	
	      this.savedMaps = storage.GetMaps();
	      if (this.savedMaps.length > 0) this.selectedMap = this.savedMaps[0];
	      this.clearMapsList();
	      this.renderMapsList();
	    }
	  }, {
	    key: 'renderMapsList',
	    value: function renderMapsList() {
	      var _this2 = this;
	
	      this.savedMaps.forEach(function (map, index) {
	        if (index === 0) _this2.selectedMap = map;
	        var img = document.createElement('img');
	        img.src = map.dataURL;
	        _this2.clickListenerHandler.add(img, function () {
	          return _this2.selectedMap = map;
	        });
	        _this2.maps.appendChild(img);
	      });
	    }
	  }, {
	    key: 'clearMapsList',
	    value: function clearMapsList() {
	      while (this.maps.children.length > 1) {
	        this.maps.removeChild(this.maps.lastChild);
	      }
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.freeplayMenu.style.visibility = '';
	      this.clearMapsList();
	      this.clickListenerHandler.dispose();
	    }
	  }, {
	    key: 'nbrOfPlayers',
	    get: function get() {
	      return storage.GetNbrOfPlayers();
	    },
	    set: function set(value) {
	      var nbrOfPlayers = Math.max(1, Math.min(value, 4));
	      storage.SetNbrOfPlayers(nbrOfPlayers);
	      this.nbrOfPlayersElement.innerText = nbrOfPlayers;
	    }
	  }, {
	    key: 'selectedMap',
	    get: function get() {
	      return this.selectedMap_;
	    },
	    set: function set(value) {
	      this.selectedMap_ = value;
	      this.selectedMapImage.setAttribute('src', this.selectedMap_.dataURL);
	    }
	  }]);
	
	  return FreeplayMenu;
	})();
	
	exports['default'] = FreeplayMenu;
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(17);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./freeplayMenu.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./freeplayMenu.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "#freeplayMenu {\n  top: 5vw;\n  bottom: 5vw;\n  padding: 1vw;\n}\n\n.mapsMenu {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  margin-top: 1vw;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n}\n\n.mapsMenu > * {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: column;\n      -ms-flex-direction: column;\n          flex-direction: column;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n\n#createMapButton {\n  font-size: 5vw;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n\n.selectedMap {\n  margin-left: 1vw;\n}\n\n.selectedMap img {\n  width: 40vw;\n  height: 40vw;\n}\n\n#createMapButton, #maps img {\n  width: 9vw;\n  height: 9vw;\n}\n\n#maps * + * {\n  margin-top: 1vw;\n}\n\n.mapControls {\n  margin-top: 20px;\n  font-size: 20px;\n}\n\nimg {\n  cursor: pointer;\n  background-color: black;\n  border-radius: 5px;\n  border: 1px solid white;\n}\n", ""]);
	
	// exports


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.prepopulateMaps = prepopulateMaps;
	var storage = __webpack_require__(9);
	
	function prepopulateMaps(cb) {
	  var request = new XMLHttpRequest();
	  request.open('GET', 'src/prepop/data.json', true);
	  request.responseType = 'json';
	  request.onload = function () {
	    var maps = request.response;
	    maps.forEach(function (map) {
	      return storage.AddMap(map);
	    });
	    cb(maps);
	  };
	  request.send();
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	__webpack_require__(21);
	var Paper = __webpack_require__(6);
	var view = __webpack_require__(5);
	var animation = __webpack_require__(8);
	var audio = __webpack_require__(14);
	var ClickListenerHandler = __webpack_require__(13);
	var storage = __webpack_require__(9);
	
	var MapEditor = (function () {
	  function MapEditor(onDone, params) {
	    var _this = this;
	
	    _classCallCheck(this, MapEditor);
	
	    this.onDone = onDone;
	
	    if (params) {
	      this.key = params.key;
	      this.track = Paper.project.importJSON(params.map.track);
	      this.start = Paper.project.importJSON(params.map.start);
	      this.end = Paper.project.importJSON(params.map.end);
	    } else {
	      this.track = new Paper.Path();
	      this.start = new Paper.Path();
	      this.end = new Paper.Path();
	    }
	    this.tools = [{
	      name: 'track',
	      color: 'purple',
	      path: this.track,
	      element: document.querySelector('#createTrackButton'),
	      init: function init(newCircle) {
	        return newCircle;
	      }
	    }, {
	      name: 'start',
	      color: 'green',
	      path: this.start,
	      element: document.querySelector('#createStartButton'),
	      init: function init(newCircle) {
	        return _this.getTool('track').path.intersect(newCircle);
	      }
	    }, {
	      name: 'end',
	      color: 'yellow',
	      path: this.end,
	      element: document.querySelector('#createEndButton'),
	      init: function init(newCircle) {
	        return _this.getTool('track').path.intersect(newCircle);
	      }
	    }];
	    this.tools.forEach(function (tool) {
	      return tool.path.fillColor = tool.color;
	    });
	
	    this.course = new Paper.Group(this.track, this.start, this.end);
	    view.addCourse(this.course);
	
	    this.clickListenerHandler = new ClickListenerHandler();
	    this.tools.forEach(function (tool) {
	      return _this.clickListenerHandler.add(tool.element, function () {
	        return _this.selectedTool = tool.name;
	      });
	    });
	
	    this.mapEditor = document.querySelector('#mapEditor');
	    this.mapEditor.style.visibility = 'visible';
	
	    this.mouseControls = new Paper.Tool();
	    this.mouseControls.onMouseDown = function (e) {
	      audio.playClick();
	      _this.onMouseDown(e);
	    };
	    this.mouseControls.onMouseDrag = function (e) {
	      return _this.onMouseDrag(e);
	    };
	
	    this.saveMapButton = document.querySelector('#saveMapButton');
	    this.saveMapButton.classList.add('disabled');
	    this.clickListenerHandler.add(this.saveMapButton, function () {
	      return _this.done();
	    });
	    this.exitMapEditorButton = document.querySelector('#exitMapEditorButton');
	    this.clickListenerHandler.add(this.exitMapEditorButton, function () {
	      return _this.onDone({ view: 'Main menu' });
	    });
	
	    this.brushButtons = ['#brushSize1', '#brushSize2', '#brushSize3'].map(function (buttonSelector) {
	      return document.querySelector(buttonSelector);
	    });
	    this.brushButtons.forEach(function (element, i) {
	      return _this.clickListenerHandler.add(element, function () {
	        return _this.brushsize = i + 1;
	      });
	    });
	
	    this.brushsize = 2;
	    this.selectedTool = 'track';
	  }
	
	  _createClass(MapEditor, [{
	    key: 'getTool',
	    value: function getTool(name) {
	      return this.tools.filter(function (tool) {
	        return tool.name === name;
	      })[0];
	    }
	  }, {
	    key: 'setButtonStates',
	    value: function setButtonStates() {
	      if (!this.getTool('track').path.isEmpty()) {
	        this.getTool('start').element.classList.remove("disabled");
	        this.getTool('end').element.classList.remove("disabled");
	      }
	
	      if (this.tools.filter(function (tool) {
	        return tool.path.isEmpty();
	      }).length === 0) {
	        this.saveMapButton.classList.remove('disabled');
	      }
	
	      this.tools.forEach(function (tool) {
	        return tool.element.classList.remove("selected");
	      });
	      this.getTool(this.selectedTool).element.classList.add("selected");
	    }
	  }, {
	    key: 'onMouseDown',
	    value: function onMouseDown(event) {
	      var tool = this.getTool(this.selectedTool);
	      if (tool.path.area < 50) {
	        this.removePath(tool.path);
	        var path = new Paper.Path.Circle(event.point, this.brushsize);
	        tool.path = path;
	        tool.path.fillColor = tool.color;
	        tool.path.simplify();
	        this.course.addChild(tool.path);
	      }
	      this.isAdding = tool.path.contains(event.point);
	      this.setButtonStates();
	    }
	  }, {
	    key: 'onMouseDrag',
	    value: function onMouseDrag(event) {
	      var editCircle = new Paper.Path.Circle(event.point, this.brushsize);
	      var tool = this.getTool(this.selectedTool);
	
	      var newPath = this.isAdding ? tool.path.unite(editCircle) : tool.path.subtract(editCircle);
	      this.removePath(editCircle);
	      this.removePath(tool.path);
	      tool.path = newPath;
	      tool.path.fillColor = tool.color;
	      this.setButtonStates();
	    }
	  }, {
	    key: 'removePath',
	    value: function removePath(path) {
	      path.remove();
	      if (path.removeSegments) {
	        path.removeSegments();
	      } else {
	        path.children.forEach(function (c) {
	          return c.removeSegments();
	        });
	        path.removeChildren();
	      };
	    }
	  }, {
	    key: 'done',
	    value: function done() {
	      var track = this.getTool('track');
	      this.tools.filter(function (tool) {
	        return tool.name != 'track';
	      }).forEach(function (tool) {
	        var newPath = track.path.unite(tool.path);
	        track.path.remove();
	        track.path = newPath;
	      });
	      var map = {};
	      this.tools.forEach(function (tool) {
	        return map[tool.name] = tool.path.toJSON();
	      });
	
	      var dataURL = document.querySelector('canvas').toDataURL("image/png");
	      var key = this.key ? this.key : 'map-' + new Date().toISOString();
	      storage.AddMap({ dataURL: dataURL, map: map, key: key });
	      this.onDone({ view: 'Main menu' });
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.course.remove();
	      document.removeEventListener('gestureend', this.gestureendListener);
	      document.removeEventListener('mosewheel', this.mousewheelListener);
	      this.mouseControls.remove();
	      this.clickListenerHandler.dispose();
	      this.mapEditor.style.visibility = '';
	    }
	  }, {
	    key: 'selectedTool',
	    get: function get() {
	      return this.selectedTool_;
	    },
	    set: function set(value) {
	      this.selectedTool_ = value;
	      this.setButtonStates();
	    }
	  }, {
	    key: 'brushsize',
	    get: function get() {
	      return this.brushsize_ * 20;
	    },
	    set: function set(value) {
	      this.brushsize_ = value;
	      this.brushButtons.forEach(function (element) {
	        return element.classList.remove('selected');
	      });
	      this.brushButtons[value - 1].classList.add('selected');
	    }
	  }]);
	
	  return MapEditor;
	})();
	
	exports['default'] = MapEditor;
	module.exports = exports['default'];

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(22);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./mapEditor.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./mapEditor.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "#mapEditor {\n  visibility: hidden;\n  position: absolute;\n  margin: 1vw;\n  border-radius: 3px;\n  display: inline-block;\n  color: white;\n  text-align: center;\n  font-size: 1.2vw;\n  background-color: rgba(0, 128, 128, 0.2);\n  border: 1px solid white;\n  top: 30vw;\n}\n\n#mapEditor > * {\n  padding: 1vw;\n}\n\n#mapEditor > * + * {\n  border-top: 1px solid white;\n}\n\n.mapEditorSteps > * {\n  display: block;\n}\n\n.mapEditorSteps > * + * {\n  margin-top: 1vw;\n}\n", ""]);
	
	// exports


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	__webpack_require__(24);
	var Paper = __webpack_require__(6);
	var Player = __webpack_require__(26);
	var Game = __webpack_require__(27);
	var view = __webpack_require__(5);
	var animation = __webpack_require__(8);
	var audio = __webpack_require__(14);
	var ClickListenerHandler = __webpack_require__(13);
	
	var GameGui = (function () {
	  function GameGui(callback, params) {
	    var _this = this;
	
	    _classCallCheck(this, GameGui);
	
	    this.callback = callback;
	    this.game;
	    this.nbrOfPlayers = params.nrbOfPlayers;
	    this.players = [];
	    this.playerConfigs = [{ name: 'Yellow', color: '#ffff00' }, { name: 'Blue', color: '#0000ff' }, { name: 'Red', color: '#ff0000' }, { name: 'Green', color: '#00ff00' }];
	    this.controls = new Paper.Group();
	    this.controlAnimations = [];
	    this.foreGround = new Paper.Group([this.controls]);
	    this.course = new Paper.Group();
	    this.mouseControls = new Paper.Tool();
	    this.mouseControls.onMouseDown = function (e) {
	      return _this.addPlayerClickEvent(e);
	    };
	
	    this.game = new Game(params.map);
	
	    var track = this.game.track;
	    track.fillColor = 'purple';
	    var startArea = this.game.start;
	    startArea.fillColor = 'green';
	    var endArea = this.game.end;
	    endArea.fillColor = 'yellow';
	
	    this.course.addChild(track);
	    this.course.addChild(startArea);
	    this.course.addChild(endArea);
	    view.addCourse(this.course);
	
	    this.setViewToStart();
	
	    this.mousewheelListener = document.addEventListener('mousewheel', function (event) {
	      if (event.wheelDelta === 0) return;
	      _this.mousewheel(event.wheelDelta < 0);
	    });
	
	    this.gestureendListener = document.addEventListener('gestureend', function (e) {
	      return _this.mousewheel(e.scale < 1);
	    }, false);
	
	    this.gameGui = document.querySelector('#gameGui');
	    this.endGameButton = document.querySelector('#endGameButton');
	    this.endGameText = document.querySelector('#endGameText');
	
	    this.clickListenerHandler = new ClickListenerHandler();
	    this.clickListenerHandler.add(endGameButton, function () {
	      return _this.endGameButtonListener();
	    });
	  }
	
	  _createClass(GameGui, [{
	    key: 'addPlayerClickEvent',
	    value: function addPlayerClickEvent(event) {
	      audio.playClick();
	      var x = Math.round(event.point.x / 20) * 20;
	      var y = Math.round(event.point.y / 20) * 20;
	      var point = new Paper.Point(x, y);
	      if (this.game.start.contains(point)) {
	        this.game.addPlayer(point, new Paper.Point(0, 0));
	        this.players.push(new Player(this.playerConfigs.pop(), point));
	        if (this.players.length === this.nbrOfPlayers) {
	          this.startGame();
	        }
	      }
	    }
	  }, {
	    key: 'startGame',
	    value: function startGame() {
	      var _this2 = this;
	
	      this.players.forEach(function (p) {
	        return _this2.foreGround.appendBottom(p.elements);
	      });
	      this.mouseControls.onMouseDown = function (e) {
	        return _this2.onMouseDown(e);
	      };
	      this.game.startGame();
	      this.drawControls();
	    }
	  }, {
	    key: 'onMouseDown',
	    value: function onMouseDown(event) {
	      audio.playClick();
	      var item = event.getItem();
	      if (!item) {
	        return;
	      }
	      var itemClicked = item.hitTest(event.point).item;
	      if (itemClicked && itemClicked.movePlayerData) {
	        this.movePlayer(itemClicked.movePlayerData);
	      }
	    }
	  }, {
	    key: 'mousewheel',
	    value: function mousewheel(shouldZoomOut) {
	      if (shouldZoomOut) {
	        this.setViewToTrack();
	      } else {
	        if (!this.game.currentPlayer) {
	          this.setViewToStart();
	        } else {
	          this.setViewToControls();
	        }
	      }
	    }
	  }, {
	    key: 'movePlayer',
	    value: function movePlayer(relativeVector) {
	      var guiPlayer = this.players[this.game.currentPlayerIndex];
	      var player = this.game.movePlayer(relativeVector);
	      guiPlayer.addPosition(player.position);
	      if (player.isInEndZone) {
	        var moves = player.positions.length - 1;
	        this.endGame('Game over, ' + guiPlayer.name.toLowerCase() + ' player won in ' + moves + ' moves!');
	      } else {
	        this.nextTurn();
	      }
	    }
	  }, {
	    key: 'nextTurn',
	    value: function nextTurn() {
	      this.game.nextTurn();
	      this.clearControls();
	
	      if (this.game.gameOver()) {
	        this.endGame('Everybody crashed, you all lost!');
	      } else if (!this.game.currentPlayer.isAlive) {
	        this.nextTurn();
	      } else {
	        this.drawControls();
	      }
	    }
	  }, {
	    key: 'drawControls',
	    value: function drawControls() {
	      var _this3 = this;
	
	      var circles = this.game.vectorsForControls.map(function (controlObject) {
	        return _this3.createControl(controlObject);
	      });
	      this.controlAnimations = circles.map(function (circle) {
	        return animation.add(function (elapsedTime) {
	          circle.scale(1 + Math.sin(elapsedTime * 10) / 100);
	        });
	      });
	      circles.forEach(function (circle) {
	        return _this3.controls.addChild(circle);
	      });
	      this.setViewToControls();
	    }
	  }, {
	    key: 'clearControls',
	    value: function clearControls() {
	      this.controls.removeChildren();
	      this.controlAnimations.forEach(function (animation) {
	        return animation.remove();
	      });
	    }
	  }, {
	    key: 'setViewToStart',
	    value: function setViewToStart() {
	      view.setView(this.game.start.bounds.expand(200));
	    }
	  }, {
	    key: 'setViewToControls',
	    value: function setViewToControls() {
	      var playerBounds = this.controls.bounds.include(this.game.currentPlayer.position);
	      view.setView(playerBounds.expand(200));
	    }
	  }, {
	    key: 'setViewToTrack',
	    value: function setViewToTrack() {
	      view.setView(this.game.track.bounds);
	    }
	  }, {
	    key: 'createControl',
	    value: function createControl(controlObject) {
	      var circle = this.currentPlayer.createPositionElement(controlObject.absolute, this.currentPlayer.radius);
	      circle.movePlayerData = controlObject.relative;
	      circle.opacity = 0.5;
	      return circle;
	    }
	  }, {
	    key: 'endGame',
	    value: function endGame(text) {
	      this.clearControls();
	      this.gameGui.style.visibility = 'visible';
	      this.endGameText.textContent = text;
	    }
	  }, {
	    key: 'endGameButtonListener',
	    value: function endGameButtonListener() {
	      this.callback({ view: 'Main menu' });
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.course.remove();
	      this.foreGround.remove();
	      document.removeEventListener('gestureend', this.gestureendListener);
	      document.removeEventListener('mosewheel', this.mousewheelListener);
	      this.clickListenerHandler.dispose();
	      this.gameGui.style.visibility = '';
	      this.endGameText.textContent = '';
	      this.mouseControls.remove();
	    }
	  }, {
	    key: 'currentPlayer',
	    get: function get() {
	      return this.players[this.game.currentPlayerIndex];
	    }
	  }]);
	
	  return GameGui;
	})();
	
	exports['default'] = GameGui;
	module.exports = exports['default'];

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(25);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./gameGui.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./gameGui.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "#gameGui {\n  top: 5vw;\n  text-align: center;\n}\n\n.endGameMessage {\n  background-color: rgba(0, 128, 128, 0.2);\n  border: 1px solid white;\n  padding: 1vw;\n  display: inline-block;\n  border-radius: 3px;\n}\n\n.endGameText {\n  margin-bottom: 1vw;\n}\n", ""]);
	
	// exports


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Paper = __webpack_require__(6);
	
	var Player = (function () {
	  function Player(config, position) {
	    _classCallCheck(this, Player);
	
	    this.color = config.color;
	    this.name = config.name;
	    this.radius = 5;
	    this.positions = [];
	    this.path = new Paper.Path({
	      strokeColor: this.color,
	      strokeWidth: 0.5
	    });
	    this.circles = new Paper.Group();
	    this.elements = new Paper.Group([this.path, this.circles]);
	
	    this.addPosition(position);
	  }
	
	  _createClass(Player, [{
	    key: 'addPosition',
	    value: function addPosition(position) {
	      var _this = this;
	
	      this.path.add(position);
	      this.path.smooth();
	
	      this.circles.removeChildren();
	      this.positions.push(position);
	      this.positions.map(function (p, index) {
	        return _this.createPositionElement(p, _this.radius * (index + 1) / _this.positions.length);
	      }).forEach(function (circle) {
	        return _this.circles.addChild(circle);
	      });
	    }
	  }, {
	    key: 'createPositionElement',
	    value: function createPositionElement(position, radius) {
	      var circle = new Paper.Path.Circle(position, radius);
	      circle.fillColor = 'black';
	      circle.strokeColor = this.color;
	      circle.strokeWidth = 0.5;
	      return circle;
	    }
	  }]);
	
	  return Player;
	})();
	
	exports['default'] = Player;
	module.exports = exports['default'];

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Car = __webpack_require__(28);
	var Paper = __webpack_require__(6);
	
	var Game = (function () {
	  function Game(map) {
	    _classCallCheck(this, Game);
	
	    this.scale = 20;
	    this.players = [];
	    this.track = Paper.project.importJSON(map.track);
	    this.start = Paper.project.importJSON(map.start);
	    this.end = Paper.project.importJSON(map.end);
	    this.currentPlayerIndex = 0;
	    this.vectorsForControls = [];
	  }
	
	  _createClass(Game, [{
	    key: 'startGame',
	    value: function startGame() {
	      this.setVectorsForControls();
	    }
	  }, {
	    key: 'setVectorsForControls',
	    value: function setVectorsForControls() {
	      var player = this.currentPlayer;
	      var vectorsForControls = [];
	      for (var y = 1; y >= -1; y--) {
	        for (var x = -1; x <= 1; x++) {
	          var playerRelativeVector = new Paper.Point(this.scale * x, this.scale * y).clone().add(player.direction);
	          var absoluteVector = playerRelativeVector.clone().add(player.position);
	          if (this.isPossiblePosition(absoluteVector)) {
	            vectorsForControls.push({
	              relative: playerRelativeVector,
	              absolute: absoluteVector
	            });
	          }
	        }
	      }
	
	      if (vectorsForControls.length === 0) {
	        player.isAlive = false;
	      }
	
	      this.vectorsForControls = vectorsForControls;
	    }
	  }, {
	    key: 'addPlayer',
	    value: function addPlayer(point, direction) {
	      this.players.push(new Car(point, direction));
	    }
	  }, {
	    key: 'movePlayer',
	    value: function movePlayer(vector) {
	      this.currentPlayer.move(vector);
	      var player = this.currentPlayer;
	      player.isInEndZone = this.isInZone(this.end, player.position);
	      return player;
	    }
	  }, {
	    key: 'nextTurn',
	    value: function nextTurn() {
	      this.setNextPlayer();
	      this.setVectorsForControls();
	    }
	  }, {
	    key: 'setNextPlayer',
	    value: function setNextPlayer() {
	      this.currentPlayerIndex++;
	      if (this.currentPlayerIndex === this.players.length) {
	        this.currentPlayerIndex = 0;
	      }
	    }
	  }, {
	    key: 'isPossiblePosition',
	    value: function isPossiblePosition(v) {
	      var carsOnThisPosition = this.players.filter(function (p) {
	        return p.position.clone().subtract(v).length === 0;
	      });
	      var noOtherCars = carsOnThisPosition.length === 0;
	      var isOnTrack = this.track.contains(v);
	      return noOtherCars && isOnTrack;
	    }
	  }, {
	    key: 'isInZone',
	    value: function isInZone(zone, position) {
	      return zone.contains(position);
	    }
	  }, {
	    key: 'gameOver',
	    value: function gameOver() {
	      return this.players.filter(function (p) {
	        return p.isAlive;
	      }).length === 0;
	    }
	  }, {
	    key: 'currentPlayer',
	    get: function get() {
	      return this.players[this.currentPlayerIndex];
	    }
	  }]);
	
	  return Game;
	})();
	
	exports['default'] = Game;
	module.exports = exports['default'];

/***/ },
/* 28 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Car = (function () {
	  function Car(position, direction) {
	    _classCallCheck(this, Car);
	
	    this.positions = [position];
	    this.currentPositionIndex = 0;
	    this.direction = direction;
	    this.isAlive = true;
	    this.isInEndZone = false;
	  }
	
	  _createClass(Car, [{
	    key: "move",
	    value: function move(vector) {
	      this.position = this.position.clone().add(vector);
	      this.direction = vector;
	    }
	  }, {
	    key: "position",
	    get: function get() {
	      return this.positions[this.currentPositionIndex];
	    },
	    set: function set(value) {
	      this.positions.push(value);
	      this.currentPositionIndex++;
	    }
	  }]);
	
	  return Car;
	})();
	
	exports["default"] = Car;
	module.exports = exports["default"];

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;;(function () {
		'use strict';
	
		/**
		 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
		 *
		 * @codingstandard ftlabs-jsv2
		 * @copyright The Financial Times Limited [All Rights Reserved]
		 * @license MIT License (see LICENSE.txt)
		 */
	
		/*jslint browser:true, node:true*/
		/*global define, Event, Node*/
	
	
		/**
		 * Instantiate fast-clicking listeners on the specified layer.
		 *
		 * @constructor
		 * @param {Element} layer The layer to listen on
		 * @param {Object} [options={}] The options to override the defaults
		 */
		function FastClick(layer, options) {
			var oldOnClick;
	
			options = options || {};
	
			/**
			 * Whether a click is currently being tracked.
			 *
			 * @type boolean
			 */
			this.trackingClick = false;
	
	
			/**
			 * Timestamp for when click tracking started.
			 *
			 * @type number
			 */
			this.trackingClickStart = 0;
	
	
			/**
			 * The element being tracked for a click.
			 *
			 * @type EventTarget
			 */
			this.targetElement = null;
	
	
			/**
			 * X-coordinate of touch start event.
			 *
			 * @type number
			 */
			this.touchStartX = 0;
	
	
			/**
			 * Y-coordinate of touch start event.
			 *
			 * @type number
			 */
			this.touchStartY = 0;
	
	
			/**
			 * ID of the last touch, retrieved from Touch.identifier.
			 *
			 * @type number
			 */
			this.lastTouchIdentifier = 0;
	
	
			/**
			 * Touchmove boundary, beyond which a click will be cancelled.
			 *
			 * @type number
			 */
			this.touchBoundary = options.touchBoundary || 10;
	
	
			/**
			 * The FastClick layer.
			 *
			 * @type Element
			 */
			this.layer = layer;
	
			/**
			 * The minimum time between tap(touchstart and touchend) events
			 *
			 * @type number
			 */
			this.tapDelay = options.tapDelay || 200;
	
			/**
			 * The maximum time for a tap
			 *
			 * @type number
			 */
			this.tapTimeout = options.tapTimeout || 700;
	
			if (FastClick.notNeeded(layer)) {
				return;
			}
	
			// Some old versions of Android don't have Function.prototype.bind
			function bind(method, context) {
				return function() { return method.apply(context, arguments); };
			}
	
	
			var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
			var context = this;
			for (var i = 0, l = methods.length; i < l; i++) {
				context[methods[i]] = bind(context[methods[i]], context);
			}
	
			// Set up event handlers as required
			if (deviceIsAndroid) {
				layer.addEventListener('mouseover', this.onMouse, true);
				layer.addEventListener('mousedown', this.onMouse, true);
				layer.addEventListener('mouseup', this.onMouse, true);
			}
	
			layer.addEventListener('click', this.onClick, true);
			layer.addEventListener('touchstart', this.onTouchStart, false);
			layer.addEventListener('touchmove', this.onTouchMove, false);
			layer.addEventListener('touchend', this.onTouchEnd, false);
			layer.addEventListener('touchcancel', this.onTouchCancel, false);
	
			// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
			// layer when they are cancelled.
			if (!Event.prototype.stopImmediatePropagation) {
				layer.removeEventListener = function(type, callback, capture) {
					var rmv = Node.prototype.removeEventListener;
					if (type === 'click') {
						rmv.call(layer, type, callback.hijacked || callback, capture);
					} else {
						rmv.call(layer, type, callback, capture);
					}
				};
	
				layer.addEventListener = function(type, callback, capture) {
					var adv = Node.prototype.addEventListener;
					if (type === 'click') {
						adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
							if (!event.propagationStopped) {
								callback(event);
							}
						}), capture);
					} else {
						adv.call(layer, type, callback, capture);
					}
				};
			}
	
			// If a handler is already declared in the element's onclick attribute, it will be fired before
			// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
			// adding it as listener.
			if (typeof layer.onclick === 'function') {
	
				// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
				// - the old one won't work if passed to addEventListener directly.
				oldOnClick = layer.onclick;
				layer.addEventListener('click', function(event) {
					oldOnClick(event);
				}, false);
				layer.onclick = null;
			}
		}
	
		/**
		* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
		*
		* @type boolean
		*/
		var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
	
		/**
		 * Android requires exceptions.
		 *
		 * @type boolean
		 */
		var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
	
	
		/**
		 * iOS requires exceptions.
		 *
		 * @type boolean
		 */
		var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
	
	
		/**
		 * iOS 4 requires an exception for select elements.
		 *
		 * @type boolean
		 */
		var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
	
	
		/**
		 * iOS 6.0-7.* requires the target element to be manually derived
		 *
		 * @type boolean
		 */
		var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
	
		/**
		 * BlackBerry requires exceptions.
		 *
		 * @type boolean
		 */
		var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
	
		/**
		 * Determine whether a given element requires a native click.
		 *
		 * @param {EventTarget|Element} target Target DOM element
		 * @returns {boolean} Returns true if the element needs a native click
		 */
		FastClick.prototype.needsClick = function(target) {
			switch (target.nodeName.toLowerCase()) {
	
			// Don't send a synthetic click to disabled inputs (issue #62)
			case 'button':
			case 'select':
			case 'textarea':
				if (target.disabled) {
					return true;
				}
	
				break;
			case 'input':
	
				// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
				if ((deviceIsIOS && target.type === 'file') || target.disabled) {
					return true;
				}
	
				break;
			case 'label':
			case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
			case 'video':
				return true;
			}
	
			return (/\bneedsclick\b/).test(target.className);
		};
	
	
		/**
		 * Determine whether a given element requires a call to focus to simulate click into element.
		 *
		 * @param {EventTarget|Element} target Target DOM element
		 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
		 */
		FastClick.prototype.needsFocus = function(target) {
			switch (target.nodeName.toLowerCase()) {
			case 'textarea':
				return true;
			case 'select':
				return !deviceIsAndroid;
			case 'input':
				switch (target.type) {
				case 'button':
				case 'checkbox':
				case 'file':
				case 'image':
				case 'radio':
				case 'submit':
					return false;
				}
	
				// No point in attempting to focus disabled inputs
				return !target.disabled && !target.readOnly;
			default:
				return (/\bneedsfocus\b/).test(target.className);
			}
		};
	
	
		/**
		 * Send a click event to the specified element.
		 *
		 * @param {EventTarget|Element} targetElement
		 * @param {Event} event
		 */
		FastClick.prototype.sendClick = function(targetElement, event) {
			var clickEvent, touch;
	
			// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
			if (document.activeElement && document.activeElement !== targetElement) {
				document.activeElement.blur();
			}
	
			touch = event.changedTouches[0];
	
			// Synthesise a click event, with an extra attribute so it can be tracked
			clickEvent = document.createEvent('MouseEvents');
			clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
			clickEvent.forwardedTouchEvent = true;
			targetElement.dispatchEvent(clickEvent);
		};
	
		FastClick.prototype.determineEventType = function(targetElement) {
	
			//Issue #159: Android Chrome Select Box does not open with a synthetic click event
			if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
				return 'mousedown';
			}
	
			return 'click';
		};
	
	
		/**
		 * @param {EventTarget|Element} targetElement
		 */
		FastClick.prototype.focus = function(targetElement) {
			var length;
	
			// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
			if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
				length = targetElement.value.length;
				targetElement.setSelectionRange(length, length);
			} else {
				targetElement.focus();
			}
		};
	
	
		/**
		 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
		 *
		 * @param {EventTarget|Element} targetElement
		 */
		FastClick.prototype.updateScrollParent = function(targetElement) {
			var scrollParent, parentElement;
	
			scrollParent = targetElement.fastClickScrollParent;
	
			// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
			// target element was moved to another parent.
			if (!scrollParent || !scrollParent.contains(targetElement)) {
				parentElement = targetElement;
				do {
					if (parentElement.scrollHeight > parentElement.offsetHeight) {
						scrollParent = parentElement;
						targetElement.fastClickScrollParent = parentElement;
						break;
					}
	
					parentElement = parentElement.parentElement;
				} while (parentElement);
			}
	
			// Always update the scroll top tracker if possible.
			if (scrollParent) {
				scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
			}
		};
	
	
		/**
		 * @param {EventTarget} targetElement
		 * @returns {Element|EventTarget}
		 */
		FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	
			// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
			if (eventTarget.nodeType === Node.TEXT_NODE) {
				return eventTarget.parentNode;
			}
	
			return eventTarget;
		};
	
	
		/**
		 * On touch start, record the position and scroll offset.
		 *
		 * @param {Event} event
		 * @returns {boolean}
		 */
		FastClick.prototype.onTouchStart = function(event) {
			var targetElement, touch, selection;
	
			// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
			if (event.targetTouches.length > 1) {
				return true;
			}
	
			targetElement = this.getTargetElementFromEventTarget(event.target);
			touch = event.targetTouches[0];
	
			if (deviceIsIOS) {
	
				// Only trusted events will deselect text on iOS (issue #49)
				selection = window.getSelection();
				if (selection.rangeCount && !selection.isCollapsed) {
					return true;
				}
	
				if (!deviceIsIOS4) {
	
					// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
					// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
					// with the same identifier as the touch event that previously triggered the click that triggered the alert.
					// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
					// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
					// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
					// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
					// random integers, it's safe to to continue if the identifier is 0 here.
					if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
						event.preventDefault();
						return false;
					}
	
					this.lastTouchIdentifier = touch.identifier;
	
					// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
					// 1) the user does a fling scroll on the scrollable layer
					// 2) the user stops the fling scroll with another tap
					// then the event.target of the last 'touchend' event will be the element that was under the user's finger
					// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
					// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
					this.updateScrollParent(targetElement);
				}
			}
	
			this.trackingClick = true;
			this.trackingClickStart = event.timeStamp;
			this.targetElement = targetElement;
	
			this.touchStartX = touch.pageX;
			this.touchStartY = touch.pageY;
	
			// Prevent phantom clicks on fast double-tap (issue #36)
			if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
				event.preventDefault();
			}
	
			return true;
		};
	
	
		/**
		 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
		 *
		 * @param {Event} event
		 * @returns {boolean}
		 */
		FastClick.prototype.touchHasMoved = function(event) {
			var touch = event.changedTouches[0], boundary = this.touchBoundary;
	
			if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
				return true;
			}
	
			return false;
		};
	
	
		/**
		 * Update the last position.
		 *
		 * @param {Event} event
		 * @returns {boolean}
		 */
		FastClick.prototype.onTouchMove = function(event) {
			if (!this.trackingClick) {
				return true;
			}
	
			// If the touch has moved, cancel the click tracking
			if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
				this.trackingClick = false;
				this.targetElement = null;
			}
	
			return true;
		};
	
	
		/**
		 * Attempt to find the labelled control for the given label element.
		 *
		 * @param {EventTarget|HTMLLabelElement} labelElement
		 * @returns {Element|null}
		 */
		FastClick.prototype.findControl = function(labelElement) {
	
			// Fast path for newer browsers supporting the HTML5 control attribute
			if (labelElement.control !== undefined) {
				return labelElement.control;
			}
	
			// All browsers under test that support touch events also support the HTML5 htmlFor attribute
			if (labelElement.htmlFor) {
				return document.getElementById(labelElement.htmlFor);
			}
	
			// If no for attribute exists, attempt to retrieve the first labellable descendant element
			// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
			return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
		};
	
	
		/**
		 * On touch end, determine whether to send a click event at once.
		 *
		 * @param {Event} event
		 * @returns {boolean}
		 */
		FastClick.prototype.onTouchEnd = function(event) {
			var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
	
			if (!this.trackingClick) {
				return true;
			}
	
			// Prevent phantom clicks on fast double-tap (issue #36)
			if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
				this.cancelNextClick = true;
				return true;
			}
	
			if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
				return true;
			}
	
			// Reset to prevent wrong click cancel on input (issue #156).
			this.cancelNextClick = false;
	
			this.lastClickTime = event.timeStamp;
	
			trackingClickStart = this.trackingClickStart;
			this.trackingClick = false;
			this.trackingClickStart = 0;
	
			// On some iOS devices, the targetElement supplied with the event is invalid if the layer
			// is performing a transition or scroll, and has to be re-detected manually. Note that
			// for this to function correctly, it must be called *after* the event target is checked!
			// See issue #57; also filed as rdar://13048589 .
			if (deviceIsIOSWithBadTarget) {
				touch = event.changedTouches[0];
	
				// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
				targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
				targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
			}
	
			targetTagName = targetElement.tagName.toLowerCase();
			if (targetTagName === 'label') {
				forElement = this.findControl(targetElement);
				if (forElement) {
					this.focus(targetElement);
					if (deviceIsAndroid) {
						return false;
					}
	
					targetElement = forElement;
				}
			} else if (this.needsFocus(targetElement)) {
	
				// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
				// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
				if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
					this.targetElement = null;
					return false;
				}
	
				this.focus(targetElement);
				this.sendClick(targetElement, event);
	
				// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
				// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
				if (!deviceIsIOS || targetTagName !== 'select') {
					this.targetElement = null;
					event.preventDefault();
				}
	
				return false;
			}
	
			if (deviceIsIOS && !deviceIsIOS4) {
	
				// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
				// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
				scrollParent = targetElement.fastClickScrollParent;
				if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
					return true;
				}
			}
	
			// Prevent the actual click from going though - unless the target node is marked as requiring
			// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
			if (!this.needsClick(targetElement)) {
				event.preventDefault();
				this.sendClick(targetElement, event);
			}
	
			return false;
		};
	
	
		/**
		 * On touch cancel, stop tracking the click.
		 *
		 * @returns {void}
		 */
		FastClick.prototype.onTouchCancel = function() {
			this.trackingClick = false;
			this.targetElement = null;
		};
	
	
		/**
		 * Determine mouse events which should be permitted.
		 *
		 * @param {Event} event
		 * @returns {boolean}
		 */
		FastClick.prototype.onMouse = function(event) {
	
			// If a target element was never set (because a touch event was never fired) allow the event
			if (!this.targetElement) {
				return true;
			}
	
			if (event.forwardedTouchEvent) {
				return true;
			}
	
			// Programmatically generated events targeting a specific element should be permitted
			if (!event.cancelable) {
				return true;
			}
	
			// Derive and check the target element to see whether the mouse event needs to be permitted;
			// unless explicitly enabled, prevent non-touch click events from triggering actions,
			// to prevent ghost/doubleclicks.
			if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
	
				// Prevent any user-added listeners declared on FastClick element from being fired.
				if (event.stopImmediatePropagation) {
					event.stopImmediatePropagation();
				} else {
	
					// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
					event.propagationStopped = true;
				}
	
				// Cancel the event
				event.stopPropagation();
				event.preventDefault();
	
				return false;
			}
	
			// If the mouse event is permitted, return true for the action to go through.
			return true;
		};
	
	
		/**
		 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
		 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
		 * an actual click which should be permitted.
		 *
		 * @param {Event} event
		 * @returns {boolean}
		 */
		FastClick.prototype.onClick = function(event) {
			var permitted;
	
			// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
			if (this.trackingClick) {
				this.targetElement = null;
				this.trackingClick = false;
				return true;
			}
	
			// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
			if (event.target.type === 'submit' && event.detail === 0) {
				return true;
			}
	
			permitted = this.onMouse(event);
	
			// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
			if (!permitted) {
				this.targetElement = null;
			}
	
			// If clicks are permitted, return true for the action to go through.
			return permitted;
		};
	
	
		/**
		 * Remove all FastClick's event listeners.
		 *
		 * @returns {void}
		 */
		FastClick.prototype.destroy = function() {
			var layer = this.layer;
	
			if (deviceIsAndroid) {
				layer.removeEventListener('mouseover', this.onMouse, true);
				layer.removeEventListener('mousedown', this.onMouse, true);
				layer.removeEventListener('mouseup', this.onMouse, true);
			}
	
			layer.removeEventListener('click', this.onClick, true);
			layer.removeEventListener('touchstart', this.onTouchStart, false);
			layer.removeEventListener('touchmove', this.onTouchMove, false);
			layer.removeEventListener('touchend', this.onTouchEnd, false);
			layer.removeEventListener('touchcancel', this.onTouchCancel, false);
		};
	
	
		/**
		 * Check whether FastClick is needed.
		 *
		 * @param {Element} layer The layer to listen on
		 */
		FastClick.notNeeded = function(layer) {
			var metaViewport;
			var chromeVersion;
			var blackberryVersion;
			var firefoxVersion;
	
			// Devices that don't support touch don't need FastClick
			if (typeof window.ontouchstart === 'undefined') {
				return true;
			}
	
			// Chrome version - zero for other browsers
			chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
	
			if (chromeVersion) {
	
				if (deviceIsAndroid) {
					metaViewport = document.querySelector('meta[name=viewport]');
	
					if (metaViewport) {
						// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
							return true;
						}
						// Chrome 32 and above with width=device-width or less don't need FastClick
						if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
							return true;
						}
					}
	
				// Chrome desktop doesn't need FastClick (issue #15)
				} else {
					return true;
				}
			}
	
			if (deviceIsBlackBerry10) {
				blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
	
				// BlackBerry 10.3+ does not require Fastclick library.
				// https://github.com/ftlabs/fastclick/issues/251
				if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
					metaViewport = document.querySelector('meta[name=viewport]');
	
					if (metaViewport) {
						// user-scalable=no eliminates click delay.
						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
							return true;
						}
						// width=device-width (or less than device-width) eliminates click delay.
						if (document.documentElement.scrollWidth <= window.outerWidth) {
							return true;
						}
					}
				}
			}
	
			// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
			if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
				return true;
			}
	
			// Firefox version - zero for other browsers
			firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
	
			if (firefoxVersion >= 27) {
				// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
	
				metaViewport = document.querySelector('meta[name=viewport]');
				if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
					return true;
				}
			}
	
			// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
			// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
			if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
				return true;
			}
	
			return false;
		};
	
	
		/**
		 * Factory method for creating a FastClick object
		 *
		 * @param {Element} layer The layer to listen on
		 * @param {Object} [options={}] The options to override the defaults
		 */
		FastClick.attach = function(layer, options) {
			return new FastClick(layer, options);
		};
	
	
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return FastClick;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module !== 'undefined' && module.exports) {
			module.exports = FastClick.attach;
			module.exports.FastClick = FastClick;
		} else {
			window.FastClick = FastClick;
		}
	}());


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNWY5ZDNlZTBjNDc4NGJjMjZiYzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmNzcz85MTc4Iiwid2VicGFjazovLy8uL3NyYy9hcHAuY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy92aWV3LmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXIvZGlzdC9wYXBlci1mdWxsLmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9zdG9yYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9tYWluTWVudS9tYWluTWVudS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWFpbk1lbnUvbWFpbk1lbnUuY3NzP2E0NzciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL21haW5NZW51L21haW5NZW51LmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY2xpY2tMaXN0ZW5lckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F1ZGlvLmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9mcmVlcGxheU1lbnUvZnJlZXBsYXlNZW51LmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9mcmVlcGxheU1lbnUvZnJlZXBsYXlNZW51LmNzcz83ZDU1Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9mcmVlcGxheU1lbnUvZnJlZXBsYXlNZW51LmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJlcG9wL21hcFByZXBvcHVsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWFwRWRpdG9yL21hcEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWFwRWRpdG9yL21hcEVkaXRvci5jc3M/MmYyOSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWFwRWRpdG9yL21hcEVkaXRvci5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2dhbWVHdWkvZ2FtZUd1aS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvZ2FtZUd1aS9nYW1lR3VpLmNzcz85ZDVhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9nYW1lR3VpL2dhbWVHdWkuY3NzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9nYW1lR3VpL3BsYXllci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9nYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2Nhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Zhc3RjbGljay9saWIvZmFzdGNsaWNrLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUN0Q0Esb0JBQU8sQ0FBQyxDQUFXLENBQUMsQ0FBQzs7QUFFckIsS0FBSSxJQUFJLEdBQUcsbUJBQU8sQ0FBQyxDQUFjLENBQUMsQ0FBQztBQUNuQyxLQUFJLFFBQVEsR0FBRyxtQkFBTyxDQUFDLEVBQTJCLENBQUMsQ0FBQztBQUNwRCxLQUFJLFlBQVksR0FBRyxtQkFBTyxDQUFDLEVBQW1DLENBQUMsQ0FBQztBQUNoRSxLQUFJLFVBQVUsR0FBRyxtQkFBTyxDQUFDLEVBQStCLENBQUMsQ0FBQztBQUMxRCxLQUFJLFNBQVMsR0FBRyxtQkFBTyxDQUFDLEVBQTZCLENBQUMsQ0FBQztBQUN2RCxLQUFJLE9BQU8sR0FBRyxt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Q0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLHlDQUF3QyxRQUFRO0FBQ2hEO0FBQ0Esc0NBQXFDLFFBQVE7QUFDN0M7QUFDQSx5Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBVywyREFBMkQ7QUFDdEUsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBVztBQUNYLGlEQUFnRDtBQUNoRCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSx1Q0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSx1Q0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxpQ0FBZ0M7QUFDaEMsR0FBRTs7QUFFRjtBQUNBLGlDQUFnQztBQUNoQyxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsSUFBSTs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLHVDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSwwQ0FBeUMsZ0JBQWdCO0FBQ3pELEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILDJEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILGVBQWM7QUFDZCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiw0Q0FBNEM7QUFDakU7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSwyQ0FBMEMsOEJBQThCO0FBQ3hFO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsT0FBTztBQUN6RDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLCtCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsdUNBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILHFDQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQSw4Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTyxpREFBaUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCx5QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDJCQUEyQjtBQUN0QyxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVywyQkFBMkI7QUFDdEMsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVywyQkFBMkI7QUFDdEMsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLGtDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILG1CQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpREFBaUQ7QUFDaEU7QUFDQTtBQUNBLElBQUc7QUFDSCxrQkFBaUIsT0FBTztBQUN4QjtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsUUFBUTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixpQkFBZ0I7QUFDaEIsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxxQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixrQkFBaUI7QUFDakIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRSxJQUFJOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFFBQVEsVUFBVTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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UTtBQUNwQixhQUFZLE9BQU8sWUFBWTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFzQix5Q0FBeUM7QUFDL0Q7OztBQUdBO0FBQ0E7QUFDQSxzQ0FBcUMsT0FBTztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQixlQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCLGFBQVksT0FBTyxZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUMiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA1ZjlkM2VlMGM0Nzg0YmMyNmJjMVxuICoqLyIsInJlcXVpcmUoJy4vYXBwLmNzcycpO1xuXG52YXIgdmlldyA9IHJlcXVpcmUoJy4vdmlld3MvdmlldycpO1xudmFyIE1haW5NZW51ID0gcmVxdWlyZSgnLi92aWV3cy9tYWluTWVudS9tYWluTWVudScpO1xudmFyIEZyZWVwbGF5TWVudSA9IHJlcXVpcmUoJy4vdmlld3MvZnJlZXBsYXlNZW51L2ZyZWVwbGF5TWVudScpO1xudmFyIFB1enpsZU1lbnUgPSByZXF1aXJlKCcuL3ZpZXdzL3B1enpsZU1lbnUvcHV6emxlTWVudScpO1xudmFyIE1hcEVkaXRvciA9IHJlcXVpcmUoJy4vdmlld3MvbWFwRWRpdG9yL21hcEVkaXRvcicpO1xudmFyIEdhbWVHdWkgPSByZXF1aXJlKCcuL3ZpZXdzL2dhbWVHdWkvZ2FtZUd1aScpO1xudmFyIGF0dGFjaEZhc3RDbGljayA9IHJlcXVpcmUoJ2Zhc3RjbGljaycpO1xuXG52YXIgY3VycmVudFZpZXcgPSBuZXcgTWFpbk1lbnUoZGF0YSA9PiBvbkRvbmUoZGF0YSkpO1xuXG5mdW5jdGlvbiBvbkRvbmUoZGF0YSl7XG4gIGN1cnJlbnRWaWV3LmRpc3Bvc2UoKTtcbiAgdmlldy5yZXNldCgpO1xuXG4gIHN3aXRjaChkYXRhLnZpZXcpe1xuICAgIGNhc2UgJ01haW4gbWVudSc6XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBNYWluTWVudShkYXRhID0+IG9uRG9uZShkYXRhKSwgZGF0YS5wYXJhbXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUHV6emxlIG1lbnUnOlxuICAgICAgY3VycmVudFZpZXcgPSBuZXcgUHV6emxlTWVudShkYXRhID0+IG9uRG9uZShkYXRhKSwgZGF0YS5wYXJhbXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRnJlZXBsYXkgbWVudSc6XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBGcmVlcGxheU1lbnUoZGF0YSA9PiBvbkRvbmUoZGF0YSksIGRhdGEucGFyYW1zKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NyZWF0ZSBtYXAnOlxuICAgICAgY3VycmVudFZpZXcgPSBuZXcgTWFwRWRpdG9yKGRhdGEgPT4gb25Eb25lKGRhdGEpLCBkYXRhLnBhcmFtcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdHYW1lJzpcbiAgICAgIGN1cnJlbnRWaWV3ID0gbmV3IEdhbWVHdWkoZGF0YSA9PiBvbkRvbmUoZGF0YSksIGRhdGEucGFyYW1zKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBGcmVlcGxheU1lbnUoZGF0YSA9PiBvbkRvbmUoZGF0YSksIGRhdGEucGFyYW1zKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICBhdHRhY2hGYXN0Q2xpY2suYXR0YWNoKGRvY3VtZW50LmJvZHkpO1xufSwgZmFsc2UpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwLmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2FwcC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXRvdWNoLWFjdGlvbjogbm9uZTtcXG4gICAgICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICAtd2Via2l0LXVzZXItZHJhZzogbm9uZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gIG1hcmdpbjogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbmJvZHk6YmVmb3Jle1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICB0b3A6IDA7XFxuICBiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC44KTtcXG4gIHBvc2l0aW9uOi13ZWJraXQtc3RpY2t5O1xcbiAgcG9zaXRpb246c3RpY2t5O1xcbn1cXG5cXG4ubWVudSB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5pbmZvVGV4dCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDEuMnZ3O1xcbn1cXG5cXG4uYnV0dG9uIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xcbiAgY29sb3I6IHRlYWw7XFxuICBwYWRkaW5nOiAwLjNlbSAwLjVlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4uYnV0dG9uOmFmdGVyLCAuYnV0dG9uID4gKiB7XFxuICBtYXJnaW46IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIG1hcmdpbi1yaWdodDogLTUwJTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG59XFxuXFxuLm1pbnVzQnV0dG9uOmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCItXFxcIjtcXG59XFxuXFxuLnBsdXNCdXR0b246YWZ0ZXIge1xcbiAgICBjb250ZW50OiBcXFwiK1xcXCI7XFxufVxcbi5idXR0b24ucHVycGxlIHtcXG4gIGNvbG9yOiBwdXJwbGU7XFxuICBib3JkZXItY29sb3I6IHB1cnBsZTtcXG59XFxuXFxuLmJ1dHRvbi5ncmVlbiB7XFxuICBjb2xvcjogZ3JlZW47XFxuICBib3JkZXItY29sb3I6IGdyZWVuO1xcbn1cXG5cXG4uYnV0dG9uLnllbGxvdyB7XFxuICBjb2xvcjogeWVsbG93O1xcbiAgYm9yZGVyLWNvbG9yOiB5ZWxsb3c7XFxufVxcblxcbi5idXR0b24uc2VsZWN0ZWQge1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4uYnV0dG9uLmRpc2FibGVkIHtcXG4gIGNvbG9yOiBncmF5O1xcbiAgYm9yZGVyLWNvbG9yOiBncmF5O1xcbn1cXG5cXG5cXG5cXG4ubWVudUNsaWNrWm9uZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMzB2dztcXG59XFxuXFxuLm1lbnVDbGlja1pvbmUtdG9wTGVmdHtcXG4gIHRvcDogLTEwcHg7XFxuICBsZWZ0OiAtMTBweDtcXG59XFxuXFxuLm1lbnVDbGlja1pvbmUtdG9wUmlnaHR7XFxuICB0b3A6IC0xMHB4O1xcbiAgcmlnaHQ6IC0xMHB4O1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwLjI1dHVybik7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDAuMjV0dXJuKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMC4yNXR1cm4pO1xcbn1cXG5cXG4ubWVudUNsaWNrWm9uZS1lbmFibGVkIC5pY29ue1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuLm1lbnVCb3R0b217XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IC0xMHB4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDcwdnc7XFxufVxcblxcbi5tZW51Qm90dG9tQXJlYXtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4ubWVudUVsZW1lbnR7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBmaWxsOiByZ2JhKDAsIDEyOCwgMTI4LCAwLjIpO1xcbiAgc3Ryb2tlOiB3aGl0ZTtcXG4gIHN0cm9rZS13aWR0aDogMjtcXG4gIHZlY3Rvci1lZmZlY3Q6IG5vbi1zY2FsaW5nLXN0cm9rZTtcXG59XFxuXFxuLmljb257XFxuICBvcGFjaXR5OiAwLjE7XFxufVxcblxcbi5pY29uIHBhdGh7XFxuICB2ZWN0b3ItZWZmZWN0OiBub24tc2NhbGluZy1zdHJva2U7XFxuICBmaWxsOiB3aGl0ZTtcXG59XFxuXFxuLmljb24tdG9we1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogM3Z3O1xcbiAgdG9wOiAzdnc7XFxuICB3aWR0aDogNnZ3O1xcbn1cXG5cXG4uc3ZnTWVudSB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLnN2Z01lbnUgc3ZnID4gKiB7XFxuICBwb2ludGVyLWV2ZW50czogYXV0bztcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIhLi9zcmMvYXBwLmNzc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCgpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQoKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGhlYWQuYXBwZW5kQ2hpbGQobGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQoKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUGFwZXIgPSByZXF1aXJlKCdwYXBlcicpO1xudmFyIGNoYW5nZUNlbnRlciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5jaGFuZ2VDZW50ZXI7XG52YXIgY2hhbmdlWm9vbSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5jaGFuZ2Vab29tO1xudmFyIGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uJyk7XG52YXIgc3RvcmFnZSA9IHJlcXVpcmUoJy4uL3N0b3JhZ2UnKTtcblxudmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcbmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2tlZXBhbGl2ZScsIHRydWUpO1xuXG52YXIgd2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xudmFyIGhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xuXG5pbml0UGFwZXIoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KTtcblxudmFyIG91dGVyQm91bmRzID0gbmV3IFBhcGVyLlJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxudmFyIGNvdXJzZSA9IG5ldyBQYXBlci5Hcm91cChjcmVhdGVHcmlkKG91dGVyQm91bmRzKSk7XG5jb3Vyc2UuY2xpcHBlZCA9IHRydWU7XG5cbnZhciBpbml0aWFsQm91bmRzID0gUGFwZXIudmlldy5ib3VuZHMuY2xvbmUoKTtcblxuUGFwZXIudmlldy5kcmF3KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRWaWV3KGJvdW5kcyl7XG4gIGlmKGlzU2FtZUJvdW5kcyhQYXBlci52aWV3LmJvdW5kcywgYm91bmRzKSkgcmV0dXJuO1xuICB2YXIgYXNwZWN0UmF0aW8gPSB3aWR0aC9oZWlnaHQ7XG4gIHZhciBzaXplID0gYm91bmRzLnNpemUuY2xvbmUoKTtcbiAgdmFyIG5ld1JhdGlvID0gc2l6ZS53aWR0aC9zaXplLmhlaWdodDtcbiAgaWYobmV3UmF0aW8gIT09IGFzcGVjdFJhdGlvKXtcbiAgICBpZihuZXdSYXRpbyA8IGFzcGVjdFJhdGlvKXtcbiAgICAgIHNpemUud2lkdGggPSBzaXplLndpZHRoICogYXNwZWN0UmF0aW8vbmV3UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKiBuZXdSYXRpby9hc3BlY3RSYXRpbztcbiAgICB9XG4gIH1cbiAgdmFyIG5ld1pvb20gPSBQYXBlci52aWV3LnZpZXdTaXplLndpZHRoL3NpemUud2lkdGg7XG4gIG5ld1pvb20gPSBuZXdab29tID4gMSA/IG5ld1pvb20gOiAxO1xuICBhbmltYXRlVmlldyhib3VuZHMuY2VudGVyLCBuZXdab29tKTtcbiAgUGFwZXIudmlldy5kcmF3KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpe1xuICBzZXRWaWV3KGluaXRpYWxCb3VuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ291cnNlKGVsZW1lbnQpe1xuICBjb3Vyc2UuYXBwZW5kQm90dG9tKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBpbml0UGFwZXIoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KXtcbiAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCk7XG4gIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gIFBhcGVyLnNldHVwKGNhbnZhcyk7XG4gIGFuaW1hdGlvbi5pbml0KCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyaWQodmlld0JvdW5kcyl7XG4gIHZhciBncmlkID0gbmV3IFBhcGVyLkdyb3VwKCk7XG4gIGZvcih2YXIgeCA9IHZpZXdCb3VuZHMubGVmdDsgeCA8IHZpZXdCb3VuZHMucmlnaHQ7IHggKz0gMjApe1xuICAgIHZhciBsaW5lID0gbmV3IFBhcGVyLlBhdGguUmVjdGFuZ2xlKFxuICAgICAgbmV3IFBhcGVyLlBvaW50KHggLSAwLjUsIHZpZXdCb3VuZHMudG9wKSxcbiAgICAgIG5ldyBQYXBlci5Qb2ludCh4ICsgMC41LCBQYXBlci52aWV3LmJvdW5kcy5ib3R0b20pXG4gICAgKTtcbiAgICBsaW5lLmZpbGxDb2xvciA9ICd3aGl0ZSc7XG5cbiAgICBncmlkLmFkZENoaWxkKGxpbmUpO1xuICB9XG4gIGZvcih2YXIgeSA9IHZpZXdCb3VuZHMudG9wOyB5IDwgdmlld0JvdW5kcy5ib3R0b207IHkgKz0gMjApe1xuICAgIHZhciBsaW5lID0gbmV3IFBhcGVyLlBhdGguUmVjdGFuZ2xlKFxuICAgICAgbmV3IFBhcGVyLlBvaW50KHZpZXdCb3VuZHMubGVmdCwgeSksXG4gICAgICBuZXcgUGFwZXIuUG9pbnQoUGFwZXIudmlldy5ib3VuZHMucmlnaHQsIHkgKyAxKVxuICAgICk7XG4gICAgbGluZS5maWxsQ29sb3IgPSAnd2hpdGUnO1xuXG4gICAgZ3JpZC5hZGRDaGlsZChsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBncmlkO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVCb3VuZHModmlldzEsIHZpZXcyKXtcbiAgdmFyIGRpZmYgPSB2aWV3MS5jZW50ZXIuc3VidHJhY3QodmlldzIuY2VudGVyKS5sZW5ndGhcbiAgcmV0dXJuIGRpZmYgPCAxO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlVmlldyhjZW50ZXIsIHpvb20pe1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb24gPSAwLjM7XG4gIHZhciBzdGFydENlbnRlciA9IFBhcGVyLnZpZXcuY2VudGVyLmNsb25lKCk7XG4gIHZhciBkZWx0YUNlbnRlciA9IGNlbnRlci5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0Q2VudGVyKTtcbiAgdmFyIHN0YXJ0Wm9vbSA9IFBhcGVyLnZpZXcuem9vbTtcbiAgdmFyIGRlbHRhWm9vbSA9IHpvb20gLSBzdGFydFpvb207XG4gIGFuaW1hdGlvbi5hZGQoZWxhcHNlZFRpbWUgPT4ge1xuICAgIGlmKGVsYXBzZWRUaW1lID4gYW5pbWF0aW9uRHVyYXRpb24pe1xuICAgICAgUGFwZXIudmlldy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgICBQYXBlci52aWV3Lnpvb20gPSB6b29tO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWFzZVZhbHVlID0gZWxhcHNlZFRpbWUvYW5pbWF0aW9uRHVyYXRpb247XG4gICAgICB2YXIgZHRDZW50ZXIgPSBkZWx0YUNlbnRlci5tdWx0aXBseShlYXNlVmFsdWUpO1xuICAgICAgUGFwZXIudmlldy5jZW50ZXIgPSBzdGFydENlbnRlci5hZGQoZHRDZW50ZXIpO1xuICAgICAgdmFyIGR0Wm9vbSA9IGRlbHRhWm9vbSAqIGVhc2VWYWx1ZTtcbiAgICAgIFBhcGVyLnZpZXcuem9vbSA9IHN0YXJ0Wm9vbSArIGR0Wm9vbTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgc3RhcnMgPSBbXTtcblxuY3JlYXRlU3RhcnMoKTtcbmlmKHN0b3JhZ2UuR2V0RW5hYmxlU3RhcnMoKSkge1xuICBlbmFibGVTdGFycygpO1xufSBlbHNlIHtcbiAgZGlzYWJsZVN0YXJzKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXJzKCkge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwOyBpKyspe1xuICAgIHZhciBzdGFyID0gY3JlYXRlU3RhcigpO1xuICAgIHN0YXJzLnB1c2goc3Rhcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RhcnMoKSB7XG4gIHN0YXJzLmZvckVhY2goc3RhciA9PiB7XG4gICAgc3Rhci5jaXJjbGUudmlzaWJsZSA9IHRydWU7XG4gICAgc3Rhci5hbmltYXRpb25SZW1vdmVyID0gYW5pbWF0aW9uLmFkZChzdGFyLmFuaW1hdGlvbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlU3RhcnMoKSB7XG4gIHN0YXJzLmZvckVhY2goc3RhciA9PiB7XG4gICAgc3Rhci5jaXJjbGUudmlzaWJsZSA9IGZhbHNlO1xuICAgIGlmKHN0YXIuYW5pbWF0aW9uUmVtb3Zlcikge1xuICAgICAgc3Rhci5hbmltYXRpb25SZW1vdmVyLnJlbW92ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVTdGFyc1Zpc2liaWxpdHkoKXtcbiAgdmFyIHN0YXJzRW5hYmxlZCA9ICFzdG9yYWdlLkdldEVuYWJsZVN0YXJzKCk7XG4gIHN0b3JhZ2UuU2V0RW5hYmxlU3RhcnMoc3RhcnNFbmFibGVkKTtcblxuICBpZihzdGFyc0VuYWJsZWQpIHtcbiAgICBlbmFibGVTdGFycygpO1xuICB9IGVsc2Uge1xuICAgIGRpc2FibGVTdGFycygpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJzRW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RhcigpIHtcbiAgLy8gYSByYW5kb20gcG9zaXRpb24gYW55d2hlcmUgaW4gc3BhY2VcbiAgdmFyIHN0YXJ0ID0gbmV3IFBhcGVyLlBvaW50LnJhbmRvbSgpLm11bHRpcGx5KG91dGVyQm91bmRzLmJvdHRvbVJpZ2h0KTtcblxuICAvLyBkaXN0YW5jZSBmcm9tIGVhcnRoIGluIHBpeGVsc1xuICB2YXIgZGlzdGFuY2UgPSA0ICsgTWF0aC5yYW5kb20oKSAqIDExO1xuXG4gIHZhciBjaXJjbGUgPSBuZXcgUGFwZXIuUGF0aC5DaXJjbGUoc3RhcnQsIDUgLyBkaXN0YW5jZSk7XG4gIGNpcmNsZS5maWxsQ29sb3IgPSAnd2hpdGUnO1xuICBjaXJjbGUucG9zaXRpb24gPSBzdGFydDtcblxuICAvLyB0aGUgc3BlZWQgb2YgYSBzdGFyIGlzIGxvd2VyIGlmIGl0cyBmYXIgYXdheS4gdGhpcyBpcyBrbm93biBzY2llbmNlIGZhY3QuXG4gIHZhciB2ZWxvY2l0eSA9IG5ldyBQYXBlci5Qb2ludCgxMCAvIGRpc3RhbmNlLCAwKTtcblxuICByZXR1cm4ge1xuICAgIGNpcmNsZTogY2lyY2xlLFxuICAgIHZlbG9jaXR5OiB2ZWxvY2l0eSxcbiAgICBhbmltYXRpb246IGVsYXBzZWRUaW1lID0+IHtcbiAgICAgIGNpcmNsZS5wb3NpdGlvbiA9IGNpcmNsZS5wb3NpdGlvbi5hZGQodmVsb2NpdHkpO1xuICAgICAgaWYoIW91dGVyQm91bmRzLmNvbnRhaW5zKGNpcmNsZS5wb3NpdGlvbikpe1xuICAgICAgICBjaXJjbGUucG9zaXRpb24ueCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdmlld3Mvdmlldy5qc1xuICoqLyIsIi8qIVxuICogUGFwZXIuanMgdjAuOS4yNSAtIFRoZSBTd2lzcyBBcm15IEtuaWZlIG9mIFZlY3RvciBHcmFwaGljcyBTY3JpcHRpbmcuXG4gKiBodHRwOi8vcGFwZXJqcy5vcmcvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAxNCwgSnVlcmcgTGVobmkgJiBKb25hdGhhbiBQdWNrZXlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vICYgaHR0cDovL2pvbmF0aGFucHVja2V5LmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBTdW4gT2N0IDI1IDExOjIzOjM4IDIwMTUgKzAxMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAxMyBKdWVyZyBMZWhuaVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuXG52YXIgcGFwZXIgPSBuZXcgZnVuY3Rpb24odW5kZWZpbmVkKSB7XG5cbnZhciBCYXNlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGlkZGVuID0gL14oc3RhdGljc3xlbnVtZXJhYmxlfGJlYW5zfHByZXNlcnZlKSQvLFxuXG5cdFx0Zm9yRWFjaCA9IFtdLmZvckVhY2ggfHwgZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRmb3JJbiA9IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdGhpcylcblx0XHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRyZXR1cm4geyBfX3Byb3RvX186IHByb3RvIH07XG5cdFx0fSxcblxuXHRcdGRlc2NyaWJlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBmdW5jdGlvbihvYmosIG5hbWUpIHtcblx0XHRcdHZhciBnZXQgPSBvYmouX19sb29rdXBHZXR0ZXJfXyAmJiBvYmouX19sb29rdXBHZXR0ZXJfXyhuYW1lKTtcblx0XHRcdHJldHVybiBnZXRcblx0XHRcdFx0XHQ/IHsgZ2V0OiBnZXQsIHNldDogb2JqLl9fbG9va3VwU2V0dGVyX18obmFtZSksXG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuXHRcdFx0XHRcdDogb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG5cdFx0XHRcdFx0XHQ/IHsgdmFsdWU6IG9ialtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdF9kZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRpZiAoKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSAmJiBvYmouX19kZWZpbmVHZXR0ZXJfXykge1xuXHRcdFx0XHRpZiAoZGVzYy5nZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lR2V0dGVyX18obmFtZSwgZGVzYy5nZXQpO1xuXHRcdFx0XHRpZiAoZGVzYy5zZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lU2V0dGVyX18obmFtZSwgZGVzYy5zZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqW25hbWVdID0gZGVzYy52YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0ZGVsZXRlIG9ialtuYW1lXTtcblx0XHRcdHJldHVybiBfZGVmaW5lKG9iaiwgbmFtZSwgZGVzYyk7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcblx0XHR2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG5cdFx0XHR2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpXG5cdFx0XHRcdFx0JiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKVxuXHRcdFx0XHR2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcblx0XHRcdHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRyZXMgPSB2YWwsXG5cdFx0XHRcdHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmMgJiYgIXZhbC5iYXNlXG5cdFx0XHRcdFx0XHQ/ICh2YWwgJiYgdmFsLmdldCA/IG5hbWUgaW4gZGVzdCA6IGRlc3RbbmFtZV0pXG5cdFx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHRcdGJlYW47XG5cdFx0XHRpZiAoIXByZXNlcnZlIHx8ICFwcmV2KSB7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgcHJldilcblx0XHRcdFx0XHR2YWwuYmFzZSA9IHByZXY7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgYmVhbnMgIT09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiAoYmVhbiA9IG5hbWUubWF0Y2goL14oW2dzXWV0fGlzKSgoW0EtWl0pKC4qKSkkLykpKVxuXHRcdFx0XHRcdGJlYW5zTmFtZXNbYmVhblszXS50b0xvd2VyQ2FzZSgpICsgYmVhbls0XV0gPSBiZWFuWzJdO1xuXHRcdFx0XHRpZiAoIXJlcyB8fCBpc0Z1bmMgfHwgIXJlcy5nZXQgfHwgdHlwZW9mIHJlcy5nZXQgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdHx8ICFCYXNlLmlzUGxhaW5PYmplY3QocmVzKSlcblx0XHRcdFx0XHRyZXMgPSB7IHZhbHVlOiByZXMsIHdyaXRhYmxlOiB0cnVlIH07XG5cdFx0XHRcdGlmICgoZGVzY3JpYmUoZGVzdCwgbmFtZSlcblx0XHRcdFx0XHRcdHx8IHsgY29uZmlndXJhYmxlOiB0cnVlIH0pLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRcdHJlcy5jb25maWd1cmFibGUgPSB0cnVlO1xuXHRcdFx0XHRcdHJlcy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZpbmUoZGVzdCwgbmFtZSwgcmVzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcblx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhaGlkZGVuLnRlc3QobmFtZSkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGJlYW5zTmFtZXMpIHtcblx0XHRcdFx0dmFyIHBhcnQgPSBiZWFuc05hbWVzW25hbWVdLFxuXHRcdFx0XHRcdHNldCA9IGRlc3RbJ3NldCcgKyBwYXJ0XSxcblx0XHRcdFx0XHRnZXQgPSBkZXN0WydnZXQnICsgcGFydF0gfHwgc2V0ICYmIGRlc3RbJ2lzJyArIHBhcnRdO1xuXHRcdFx0XHRpZiAoZ2V0ICYmIChiZWFucyA9PT0gdHJ1ZSB8fCBnZXQubGVuZ3RoID09PSAwKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lLCB7IGdldDogZ2V0LCBzZXQ6IHNldCB9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRlc3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgYmluZCkge1xuXHRcdGlmIChvYmopXG5cdFx0XHQoJ2xlbmd0aCcgaW4gb2JqICYmICFvYmouZ2V0TGVuZ3RoXG5cdFx0XHRcdFx0JiYgdHlwZW9mIG9iai5sZW5ndGggPT09ICdudW1iZXInXG5cdFx0XHRcdD8gZm9yRWFjaFxuXHRcdFx0XHQ6IGZvckluKS5jYWxsKG9iaiwgaXRlciwgYmluZCA9IGJpbmQgfHwgb2JqKTtcblx0XHRyZXR1cm4gYmluZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldChvYmosIHByb3BzLCBleGNsdWRlKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHByb3BzKVxuXHRcdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiYgIShleGNsdWRlICYmIGV4Y2x1ZGVba2V5XSkpXG5cdFx0XHRcdG9ialtrZXldID0gcHJvcHNba2V5XTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0cmV0dXJuIGluamVjdChmdW5jdGlvbiBCYXNlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNldCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuXHR9LCB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbihzcmMpIHtcblx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0dmFyIHN0YXRpY3MgPSBzcmMuc3RhdGljcyA9PT0gdHJ1ZSA/IHNyYyA6IHNyYy5zdGF0aWNzLFxuXHRcdFx0XHRcdGJlYW5zID0gc3JjLmJlYW5zLFxuXHRcdFx0XHRcdHByZXNlcnZlID0gc3JjLnByZXNlcnZlO1xuXHRcdFx0XHRpZiAoc3RhdGljcyAhPT0gc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLnByb3RvdHlwZSwgc3JjLCBzcmMuZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdFx0aW5qZWN0KHRoaXMsIHN0YXRpY3MsIHRydWUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuaW5qZWN0KGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBiYXNlID0gdGhpcyxcblx0XHRcdFx0Y3Rvcixcblx0XHRcdFx0cHJvdG87XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmIChjdG9yID0gYXJndW1lbnRzW2ldLmluaXRpYWxpemUpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjdG9yID0gY3RvciB8fCBmdW5jdGlvbigpIHtcblx0XHRcdFx0YmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHRcdHByb3RvID0gY3Rvci5wcm90b3R5cGUgPSBjcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0ZGVmaW5lKHByb3RvLCAnY29uc3RydWN0b3InLFxuXHRcdFx0XHRcdHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRpbmplY3QoY3RvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5pbmplY3QuYXBwbHkoY3RvciwgYXJndW1lbnRzKTtcblx0XHRcdGN0b3IuYmFzZSA9IGJhc2U7XG5cdFx0XHRyZXR1cm4gY3Rvcjtcblx0XHR9XG5cdH0sIHRydWUpLmluamVjdCh7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBzcmMuYmVhbnMsIHNyYy5wcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0XHRyZXR1cm4gc2V0KHRoaXMsIHByb3BzKTtcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRlYWNoOiBlYWNoLFxuXHRcdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0XHRkZWZpbmU6IGRlZmluZSxcblx0XHRcdGRlc2NyaWJlOiBkZXNjcmliZSxcblx0XHRcdHNldDogc2V0LFxuXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBzZXQobmV3IG9iai5jb25zdHJ1Y3RvcigpLCBvYmopO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHZhciBjdG9yID0gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gY3RvciAmJiAoY3RvciA9PT0gT2JqZWN0IHx8IGN0b3IgPT09IEJhc2Vcblx0XHRcdFx0XHRcdHx8IGN0b3IubmFtZSA9PT0gJ09iamVjdCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0cGljazogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYSAhPT0gdW5kZWZpbmVkID8gYSA6IGI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJylcblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG5CYXNlLmluamVjdCh7XG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQgIT0gbnVsbFxuXHRcdFx0PyAgKHRoaXMuX2NsYXNzIHx8ICdPYmplY3QnKSArICh0aGlzLl9uYW1lXG5cdFx0XHRcdD8gXCIgJ1wiICsgdGhpcy5fbmFtZSArIFwiJ1wiXG5cdFx0XHRcdDogJyBAJyArIHRoaXMuX2lkKVxuXHRcdFx0OiAneyAnICsgQmFzZS5lYWNoKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0aWYgKCEvXl8vLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsgKHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHRcdD8gRm9ybWF0dGVyLmluc3RhbmNlLm51bWJlcih2YWx1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IHZhbHVlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtdKS5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRnZXRDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGFzcyB8fCAnJztcblx0fSxcblxuXHRleHBvcnRKU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXhwb3J0SlNPTih0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzKTtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbihwcm9wcywgZXhjbHVkZSwgZG9udENoZWNrKSB7XG5cdFx0aWYgKHByb3BzICYmIChkb250Q2hlY2sgfHwgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSkpIHtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMuX2ZpbHRlcmluZyB8fCBwcm9wcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRpZiAoIShleGNsdWRlICYmIGV4Y2x1ZGVba2V5XSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cblx0XHRleHBvcnRzOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdFx0dmFyIHJlcyA9IGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG5cdFx0XHRcdG5hbWUgPSByZXMucHJvdG90eXBlLl9jbGFzcztcblx0XHRcdGlmIChuYW1lICYmICFCYXNlLmV4cG9ydHNbbmFtZV0pXG5cdFx0XHRcdEJhc2UuZXhwb3J0c1tuYW1lXSA9IHJlcztcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aWYgKG9iajEgJiYgb2JqMS5lcXVhbHMpXG5cdFx0XHRcdHJldHVybiBvYmoxLmVxdWFscyhvYmoyKTtcblx0XHRcdGlmIChvYmoyICYmIG9iajIuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMi5lcXVhbHMob2JqMSk7XG5cdFx0XHRpZiAob2JqMSAmJiBvYmoyXG5cdFx0XHRcdFx0JiYgdHlwZW9mIG9iajEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmoxKSAmJiBBcnJheS5pc0FycmF5KG9iajIpKSB7XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IG9iajEubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChsZW5ndGggIT09IG9iajIubGVuZ3RoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyhvYmoxW2xlbmd0aF0sIG9iajJbbGVuZ3RoXSkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmoxKSxcblx0XHRcdFx0XHRcdGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aClcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2xlbmd0aF07XG5cdFx0XHRcdFx0XHRpZiAoIShvYmoyLmhhc093blByb3BlcnR5KGtleSlcblx0XHRcdFx0XHRcdFx0XHQmJiBCYXNlLmVxdWFscyhvYmoxW2tleV0sIG9iajJba2V5XSkpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRyZWFkOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcyA9PT0gQmFzZSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuXHRcdFx0XHRsaXN0Ll9faW5kZXgrKztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG5cdFx0XHRcdHJlYWRJbmRleCA9IHByb3RvLl9yZWFkSW5kZXgsXG5cdFx0XHRcdGluZGV4ID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwO1xuXHRcdFx0aWYgKCFsZW5ndGgpXG5cdFx0XHRcdGxlbmd0aCA9IGxpc3QubGVuZ3RoIC0gaW5kZXg7XG5cdFx0XHR2YXIgb2JqID0gbGlzdFtpbmRleF07XG5cdFx0XHRpZiAob2JqIGluc3RhbmNlb2YgdGhpc1xuXHRcdFx0XHR8fCBvcHRpb25zICYmIG9wdGlvbnMucmVhZE51bGwgJiYgb2JqID09IG51bGwgJiYgbGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0XHRsaXN0Ll9faW5kZXggPSBpbmRleCArIDE7XG5cdFx0XHRcdHJldHVybiBvYmogJiYgb3B0aW9ucyAmJiBvcHRpb25zLmNsb25lID8gb2JqLmNsb25lKCkgOiBvYmo7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSBCYXNlLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRvYmouX19yZWFkID0gdHJ1ZTtcblx0XHRcdG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgaW5kZXggPiAwIHx8IGxlbmd0aCA8IGxpc3QubGVuZ3RoXG5cdFx0XHRcdD8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaW5kZXgsIGluZGV4ICsgbGVuZ3RoKVxuXHRcdFx0XHQ6IGxpc3QpIHx8IG9iajtcblx0XHRcdGlmIChyZWFkSW5kZXgpIHtcblx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyBvYmouX19yZWFkO1xuXHRcdFx0XHRvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0cGVlazogZnVuY3Rpb24obGlzdCwgc3RhcnQpIHtcblx0XHRcdHJldHVybiBsaXN0W2xpc3QuX19pbmRleCA9IHN0YXJ0IHx8IGxpc3QuX19pbmRleCB8fCAwXTtcblx0XHR9LFxuXG5cdFx0cmVtYWluOiBmdW5jdGlvbihsaXN0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuXHRcdH0sXG5cblx0XHRyZWFkQWxsOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHJlcyA9IFtdLFxuXHRcdFx0XHRlbnRyeTtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydCB8fCAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pXG5cdFx0XHRcdFx0XHQ/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucylcblx0XHRcdFx0XHRcdDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdHJlYWROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKSxcblx0XHRcdFx0aGFzT2JqZWN0ID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblx0XHRcdGlmIChoYXNPYmplY3QpIHtcblx0XHRcdFx0dmFyIGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQ7XG5cdFx0XHRcdGlmICghZmlsdGVyZWQpIHtcblx0XHRcdFx0XHRmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUobGlzdFswXSk7XG5cdFx0XHRcdFx0ZmlsdGVyZWQuX2ZpbHRlcmluZyA9IGxpc3RbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGhhc09iamVjdCA/IFt2YWx1ZV0gOiBsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKTtcblx0XHR9LFxuXG5cdFx0Z2V0TmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHZhciBhcmcgPSBsaXN0WzBdO1xuXHRcdFx0aWYgKGxpc3QuX2hhc09iamVjdCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRsaXN0Ll9oYXNPYmplY3QgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QpXG5cdFx0XHRcdHJldHVybiBuYW1lID8gYXJnW25hbWVdIDogbGlzdC5fZmlsdGVyZWQgfHwgYXJnO1xuXHRcdH0sXG5cblx0XHRoYXNOYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0aXNQbGFpblZhbHVlOiBmdW5jdGlvbihvYmosIGFzU3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopXG5cdFx0XHRcdFx0fHwgYXNTdHJpbmcgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5cdFx0fSxcblxuXHRcdHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0dmFyIHJvb3QgPSAhZGljdGlvbmFyeSxcblx0XHRcdFx0cmVzO1xuXHRcdFx0aWYgKHJvb3QpIHtcblx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdFx0ZGljdGlvbmFyeSA9IHtcblx0XHRcdFx0XHRsZW5ndGg6IDAsXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnM6IHt9LFxuXHRcdFx0XHRcdHJlZmVyZW5jZXM6IHt9LFxuXHRcdFx0XHRcdGFkZDogZnVuY3Rpb24oaXRlbSwgY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcblx0XHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblx0XHRcdFx0XHRcdGlmICghcmVmKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0XHRcdFx0XHRcdHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gaXRlbS5fY2xhc3M7XG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWZpbml0aW9uc1tpZF0gPSByZXM7XG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG5cdFx0XHRcdHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR2YXIgbmFtZSA9IG9iai5fY2xhc3M7XG5cdFx0XHRcdGlmIChuYW1lICYmICFjb21wYWN0ICYmICFyZXMuX2NvbXBhY3QgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdHJlcy51bnNoaWZ0KG5hbWUpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHRpZiAoY29tcGFjdClcblx0XHRcdFx0XHRyZXMuX2NvbXBhY3QgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuXHRcdFx0XHRyZXMgPSB7fTtcblx0XHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpba2V5XSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzID0gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG5cdFx0XHRcdFx0PyBbWydkaWN0aW9uYXJ5JywgZGljdGlvbmFyeS5kZWZpbml0aW9uc10sIHJlc11cblx0XHRcdFx0XHQ6IHJlcztcblx0XHR9LFxuXG5cdFx0ZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGpzb24sIGNyZWF0ZSwgX2RhdGEsIF9pc0RpY3Rpb25hcnkpIHtcblx0XHRcdHZhciByZXMgPSBqc29uLFxuXHRcdFx0XHRpc1Jvb3QgPSAhX2RhdGE7XG5cdFx0XHRfZGF0YSA9IF9kYXRhIHx8IHt9O1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBqc29uWzBdLFxuXHRcdFx0XHRcdGlzRGljdGlvbmFyeSA9IHR5cGUgPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRcdFx0aWYgKGpzb24ubGVuZ3RoID09IDEgJiYgL14jLy50ZXN0KHR5cGUpKVxuXHRcdFx0XHRcdHJldHVybiBfZGF0YS5kaWN0aW9uYXJ5W3R5cGVdO1xuXHRcdFx0XHR0eXBlID0gQmFzZS5leHBvcnRzW3R5cGVdO1xuXHRcdFx0XHRyZXMgPSBbXTtcblx0XHRcdFx0aWYgKF9pc0RpY3Rpb25hcnkpXG5cdFx0XHRcdFx0X2RhdGEuZGljdGlvbmFyeSA9IHJlcztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHR5cGUgPyAxIDogMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlcy5wdXNoKEJhc2UuZGVzZXJpYWxpemUoanNvbltpXSwgY3JlYXRlLCBfZGF0YSxcblx0XHRcdFx0XHRcdFx0aXNEaWN0aW9uYXJ5KSk7XG5cdFx0XHRcdGlmICh0eXBlKSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSByZXM7XG5cdFx0XHRcdFx0aWYgKGNyZWF0ZSkge1xuXHRcdFx0XHRcdFx0cmVzID0gY3JlYXRlKHR5cGUsIGFyZ3MpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBCYXNlLmNyZWF0ZSh0eXBlLnByb3RvdHlwZSk7XG5cdFx0XHRcdFx0XHR0eXBlLmFwcGx5KHJlcywgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChqc29uKSkge1xuXHRcdFx0XHRyZXMgPSB7fTtcblx0XHRcdFx0aWYgKF9pc0RpY3Rpb25hcnkpXG5cdFx0XHRcdFx0X2RhdGEuZGljdGlvbmFyeSA9IHJlcztcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGpzb24pXG5cdFx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLmRlc2VyaWFsaXplKGpzb25ba2V5XSwgY3JlYXRlLCBfZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXNSb290ICYmIGpzb24gJiYganNvbi5sZW5ndGggJiYganNvblswXVswXSA9PT0gJ2RpY3Rpb25hcnknXG5cdFx0XHRcdFx0PyByZXNbMV1cblx0XHRcdFx0XHQ6IHJlcztcblx0XHR9LFxuXG5cdFx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIganNvbiA9IEJhc2Uuc2VyaWFsaXplKG9iaiwgb3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID09PSBmYWxzZVxuXHRcdFx0XHRcdD8ganNvblxuXHRcdFx0XHRcdDogSlNPTi5zdHJpbmdpZnkoanNvbik7XG5cdFx0fSxcblxuXHRcdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24sIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIEJhc2UuZGVzZXJpYWxpemUoXG5cdFx0XHRcdFx0dHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24sXG5cdFx0XHRcdFx0ZnVuY3Rpb24odHlwZSwgYXJncykge1xuXHRcdFx0XHRcdFx0dmFyIG9iaiA9IHRhcmdldCAmJiB0YXJnZXQuY29uc3RydWN0b3IgPT09IHR5cGVcblx0XHRcdFx0XHRcdFx0XHQ/IHRhcmdldFxuXHRcdFx0XHRcdFx0XHRcdDogQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpLFxuXHRcdFx0XHRcdFx0XHRpc1RhcmdldCA9IG9iaiA9PT0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIG9iaiBpbnN0YW5jZW9mIEl0ZW1cblx0XHRcdFx0XHRcdFx0XHQmJiAoaXNUYXJnZXQgfHwgIShvYmogaW5zdGFuY2VvZiBMYXllcikpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmcgPSBhcmdzWzBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpXG5cdFx0XHRcdFx0XHRcdFx0YXJnLmluc2VydCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShvYmosIGFyZ3MpO1xuXHRcdFx0XHRcdFx0aWYgKGlzVGFyZ2V0KVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c3BsaWNlOiBmdW5jdGlvbihsaXN0LCBpdGVtcywgaW5kZXgsIHJlbW92ZSkge1xuXHRcdFx0dmFyIGFtb3VudCA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcblx0XHRcdFx0YXBwZW5kID0gaW5kZXggPT09IHVuZGVmaW5lZDtcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcblx0XHRcdGlmIChpbmRleCA+IGxpc3QubGVuZ3RoKVxuXHRcdFx0XHRpbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcblx0XHRcdFx0aXRlbXNbaV0uX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0XHRsaXN0LnB1c2guYXBwbHkobGlzdCwgaXRlbXMpO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IFtpbmRleCwgcmVtb3ZlXTtcblx0XHRcdFx0aWYgKGl0ZW1zKVxuXHRcdFx0XHRcdGFyZ3MucHVzaC5hcHBseShhcmdzLCBpdGVtcyk7XG5cdFx0XHRcdHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVtb3ZlZFtpXS5faW5kZXggPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGxpc3RbaV0uX2luZGV4ID0gaTtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9cXGJbYS16XS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRjYW1lbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24oYWxsLCBjaHIpIHtcblx0XHRcdFx0cmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGh5cGhlbmF0ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIEVtaXR0ZXIgPSB7XG5cdG9uOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5vbihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0XHRlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblx0XHRcdGlmIChoYW5kbGVycy5pbmRleE9mKGZ1bmMpID09PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0aWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMVxuXHRcdFx0XHRcdCYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkudW5pbnN0YWxsKVxuXHRcdFx0XHRcdGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b25jZTogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5vZmYodHlwZSwgZnVuYyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0ZW1pdDogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmICghaGFuZGxlcnMpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aGFuZGxlcnMgPSBoYW5kbGVycy5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChldmVudCAmJiBldmVudC5zdG9wKVxuXHRcdFx0XHRcdGV2ZW50LnN0b3AoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHJlc3BvbmRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuXHR9LFxuXG5cdGF0dGFjaDogJyNvbicsXG5cdGRldGFjaDogJyNvZmYnLFxuXHRmaXJlOiAnI2VtaXQnLFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbihpbnN0YWxsKSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzLFxuXHRcdFx0a2V5ID0gaW5zdGFsbCA/ICdpbnN0YWxsJyA6ICd1bmluc3RhbGwnO1xuXHRcdGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcblx0XHRcdGlmIChoYW5kbGVyc1t0eXBlXS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRmdW5jID0gZW50cnkgJiYgZW50cnlba2V5XTtcblx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbiBpbmplY3Qoc3JjKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gc3JjLl9ldmVudHM7XG5cdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHt9O1xuXHRcdFx0XHRCYXNlLmVhY2goZXZlbnRzLCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdFx0XHRcdFx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuXHRcdFx0XHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0XHRcdHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuXHRcdFx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdFx0XHRcdHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdFx0dmFyIHByZXYgPSB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYpXG5cdFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIHByZXYpO1xuXHRcdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRcdHRoaXMub24odHlwZSwgZnVuYyk7XG5cdFx0XHRcdFx0XHR0aGlzW25hbWVdID0gZnVuYztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c3JjLl9ldmVudFR5cGVzID0gdHlwZXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5qZWN0LmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXBlclNjb3BlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnNldHRpbmdzID0gbmV3IEJhc2Uoe1xuXHRcdFx0YXBwbHlNYXRyaXg6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMucGFsZXR0ZXMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0cHJvdG8uc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5icm93c2VyKSB7XG5cdFx0XHR2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdHBsYXRmb3JtID0gKC8od2luKS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IC8obWFjKS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IC8obGludXgpLy5leGVjKGFnZW50KVxuXHRcdFx0XHRcdFx0fHwgW10pWzBdLFxuXHRcdFx0XHRicm93c2VyID0gcHJvdG8uYnJvd3NlciA9IHsgcGxhdGZvcm06IHBsYXRmb3JtIH07XG5cdFx0XHRpZiAocGxhdGZvcm0pXG5cdFx0XHRcdGJyb3dzZXJbcGxhdGZvcm1dID0gdHJ1ZTtcblx0XHRcdGFnZW50LnJlcGxhY2UoXG5cdFx0XHRcdC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbSlcXC8/XFxzKihbLlxcZF0rKSg/Oi4qdmVyc2lvblxcLyhbLlxcZF0rKSk/KD86LipydlxcOihbLlxcZF0rKSk/L2csXG5cdFx0XHRcdGZ1bmN0aW9uKGFsbCwgbiwgdjEsIHYyLCBydikge1xuXHRcdFx0XHRcdGlmICghYnJvd3Nlci5jaHJvbWUpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDogdjE7XG5cdFx0XHRcdFx0XHRpZiAobiA9PT0gJ3RyaWRlbnQnKSB7XG5cdFx0XHRcdFx0XHRcdHYgPSBydjtcblx0XHRcdFx0XHRcdFx0biA9ICdtc2llJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyb3dzZXIudmVyc2lvbiA9IHY7XG5cdFx0XHRcdFx0XHRicm93c2VyLnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0XHRcdFx0YnJvd3Nlci5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGJyb3dzZXJbbl0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHRcdGlmIChicm93c2VyLmNocm9tZSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIud2Via2l0O1xuXHRcdFx0aWYgKGJyb3dzZXIuYXRvbSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIuY2hyb21lO1xuXHRcdH1cblx0fSxcblxuXHR2ZXJzaW9uOiBcIjAuOS4yNVwiLFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByb2plY3QgJiYgdGhpcy5wcm9qZWN0LmdldFZpZXcoKTtcblx0fSxcblxuXHRnZXRQYXBlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhlY3V0ZTogZnVuY3Rpb24oY29kZSwgdXJsLCBvcHRpb25zKSB7XG5cdFx0cGFwZXIuUGFwZXJTY3JpcHQuZXhlY3V0ZShjb2RlLCB0aGlzLCB1cmwsIG9wdGlvbnMpO1xuXHRcdFZpZXcudXBkYXRlRm9jdXMoKTtcblx0fSxcblxuXHRpbnN0YWxsOiBmdW5jdGlvbihzY29wZSkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRCYXNlLmVhY2goWydwcm9qZWN0JywgJ3ZpZXcnLCAndG9vbCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdEJhc2UuZGVmaW5lKHNjb3BlLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGF0W2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzKVxuXHRcdFx0aWYgKCEvXl8vLnRlc3Qoa2V5KSAmJiB0aGlzW2tleV0pXG5cdFx0XHRcdHNjb3BlW2tleV0gPSB0aGlzW2tleV07XG5cdH0sXG5cblx0c2V0dXA6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbmV3IFByb2plY3QoZWxlbWVudCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucHJvamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnByb2plY3RzW2ldLnJlbW92ZSgpO1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnRvb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy50b29sc1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5wYWxldHRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMucGFsZXR0ZXNbaV0ucmVtb3ZlKCk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0ZGVsZXRlIFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF07XG5cdH0sXG5cblx0c3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRuYW1lICs9ICdBdHRyaWJ1dGUnO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG5cdFx0XHRcdHJldHVybiBlbFtuYW1lXShhdHRyKSB8fCBlbFtuYW1lXSgnZGF0YS1wYXBlci0nICsgYXR0cik7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRfc2NvcGVzOiB7fSxcblx0XHRcdF9pZDogMCxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2NvcGVzW2lkXSB8fCBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2dldCcpLFxuXHRcdFx0aGFzQXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2hhcycpXG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBQYXBlclNjb3BlSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihhY3RpdmF0ZSkge1xuXHRcdHRoaXMuX3Njb3BlID0gcGFwZXI7XG5cdFx0dGhpcy5faW5kZXggPSB0aGlzLl9zY29wZVt0aGlzLl9saXN0XS5wdXNoKHRoaXMpIC0gMTtcblx0XHRpZiAoYWN0aXZhdGUgfHwgIXRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0pXG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fc2NvcGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHByZXYgPSB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdO1xuXHRcdGlmIChwcmV2ICYmIHByZXYgIT09IHRoaXMpXG5cdFx0XHRwcmV2LmVtaXQoJ2RlYWN0aXZhdGUnKTtcblx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gdGhpcztcblx0XHR0aGlzLmVtaXQoJ2FjdGl2YXRlJywgcHJldik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09PSB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2luZGV4ID09IG51bGwpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0QmFzZS5zcGxpY2UodGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRpZiAodGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PSB0aGlzKVxuXHRcdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IG51bGw7XG5cdFx0dGhpcy5fc2NvcGUgPSBudWxsO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIEZvcm1hdHRlciA9IEJhc2UuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cdFx0dGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgNTtcblx0XHR0aGlzLm11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgdGhpcy5wcmVjaXNpb24pO1xuXHR9LFxuXG5cdG51bWJlcjogZnVuY3Rpb24odmFsKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQodmFsICogdGhpcy5tdWx0aXBsaWVyKSAvIHRoaXMubXVsdGlwbGllcjtcblx0fSxcblxuXHRwYWlyOiBmdW5jdGlvbih2YWwxLCB2YWwyLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsMSkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwyKTtcblx0fSxcblxuXHRwb2ludDogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLngpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsLnkpO1xuXHR9LFxuXG5cdHNpemU6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC53aWR0aCkgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLm51bWJlcih2YWwuaGVpZ2h0KTtcblx0fSxcblxuXHRyZWN0YW5nbGU6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMucG9pbnQodmFsLCBzZXBhcmF0b3IpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5zaXplKHZhbCwgc2VwYXJhdG9yKTtcblx0fVxufSk7XG5cbkZvcm1hdHRlci5pbnN0YW5jZSA9IG5ldyBGb3JtYXR0ZXIoKTtcblxudmFyIE51bWVyaWNhbCA9IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIgYWJzY2lzc2FzID0gW1xuXHRcdFsgIDAuNTc3MzUwMjY5MTg5NjI1NzY0NTA5MTQ4OF0sXG5cdFx0WzAsMC43NzQ1OTY2NjkyNDE0ODMzNzcwMzU4NTMxXSxcblx0XHRbICAwLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSxcblx0XHRbMCwwLjUzODQ2OTMxMDEwNTY4MzA5MTAzNjMxNDQsMC45MDYxNzk4NDU5Mzg2NjM5OTI3OTc2MjY5XSxcblx0XHRbICAwLjIzODYxOTE4NjA4MzE5NjkwODYzMDUwMTcsMC42NjEyMDkzODY0NjYyNjQ1MTM2NjEzOTk2LDAuOTMyNDY5NTE0MjAzMTUyMDI3ODEyMzAxNl0sXG5cdFx0WzAsMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLFxuXHRcdFsgIDAuMTgzNDM0NjQyNDk1NjQ5ODA0OTM5NDc2MSwwLjUyNTUzMjQwOTkxNjMyODk4NTgxNzczOTAsMC43OTY2NjY0Nzc0MTM2MjY3Mzk1OTE1NTM5LDAuOTYwMjg5ODU2NDk3NTM2MjMxNjgzNTYwOV0sXG5cdFx0WzAsMC4zMjQyNTM0MjM0MDM4MDg5MjkwMzg1MzgwLDAuNjEzMzcxNDMyNzAwNTkwMzk3MzA4NzAyMCwwLjgzNjAzMTEwNzMyNjYzNTc5NDI5OTQyOTgsMC45NjgxNjAyMzk1MDc2MjYwODk4MzU1NzYyXSxcblx0XHRbICAwLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSxcblx0XHRbMCwwLjI2OTU0MzE1NTk1MjM0NDk3MjMzMTUzMjAsMC41MTkwOTYxMjkyMDY4MTE4MTU5MjU3MjU3LDAuNzMwMTUyMDA1NTc0MDQ5MzI0MDkzNDE2MywwLjg4NzA2MjU5OTc2ODA5NTI5OTA3NTE1NzgsMC45NzgyMjg2NTgxNDYwNTY5OTI4MDM5MzgwXSxcblx0XHRbICAwLjEyNTIzMzQwODUxMTQ2ODkxNTQ3MjQ0MTQsMC4zNjc4MzE0OTg5OTgxODAxOTM3NTI2OTE1LDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNCwwLjc2OTkwMjY3NDE5NDMwNDY4NzAzNjg5MzgsMC45MDQxMTcyNTYzNzA0NzQ4NTY2Nzg0NjU5LDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MV0sXG5cdFx0WzAsMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLFxuXHRcdFsgIDAuMTA4MDU0OTQ4NzA3MzQzNjYyMDY2MjQ0NywwLjMxOTExMjM2ODkyNzg4OTc2MDQzNTY3MTgsMC41MTUyNDg2MzYzNTgxNTQwOTE5NjUyOTA3LDAuNjg3MjkyOTA0ODExNjg1NDcwMTQ4MDE5OCwwLjgyNzIwMTMxNTA2OTc2NDk5MzE4OTc5NDcsMC45Mjg0MzQ4ODM2NjM1NzM1MTczMzYzOTExLDAuOTg2MjgzODA4Njk2ODEyMzM4ODQxNTk3M10sXG5cdFx0WzAsMC4yMDExOTQwOTM5OTc0MzQ1MjIzMDA2MjgzLDAuMzk0MTUxMzQ3MDc3NTYzMzY5ODk3MjA3NCwwLjU3MDk3MjE3MjYwODUzODg0NzUzNzIyNjcsMC43MjQ0MTc3MzEzNjAxNzAwNDc0MTYxODYxLDAuODQ4MjA2NTgzNDEwNDI3MjE2MjAwNjQ4MywwLjkzNzI3MzM5MjQwMDcwNTkwNDMwNzc1ODksMC45ODc5OTI1MTgwMjA0ODU0Mjg0ODk1NjU3XSxcblx0XHRbICAwLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXVxuXHRdO1xuXG5cdHZhciB3ZWlnaHRzID0gW1xuXHRcdFsxXSxcblx0XHRbMC44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1Nl0sXG5cdFx0WzAuNjUyMTQ1MTU0ODYyNTQ2MTQyNjI2OTM2MSwwLjM0Nzg1NDg0NTEzNzQ1Mzg1NzM3MzA2MzldLFxuXHRcdFswLjU2ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC40Nzg2Mjg2NzA0OTkzNjY0NjgwNDEyOTE1LDAuMjM2OTI2ODg1MDU2MTg5MDg3NTE0MjY0MF0sXG5cdFx0WzAuNDY3OTEzOTM0NTcyNjkxMDQ3Mzg5ODcwMywwLjM2MDc2MTU3MzA0ODEzODYwNzU2OTgzMzUsMC4xNzEzMjQ0OTIzNzkxNzAzNDUwNDAyOTYxXSxcblx0XHRbMC40MTc5NTkxODM2NzM0NjkzODc3NTUxMDIwLDAuMzgxODMwMDUwNTA1MTE4OTQ0OTUwMzY5OCwwLjI3OTcwNTM5MTQ4OTI3NjY2NzkwMTQ2NzgsMC4xMjk0ODQ5NjYxNjg4Njk2OTMyNzA2MTE0XSxcblx0XHRbMC4zNjI2ODM3ODMzNzgzNjE5ODI5NjUxNTA0LDAuMzEzNzA2NjQ1ODc3ODg3Mjg3MzM3OTYyMiwwLjIyMjM4MTAzNDQ1MzM3NDQ3MDU0NDM1NjAsMC4xMDEyMjg1MzYyOTAzNzYyNTkxNTI1MzE0XSxcblx0XHRbMC4zMzAyMzkzNTUwMDEyNTk3NjMxNjQ1MjUxLDAuMzEyMzQ3MDc3MDQwMDAyODQwMDY4NjMwNCwwLjI2MDYxMDY5NjQwMjkzNTQ2MjMxODc0MjksMC4xODA2NDgxNjA2OTQ4NTc0MDQwNTg0NzIwLDAuMDgxMjc0Mzg4MzYxNTc0NDExOTcxODkyMl0sXG5cdFx0WzAuMjk1NTI0MjI0NzE0NzUyODcwMTczODkzMCwwLjI2OTI2NjcxOTMwOTk5NjM1NTA5MTIyNjksMC4yMTkwODYzNjI1MTU5ODIwNDM5OTU1MzQ5LDAuMTQ5NDUxMzQ5MTUwNTgwNTkzMTQ1Nzc2MywwLjA2NjY3MTM0NDMwODY4ODEzNzU5MzU2ODhdLFxuXHRcdFswLjI3MjkyNTA4Njc3NzkwMDYzMDcxNDQ4MzUsMC4yNjI4MDQ1NDQ1MTAyNDY2NjIxODA2ODg5LDAuMjMzMTkzNzY0NTkxOTkwNDc5OTE4NTIzNywwLjE4NjI5MDIxMDkyNzczNDI1MTQyNjA5NzYsMC4xMjU1ODAzNjk0NjQ5MDQ2MjQ2MzQ2OTQzLDAuMDU1NjY4NTY3MTE2MTczNjY2NDgyNzUzN10sXG5cdFx0WzAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNCwwLjIzMzQ5MjUzNjUzODM1NDgwODc2MDg0OTksMC4yMDMxNjc0MjY3MjMwNjU5MjE3NDkwNjQ1LDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNSwwLjEwNjkzOTMyNTk5NTMxODQzMDk2MDI1NDcsMC4wNDcxNzUzMzYzODY1MTE4MjcxOTQ2MTYwXSxcblx0XHRbMC4yMzI1NTE1NTMyMzA4NzM5MTAxOTQ1ODk1LDAuMjI2MjgzMTgwMjYyODk3MjM4NDEyMDkwMiwwLjIwNzgxNjA0NzUzNjg4ODUwMjMxMjUyMzIsMC4xNzgxNDU5ODA3NjE5NDU3MzgyODAwNDY3LDAuMTM4ODczNTEwMjE5Nzg3MjM4NDYzNjAxOCwwLjA5MjEyMTQ5OTgzNzcyODQ0NzkxNDQyMTgsMC4wNDA0ODQwMDQ3NjUzMTU4Nzk1MjAwMjE2XSxcblx0XHRbMC4yMTUyNjM4NTM0NjMxNTc3OTAxOTU4NzY0LDAuMjA1MTk4NDYzNzIxMjk1NjAzOTY1OTI0MSwwLjE4NTUzODM5NzQ3NzkzNzgxMzc0MTcxNjYsMC4xNTcyMDMxNjcxNTgxOTM1MzQ1Njk2MDE5LDAuMTIxNTE4NTcwNjg3OTAzMTg0Njg5NDE0OCwwLjA4MDE1ODA4NzE1OTc2MDIwOTgwNTYzMzMsMC4wMzUxMTk0NjAzMzE3NTE4NjMwMzE4MzI5XSxcblx0XHRbMC4yMDI1NzgyNDE5MjU1NjEyNzI4ODA2MjAyLDAuMTk4NDMxNDg1MzI3MTExNTc2NDU2MTE4MywwLjE4NjE2MTAwMDAxNTU2MjIxMTAyNjgwMDYsMC4xNjYyNjkyMDU4MTY5OTM5MzM1NTMyMDA5LDAuMTM5NTcwNjc3OTI2MTU0MzE0NDQ3ODA0OCwwLjEwNzE1OTIyMDQ2NzE3MTkzNTAxMTg2OTUsMC4wNzAzNjYwNDc0ODgxMDgxMjQ3MDkyNjc0LDAuMDMwNzUzMjQxOTk2MTE3MjY4MzU0NjI4NF0sXG5cdFx0WzAuMTg5NDUwNjEwNDU1MDY4NDk2Mjg1Mzk2NywwLjE4MjYwMzQxNTA0NDkyMzU4ODg2Njc2MzcsMC4xNjkxNTY1MTkzOTUwMDI1MzgxODkzMTIxLDAuMTQ5NTk1OTg4ODE2NTc2NzMyMDgxNTAxNywwLjEyNDYyODk3MTI1NTUzMzg3MjA1MjQ3NjMsMC4wOTUxNTg1MTE2ODI0OTI3ODQ4MDk5MjUxLDAuMDYyMjUzNTIzOTM4NjQ3ODkyODYyODQzOCwwLjAyNzE1MjQ1OTQxMTc1NDA5NDg1MTc4MDZdXG5cdF07XG5cblx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0cG93ID0gTWF0aC5wb3csXG5cdFx0RVBTSUxPTiA9IDFlLTEyLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTiA9IDEuMTJlLTE2O1xuXG5cdGZ1bmN0aW9uIGNsaXAodmFsdWUsIG1pbiwgbWF4KSB7XG5cdFx0cmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0VE9MRVJBTkNFOiAxZS02LFxuXHRcdEVQU0lMT046IEVQU0lMT04sXG5cdFx0TUFDSElORV9FUFNJTE9OOiBNQUNISU5FX0VQU0lMT04sXG5cdFx0Q1VSVkVUSU1FX0VQU0lMT046IDRlLTcsXG5cdFx0R0VPTUVUUklDX0VQU0lMT046IDJlLTcsXG5cdFx0V0lORElOR19FUFNJTE9OOiAyZS03LFxuXHRcdFRSSUdPTk9NRVRSSUNfRVBTSUxPTjogMWUtNyxcblx0XHRDTElQUElOR19FUFNJTE9OOiAxZS03LFxuXHRcdEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG5cblx0XHRpc1plcm86IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0cmV0dXJuIHZhbCA+PSAtRVBTSUxPTiAmJiB2YWwgPD0gRVBTSUxPTjtcblx0XHR9LFxuXG5cdFx0aW50ZWdyYXRlOiBmdW5jdGlvbihmLCBhLCBiLCBuKSB7XG5cdFx0XHR2YXIgeCA9IGFic2Npc3Nhc1tuIC0gMl0sXG5cdFx0XHRcdHcgPSB3ZWlnaHRzW24gLSAyXSxcblx0XHRcdFx0QSA9IChiIC0gYSkgKiAwLjUsXG5cdFx0XHRcdEIgPSBBICsgYSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdG0gPSAobiArIDEpID4+IDEsXG5cdFx0XHRcdHN1bSA9IG4gJiAxID8gd1tpKytdICogZihCKSA6IDA7XG5cdFx0XHR3aGlsZSAoaSA8IG0pIHtcblx0XHRcdFx0dmFyIEF4ID0gQSAqIHhbaV07XG5cdFx0XHRcdHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBICogc3VtO1xuXHRcdH0sXG5cblx0XHRmaW5kUm9vdDogZnVuY3Rpb24oZiwgZGYsIHgsIGEsIGIsIG4sIHRvbGVyYW5jZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGZ4ID0gZih4KSxcblx0XHRcdFx0XHRkeCA9IGZ4IC8gZGYoeCksXG5cdFx0XHRcdFx0bnggPSB4IC0gZHg7XG5cdFx0XHRcdGlmIChhYnMoZHgpIDwgdG9sZXJhbmNlKVxuXHRcdFx0XHRcdHJldHVybiBueDtcblx0XHRcdFx0aWYgKGZ4ID4gMCkge1xuXHRcdFx0XHRcdGIgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA8PSBhID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGEgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA+PSBiID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9LFxuXG5cdFx0c29sdmVRdWFkcmF0aWM6IGZ1bmN0aW9uKGEsIGIsIGMsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGNvdW50ID0gMCxcblx0XHRcdFx0ZU1pbiA9IG1pbiAtIEVQU0lMT04sXG5cdFx0XHRcdGVNYXggPSBtYXggKyBFUFNJTE9OLFxuXHRcdFx0XHR4MSwgeDIgPSBJbmZpbml0eSxcblx0XHRcdFx0QiA9IGIsXG5cdFx0XHRcdEQ7XG5cdFx0XHRiIC89IC0yO1xuXHRcdFx0RCA9IGIgKiBiIC0gYSAqIGM7XG5cdFx0XHRpZiAoRCAhPT0gMCAmJiBhYnMoRCkgPCBNQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0dmFyIGdtQyA9IHBvdyhhYnMoYSAqIGIgKiBjKSwgMSAvIDMpO1xuXHRcdFx0XHRpZiAoZ21DIDwgMWUtOCkge1xuXHRcdFx0XHRcdHZhciBtdWx0ID0gcG93KDEwLFxuXHRcdFx0XHRcdFx0XHRhYnMoTWF0aC5mbG9vcihNYXRoLmxvZyhnbUMpICogTWF0aC5MT0cxMEUpKSk7XG5cdFx0XHRcdFx0aWYgKCFpc0Zpbml0ZShtdWx0KSlcblx0XHRcdFx0XHRcdG11bHQgPSAwO1xuXHRcdFx0XHRcdGEgKj0gbXVsdDtcblx0XHRcdFx0XHRiICo9IG11bHQ7XG5cdFx0XHRcdFx0YyAqPSBtdWx0O1xuXHRcdFx0XHRcdEQgPSBiICogYiAtIGEgKiBjO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKEIpIDwgRVBTSUxPTilcblx0XHRcdFx0XHRyZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDtcblx0XHRcdFx0eDEgPSAtYyAvIEI7XG5cdFx0XHR9IGVsc2UgaWYgKEQgPj0gLU1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHR2YXIgUSA9IEQgPCAwID8gMCA6IHNxcnQoRCksXG5cdFx0XHRcdFx0UiA9IGIgKyAoYiA8IDAgPyAtUSA6IFEpO1xuXHRcdFx0XHRpZiAoUiA9PT0gMCkge1xuXHRcdFx0XHRcdHgxID0gYyAvIGE7XG5cdFx0XHRcdFx0eDIgPSAteDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBSIC8gYTtcblx0XHRcdFx0XHR4MiA9IGMgLyBSO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNGaW5pdGUoeDEpICYmIChtaW4gPT0gbnVsbCB8fCB4MSA+IGVNaW4gJiYgeDEgPCBlTWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBtaW4gPT0gbnVsbCA/IHgxIDogY2xpcCh4MSwgbWluLCBtYXgpO1xuXHRcdFx0aWYgKHgyICE9PSB4MVxuXHRcdFx0XHRcdCYmIGlzRmluaXRlKHgyKSAmJiAobWluID09IG51bGwgfHwgeDIgPiBlTWluICYmIHgyIDwgZU1heCkpXG5cdFx0XHRcdHJvb3RzW2NvdW50KytdID0gbWluID09IG51bGwgPyB4MiA6IGNsaXAoeDIsIG1pbiwgbWF4KTtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0c29sdmVDdWJpYzogZnVuY3Rpb24oYSwgYiwgYywgZCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHR4LCBiMSwgYzI7XG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRhID0gYjtcblx0XHRcdFx0YjEgPSBjO1xuXHRcdFx0XHRjMiA9IGQ7XG5cdFx0XHRcdHggPSBJbmZpbml0eTtcblx0XHRcdH0gZWxzZSBpZiAoYWJzKGQpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRiMSA9IGI7XG5cdFx0XHRcdGMyID0gYztcblx0XHRcdFx0eCA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZWMgPSAxICsgTUFDSElORV9FUFNJTE9OLFxuXHRcdFx0XHRcdHgwLCBxLCBxZCwgdCwgciwgcywgdG1wO1xuXHRcdFx0XHR4ID0gLShiIC8gYSkgLyAzO1xuXHRcdFx0XHR0bXAgPSBhICogeCxcblx0XHRcdFx0YjEgPSB0bXAgKyBiLFxuXHRcdFx0XHRjMiA9IGIxICogeCArIGMsXG5cdFx0XHRcdHFkID0gKHRtcCArIGIxKSAqIHggKyBjMixcblx0XHRcdFx0cSA9IGMyICogeCArIGQ7XG5cdFx0XHRcdHQgPSBxIC9hO1xuXHRcdFx0XHRyID0gcG93KGFicyh0KSwgMS8zKTtcblx0XHRcdFx0cyA9IHQgPCAwID8gLTEgOiAxO1xuXHRcdFx0XHR0ID0gLXFkIC8gYTtcblx0XHRcdFx0ciA9IHQgPiAwID8gMS4zMjQ3MTc5NTcyICogTWF0aC5tYXgociwgc3FydCh0KSkgOiByO1xuXHRcdFx0XHR4MCA9IHggLSBzICogcjtcblx0XHRcdFx0aWYgKHgwICE9PSB4KSB7XG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0eCA9IHgwO1xuXHRcdFx0XHRcdFx0dG1wID0gYSAqIHgsXG5cdFx0XHRcdFx0XHRiMSA9IHRtcCArIGIsXG5cdFx0XHRcdFx0XHRjMiA9IGIxICogeCArIGMsXG5cdFx0XHRcdFx0XHRxZCA9ICh0bXAgKyBiMSkgKiB4ICsgYzIsXG5cdFx0XHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdFx0XHRcdHgwID0gcWQgPT09IDAgPyB4IDogeCAtIHEgLyBxZCAvIGVjO1xuXHRcdFx0XHRcdFx0aWYgKHgwID09PSB4KSB7XG5cdFx0XHRcdFx0XHRcdHggPSB4MDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSB3aGlsZSAocyAqIHgwID4gcyAqIHgpO1xuXHRcdFx0XHRcdGlmIChhYnMoYSkgKiB4ICogeCA+IGFicyhkIC8geCkpIHtcblx0XHRcdFx0XHRcdGMyID0gLWQgLyB4O1xuXHRcdFx0XHRcdFx0YjEgPSAoYzIgLSBjKSAvIHg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgY291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYjEsIGMyLCByb290cywgbWluLCBtYXgpO1xuXHRcdFx0aWYgKGlzRmluaXRlKHgpICYmIChjb3VudCA9PT0gMCB8fCB4ICE9PSByb290c1tjb3VudCAtIDFdKVxuXHRcdFx0XHRcdCYmIChtaW4gPT0gbnVsbCB8fCB4ID4gbWluIC0gRVBTSUxPTiAmJiB4IDwgbWF4ICsgRVBTSUxPTikpXG5cdFx0XHRcdHJvb3RzW2NvdW50KytdID0gbWluID09IG51bGwgPyB4IDogY2xpcCh4LCBtaW4sIG1heCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFVJRCA9IHtcblx0X2lkOiAxLFxuXHRfcG9vbHM6IHt9LFxuXG5cdGdldDogZnVuY3Rpb24oY3Rvcikge1xuXHRcdGlmIChjdG9yKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGN0b3IuX2NsYXNzLFxuXHRcdFx0XHRwb29sID0gdGhpcy5fcG9vbHNbbmFtZV07XG5cdFx0XHRpZiAoIXBvb2wpXG5cdFx0XHRcdHBvb2wgPSB0aGlzLl9wb29sc1tuYW1lXSA9IHsgX2lkOiAxIH07XG5cdFx0XHRyZXR1cm4gcG9vbC5faWQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2lkKys7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgUG9pbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50Jyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludChhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNZID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy54ID0gYXJnMDtcblx0XHRcdHRoaXMueSA9IGhhc1kgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNZID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSAwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC5sZW5ndGggPiAxID8gYXJnMFsxXSA6IGFyZzBbMF07XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAueDtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC55O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLndpZHRoICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC53aWR0aDtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC5oZWlnaHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuYW5nbGUgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLmxlbmd0aDtcblx0XHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdFx0dGhpcy5zZXRBbmdsZShhcmcwLmFuZ2xlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMueCA9IHRoaXMueSA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gdGhpcyA9PT0gcG9pbnQgfHwgcG9pbnRcblx0XHRcdFx0JiYgKHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnlcblx0XHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHBvaW50KVxuXHRcdFx0XHRcdFx0JiYgdGhpcy54ID09PSBwb2ludFswXSAmJiB0aGlzLnkgPT09IHBvaW50WzFdKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSldO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBhbmdsZSA9IHRoaXMuX2FuZ2xlIHx8IDA7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IGxlbmd0aCAvIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhzY2FsZSkpXG5cdFx0XHRcdHRoaXMuZ2V0QW5nbGUoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHR0aGlzLnggKiBzY2FsZSxcblx0XHRcdFx0dGhpcy55ICogc2NhbGVcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXHRnZXRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QW5nbGVJblJhZGlhbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIDE4MCAvIE1hdGguUEk7XG5cdH0sXG5cblx0c2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0dGhpcy5zZXRBbmdsZUluUmFkaWFucy5jYWxsKHRoaXMsIGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7XG5cdH0sXG5cblx0Z2V0QW5nbGVJbkRlZ3JlZXM6ICcjZ2V0QW5nbGUnLFxuXHRzZXRBbmdsZUluRGVncmVlczogJyNzZXRBbmdsZScsXG5cblx0Z2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2FuZ2xlIHx8IDBcblx0XHRcdFx0XHQ6IHRoaXMuX2FuZ2xlID0gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0ZGl2ID0gdGhpcy5nZXRMZW5ndGgoKSAqIHBvaW50LmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZGl2KSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGEgPSB0aGlzLmRvdChwb2ludCkgLyBkaXY7XG5cdFx0XHRcdHJldHVybiBNYXRoLmFjb3MoYSA8IC0xID8gLTEgOiBhID4gMSA/IDEgOiBhKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0dGhpcy5fYW5nbGUgPSBhbmdsZTtcblx0XHRpZiAoIXRoaXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRRdWFkcmFudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCA+PSAwID8gdGhpcy55ID49IDAgPyAxIDogNCA6IHRoaXMueSA+PSAwID8gMiA6IDM7XG5cdH1cbn0sIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldERpcmVjdGVkQW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gTWF0aC5hdGFuMih0aGlzLmNyb3NzKHBvaW50KSwgdGhpcy5kb3QocG9pbnQpKSAqIDE4MCAvIE1hdGguUEk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54IC0gdGhpcy54LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLnksXG5cdFx0XHRkID0geCAqIHggKyB5ICogeSxcblx0XHRcdHNxdWFyZWQgPSBCYXNlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gc3F1YXJlZCA/IGQgOiBNYXRoLnNxcnQoZCk7XG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpXG5cdFx0XHRsZW5ndGggPSAxO1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRMZW5ndGgoKSxcblx0XHRcdHNjYWxlID0gY3VycmVudCAhPT0gMCA/IGxlbmd0aCAvIGN1cnJlbnQgOiAwLFxuXHRcdFx0cG9pbnQgPSBuZXcgUG9pbnQodGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlKTtcblx0XHRpZiAoc2NhbGUgPj0gMClcblx0XHRcdHBvaW50Ll9hbmdsZSA9IHRoaXMuX2FuZ2xlO1xuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlLCBjZW50ZXIpIHtcblx0XHRpZiAoYW5nbGUgPT09IDApXG5cdFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHRcdGFuZ2xlID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdHZhciBwb2ludCA9IGNlbnRlciA/IHRoaXMuc3VidHJhY3QoY2VudGVyKSA6IHRoaXMsXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogY29zIC0gcG9pbnQueSAqIHNpbixcblx0XHRcdHBvaW50LnggKiBzaW4gKyBwb2ludC55ICogY29zXG5cdFx0KTtcblx0XHRyZXR1cm4gY2VudGVyID8gcG9pbnQuYWRkKGNlbnRlcikgOiBwb2ludDtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHRoaXMpIDogdGhpcztcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHBvaW50LngsIHRoaXMueSArIHBvaW50LnkpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwb2ludC54LCB0aGlzLnkgLSBwb2ludC55KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAlIHBvaW50LngsIHRoaXMueSAlIHBvaW50LnkpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCgtdGhpcy54LCAtdGhpcy55KTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcyk7XG5cdH0sXG5cblx0aXNDbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0dG9sZXJhbmNlID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDwgdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMueCwgdGhpcy55LCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRpc0NvbGluZWFyOiAnI2lzQ29sbGluZWFyJyxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMueCwgdGhpcy55LCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLnkpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy54KSB8fCBpc05hTih0aGlzLnkpO1xuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC54ICsgdGhpcy55ICogcG9pbnQueTtcblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC55IC0gdGhpcy55ICogcG9pbnQueDtcblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRzY2FsZSA9IHBvaW50LmlzWmVybygpID8gMCA6IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdHBvaW50LnggKiBzY2FsZSxcblx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fSxcblxuXHRcdGlzQ29sbGluZWFyOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHgxICogeTIgLSB5MSAqIHgyKVxuXHRcdFx0XHRcdDw9IE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcblx0XHRcdFx0XHRcdCogMWUtNztcblx0XHR9LFxuXG5cdFx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHgxICogeDIgKyB5MSAqIHkyKVxuXHRcdFx0XHRcdDw9IE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcblx0XHRcdFx0XHRcdCogMWUtNztcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIG9wID0gTWF0aFtuYW1lXTtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQob3AodGhpcy54KSwgb3AodGhpcy55KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkUG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludCh4LCB5LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFNpemUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NpemUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzSGVpZ2h0ID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy53aWR0aCA9IGFyZzA7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhhc0hlaWdodCA/IGFyZzEgOiBhcmcwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGhhc0hlaWdodCA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLndpZHRoICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5oZWlnaHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLng7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC55O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdHRoaXMuX19yZWFkID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSAxO1xuXHRcdH1cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0cmV0dXJuIHNpemUgPT09IHRoaXMgfHwgc2l6ZSAmJiAodGhpcy53aWR0aCA9PT0gc2l6ZS53aWR0aFxuXHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHRcblx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShzaXplKSAmJiB0aGlzLndpZHRoID09PSBzaXplWzBdXG5cdFx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemVbMV0pIHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKVxuXHRcdFx0XHQrICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLndpZHRoKSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy5oZWlnaHQpXTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCArIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAtIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKiBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC8gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICUgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgJSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUoLXRoaXMud2lkdGgsIC10aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh0aGlzLndpZHRoKSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc05hTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGlzTmFOKHRoaXMud2lkdGgpIHx8IGlzTmFOKHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0bWluOiBmdW5jdGlvbihzaXplMSwgc2l6ZTIpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdFx0TWF0aC5taW4oc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSxcblx0XHRcdFx0TWF0aC5taW4oc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbihzaXplMSwgc2l6ZTIpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdFx0TWF0aC5tYXgoc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSxcblx0XHRcdFx0TWF0aC5tYXgoc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIG9wID0gTWF0aFtuYW1lXTtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZShvcCh0aGlzLndpZHRoKSwgb3AodGhpcy5oZWlnaHQpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRTaXplID0gU2l6ZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl93aWR0aDtcblx0fSxcblxuXHRzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgUmVjdGFuZ2xlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSZWN0YW5nbGUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkID0gMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMueCA9IGFyZzA7XG5cdFx0XHR0aGlzLnkgPSBhcmcxO1xuXHRcdFx0dGhpcy53aWR0aCA9IGFyZzI7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGFyZzM7XG5cdFx0XHRyZWFkID0gNDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueSA9IHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy55ID0gYXJnMFsxXTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzBbMl07XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMFszXTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPT0gdW5kZWZpbmVkIHx8IGFyZzAud2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLnggfHwgMDtcblx0XHRcdFx0dGhpcy55ID0gYXJnMC55IHx8IDA7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoIHx8IDA7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5oZWlnaHQgfHwgMDtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuZnJvbSA9PT0gdW5kZWZpbmVkICYmIGFyZzAudG8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0XHR0aGlzLl9zZXQoYXJnMCk7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXJlYWQpIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdG5leHQgPSBCYXNlLnBlZWsoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHRcdFx0aWYgKG5leHQgJiYgbmV4dC54ICE9PSB1bmRlZmluZWQgfHwgQmFzZS5oYXNOYW1lZChhcmd1bWVudHMsICd0bycpKSB7XG5cdFx0XHRcdHZhciB0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdG8ueCAtIHBvaW50Lng7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gdG8ueSAtIHBvaW50Lnk7XG5cdFx0XHRcdGlmICh0aGlzLndpZHRoIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMueCA9IHRvLng7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IC10aGlzLndpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmhlaWdodCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnkgPSB0by55O1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gLXRoaXMuaGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdH1cblx0XHRcdHJlYWQgPSBhcmd1bWVudHMuX19pbmRleDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHJ0ID0gQmFzZS5pc1BsYWluVmFsdWUocmVjdClcblx0XHRcdFx0PyBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdDogcmVjdDtcblx0XHRyZXR1cm4gcnQgPT09IHRoaXNcblx0XHRcdFx0fHwgcnQgJiYgdGhpcy54ID09PSBydC54ICYmIHRoaXMueSA9PT0gcnQueVxuXHRcdFx0XHRcdCYmIHRoaXMud2lkdGggPT09IHJ0LndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBydC5oZWlnaHRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KVxuXHRcdFx0XHQrICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpXG5cdFx0XHRcdCsgJywgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKVxuXHRcdFx0XHQrICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KVxuXHRcdFx0XHQrICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLnkpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLndpZHRoKSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy5oZWlnaHQpXTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBTaXplIDogTGlua2VkU2l6ZTtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5fZml4WClcblx0XHRcdHRoaXMueCArPSAodGhpcy53aWR0aCAtIHNpemUud2lkdGgpICogdGhpcy5fZml4WDtcblx0XHRpZiAodGhpcy5fZml4WSlcblx0XHRcdHRoaXMueSArPSAodGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCkgKiB0aGlzLl9maXhZO1xuXHRcdHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0dGhpcy5fZml4VyA9IDE7XG5cdFx0dGhpcy5fZml4SCA9IDE7XG5cdH0sXG5cblx0Z2V0TGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueDtcblx0fSxcblxuXHRzZXRMZWZ0OiBmdW5jdGlvbihsZWZ0KSB7XG5cdFx0aWYgKCF0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy53aWR0aCAtPSBsZWZ0IC0gdGhpcy54O1xuXHRcdHRoaXMueCA9IGxlZnQ7XG5cdFx0dGhpcy5fZml4WCA9IDA7XG5cdH0sXG5cblx0Z2V0VG9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55O1xuXHR9LFxuXG5cdHNldFRvcDogZnVuY3Rpb24odG9wKSB7XG5cdFx0aWYgKCF0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy5oZWlnaHQgLT0gdG9wIC0gdGhpcy55O1xuXHRcdHRoaXMueSA9IHRvcDtcblx0XHR0aGlzLl9maXhZID0gMDtcblx0fSxcblxuXHRnZXRSaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG5cdH0sXG5cblx0c2V0UmlnaHQ6IGZ1bmN0aW9uKHJpZ2h0KSB7XG5cdFx0aWYgKHRoaXMuX2ZpeFggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maXhYICE9PSAxKVxuXHRcdFx0dGhpcy5fZml4VyA9IDA7XG5cdFx0aWYgKHRoaXMuX2ZpeFcpXG5cdFx0XHR0aGlzLnggPSByaWdodCAtIHRoaXMud2lkdGg7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy53aWR0aCA9IHJpZ2h0IC0gdGhpcy54O1xuXHRcdHRoaXMuX2ZpeFggPSAxO1xuXHR9LFxuXG5cdGdldEJvdHRvbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdHNldEJvdHRvbTogZnVuY3Rpb24oYm90dG9tKSB7XG5cdFx0aWYgKHRoaXMuX2ZpeFkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maXhZICE9PSAxKVxuXHRcdFx0dGhpcy5fZml4SCA9IDA7XG5cdFx0aWYgKHRoaXMuX2ZpeEgpXG5cdFx0XHR0aGlzLnkgPSBib3R0b20gLSB0aGlzLmhlaWdodDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmhlaWdodCA9IGJvdHRvbSAtIHRoaXMueTtcblx0XHR0aGlzLl9maXhZID0gMTtcblx0fSxcblxuXHRnZXRDZW50ZXJYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAqIDAuNTtcblx0fSxcblxuXHRzZXRDZW50ZXJYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy54ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG5cdFx0dGhpcy5fZml4WCA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXJZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMueSA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcblx0XHR0aGlzLl9maXhZID0gMC41O1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLmdldENlbnRlclgoKSwgdGhpcy5nZXRDZW50ZXJZKCksIHRoaXMsICdzZXRDZW50ZXInKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnNldENlbnRlclgocG9pbnQueCk7XG5cdFx0dGhpcy5zZXRDZW50ZXJZKHBvaW50LnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDA7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKGFyZykge1xuXHRcdHJldHVybiBhcmcgJiYgYXJnLndpZHRoICE9PSB1bmRlZmluZWRcblx0XHRcdFx0fHwgKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cykubGVuZ3RoID09IDRcblx0XHRcdFx0PyB0aGlzLl9jb250YWluc1JlY3RhbmdsZShSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0XHQ6IHRoaXMuX2NvbnRhaW5zUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0X2NvbnRhaW5zUmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHggPSByZWN0LngsXG5cdFx0XHR5ID0gcmVjdC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4ICsgcmVjdC53aWR0aCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHkgKyByZWN0LmhlaWdodCA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPiB0aGlzLnhcblx0XHRcdFx0JiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPiB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDwgdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiByZWN0LnkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHR0b3VjaGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPj0gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID49IHRoaXMueVxuXHRcdFx0XHQmJiByZWN0LnggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiByZWN0LnkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdC54KSxcblx0XHRcdHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcblx0XHRcdHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdHVuaXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4MSA9IE1hdGgubWluKHRoaXMueCwgcmVjdC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCByZWN0LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcblx0XHRcdHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGluY2x1ZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC54KSxcblx0XHRcdHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHBvaW50LnkpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0ZXhwYW5kOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW1vdW50ID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRob3IgPSBhbW91bnQud2lkdGgsXG5cdFx0XHR2ZXIgPSBhbW91bnQuaGVpZ2h0O1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIGhvciAvIDIsIHRoaXMueSAtIHZlciAvIDIsXG5cdFx0XHRcdHRoaXMud2lkdGggKyBob3IsIHRoaXMuaGVpZ2h0ICsgdmVyKTtcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oaG9yLCB2ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQodGhpcy53aWR0aCAqIGhvciAtIHRoaXMud2lkdGgsXG5cdFx0XHRcdHRoaXMuaGVpZ2h0ICogKHZlciA9PT0gdW5kZWZpbmVkID8gaG9yIDogdmVyKSAtIHRoaXMuaGVpZ2h0KTtcblx0fVxufSwgQmFzZS5lYWNoKFtcblx0XHRbJ1RvcCcsICdMZWZ0J10sIFsnVG9wJywgJ1JpZ2h0J10sXG5cdFx0WydCb3R0b20nLCAnTGVmdCddLCBbJ0JvdHRvbScsICdSaWdodCddLFxuXHRcdFsnTGVmdCcsICdDZW50ZXInXSwgWydUb3AnLCAnQ2VudGVyJ10sXG5cdFx0WydSaWdodCcsICdDZW50ZXInXSwgWydCb3R0b20nLCAnQ2VudGVyJ11cblx0XSxcblx0ZnVuY3Rpb24ocGFydHMsIGluZGV4KSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0cy5qb2luKCcnKTtcblx0XHR2YXIgeEZpcnN0ID0gL15bUkxdLy50ZXN0KHBhcnQpO1xuXHRcdGlmIChpbmRleCA+PSA0KVxuXHRcdFx0cGFydHNbMV0gKz0geEZpcnN0ID8gJ1knIDogJ1gnO1xuXHRcdHZhciB4ID0gcGFydHNbeEZpcnN0ID8gMCA6IDFdLFxuXHRcdFx0eSA9IHBhcnRzW3hGaXJzdCA/IDEgOiAwXSxcblx0XHRcdGdldFggPSAnZ2V0JyArIHgsXG5cdFx0XHRnZXRZID0gJ2dldCcgKyB5LFxuXHRcdFx0c2V0WCA9ICdzZXQnICsgeCxcblx0XHRcdHNldFkgPSAnc2V0JyArIHksXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQsXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQ7XG5cdFx0dGhpc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0XHRyZXR1cm4gbmV3IGN0b3IodGhpc1tnZXRYXSgpLCB0aGlzW2dldFldKCksIHRoaXMsIHNldCk7XG5cdFx0fTtcblx0XHR0aGlzW3NldF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXNbc2V0WF0ocG9pbnQueCk7XG5cdFx0XHR0aGlzW3NldFldKHBvaW50LnkpO1xuXHRcdH07XG5cdH0sIHtcblx0XHRiZWFuczogdHJ1ZVxuXHR9XG4pKTtcblxudmFyIExpbmtlZFJlY3RhbmdsZSA9IFJlY3RhbmdsZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuXHRcdHZhciBpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLnNldFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3duZXIuX2JvdW5kc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0b3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID09PSA2KSB7XG5cdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5zZXQoYXJnLl9hLCBhcmcuX2MsIGFyZy5fYiwgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaylcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKGEsIGMsIGIsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLFxuXHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2Jcblx0XHRcdFx0JiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2Rcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYiksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG5cdFx0XHRcdCsgW2YubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl9kKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcblx0XHR0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwbHk6IGZ1bmN0aW9uKHJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlLCBCYXNlLnBpY2socmVjdXJzaXZlbHksIHRydWUpLFxuXHRcdFx0XHRcdF9zZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0dGhpcy5fdHggKz0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYjtcblx0XHR0aGlzLl90eSArPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjYWxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dGhpcy5fYSAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9iICo9IHNjYWxlLnk7XG5cdFx0dGhpcy5fZCAqPSBzY2FsZS55O1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcblx0XHRcdHggPSBjZW50ZXIueCxcblx0XHRcdHkgPSBjZW50ZXIueSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuXHRcdFx0dHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG5cdFx0XHRhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZDtcblx0XHR0aGlzLl9hID0gY29zICogYSArIHNpbiAqIGI7XG5cdFx0dGhpcy5fYiA9IC1zaW4gKiBhICsgY29zICogYjtcblx0XHR0aGlzLl9jID0gY29zICogYyArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fZCA9IC1zaW4gKiBjICsgY29zICogZDtcblx0XHR0aGlzLl90eCArPSB0eCAqIGEgKyB0eSAqIGI7XG5cdFx0dGhpcy5fdHkgKz0gdHggKiBjICsgdHkgKiBkO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNoZWFyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YyA9IHRoaXMuX2M7XG5cdFx0dGhpcy5fYSArPSBzaGVhci55ICogdGhpcy5fYjtcblx0XHR0aGlzLl9jICs9IHNoZWFyLnkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueCAqIGE7XG5cdFx0dGhpcy5fZCArPSBzaGVhci54ICogYztcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2tldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNrZXcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLFxuXHRcdFx0XHRNYXRoLnRhbihza2V3LnkgKiB0b1JhZGlhbnMpKTtcblx0XHRyZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcblx0fSxcblxuXHRjb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYjE7XG5cdFx0dGhpcy5fYiA9IGIyICogYTEgKyBkMiAqIGIxO1xuXHRcdHRoaXMuX2MgPSBhMiAqIGMxICsgYzIgKiBkMTtcblx0XHR0aGlzLl9kID0gYjIgKiBjMSArIGQyICogZDE7XG5cdFx0dGhpcy5fdHggKz0gdHgyICogYTEgKyB0eTIgKiBiMTtcblx0XHR0aGlzLl90eSArPSB0eDIgKiBjMSArIHR5MiAqIGQxO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVDb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0dHgxID0gdGhpcy5fdHgsXG5cdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0dGhpcy5fYSA9IGEyICogYTEgKyBiMiAqIGMxO1xuXHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYjIgKiBkMTtcblx0XHR0aGlzLl9jID0gYzIgKiBhMSArIGQyICogYzE7XG5cdFx0dGhpcy5fZCA9IGMyICogYjEgKyBkMiAqIGQxO1xuXHRcdHRoaXMuX3R4ID0gYTIgKiB0eDEgKyBiMiAqIHR5MSArIHR4Mjtcblx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNoYWluOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdHR5MSA9IHRoaXMuX3R5LFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeChcblx0XHRcdFx0YTIgKiBhMSArIGMyICogYjEsXG5cdFx0XHRcdGEyICogYzEgKyBjMiAqIGQxLFxuXHRcdFx0XHRiMiAqIGExICsgZDIgKiBiMSxcblx0XHRcdFx0YjIgKiBjMSArIGQyICogZDEsXG5cdFx0XHRcdHR4MSArIHR4MiAqIGExICsgdHkyICogYjEsXG5cdFx0XHRcdHR5MSArIHR4MiAqIGMxICsgdHkyICogZDEpO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2MgPT09IDAgJiYgdGhpcy5fYiA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdG9yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHRpc1Npbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbiggc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzXG5cdFx0XHQ/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBkc3QsIGNvdW50KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHR4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHgsXG5cdFx0XHR4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRqID0gMCxcblx0XHRcdG1heCA9IDIgKiBjb3VudDtcblx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0dmFyIHggPSBzcmNbaSsrXSxcblx0XHRcdFx0eSA9IHNyY1tpKytdO1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHg7XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcblx0XHR9XG5cdFx0cmV0dXJuIGRzdDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4MSA9IHJlY3QueCxcblx0XHRcdHkxID0gcmVjdC55LFxuXHRcdFx0eDIgPSB4MSArIHJlY3Qud2lkdGgsXG5cdFx0XHR5MiA9IHkxICsgcmVjdC5oZWlnaHQsXG5cdFx0XHRjb29yZHMgPSBbIHgxLCB5MSwgeDIsIHkxLCB4MiwgeTIsIHgxLCB5MiBdO1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgNCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl90cmFuc2Zvcm1Db3JuZXJzKGJvdW5kcyksXG5cdFx0XHRtaW4gPSBjb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuXHRcdFx0dmFyIHZhbCA9IGNvb3Jkc1tpXSxcblx0XHRcdFx0aiA9IGkgJiAxO1xuXHRcdFx0aWYgKHZhbCA8IG1pbltqXSlcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0ZWxzZSBpZiAodmFsID4gbWF4W2pdKVxuXHRcdFx0XHRtYXhbal0gPSB2YWw7XG5cdFx0fVxuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2dldERldGVybWluYW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fYSAqIHRoaXMuX2QgLSB0aGlzLl9iICogdGhpcy5fYztcblx0XHRyZXR1cm4gaXNGaW5pdGUoZGV0KSAmJiAhTnVtZXJpY2FsLmlzWmVybyhkZXQpXG5cdFx0XHRcdCYmIGlzRmluaXRlKHRoaXMuX3R4KSAmJiBpc0Zpbml0ZSh0aGlzLl90eSlcblx0XHRcdFx0PyBkZXQgOiBudWxsO1xuXHR9LFxuXG5cdF9pbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIWRldClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLl90eTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0KHggKiB0aGlzLl9kIC0geSAqIHRoaXMuX2IpIC8gZGV0LFxuXHRcdFx0KHkgKiB0aGlzLl9hIC0geCAqIHRoaXMuX2MpIC8gZGV0LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLCBiID0gdGhpcy5fYiwgYyA9IHRoaXMuX2MsIGQgPSB0aGlzLl9kO1xuXHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGEgKiBkIC0gYiAqIGMpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdGEgLz0gc2NhbGVYO1xuXHRcdGIgLz0gc2NhbGVYO1xuXG5cdFx0dmFyIHNoZWFyID0gYSAqIGMgKyBiICogZDtcblx0XHRjIC09IGEgKiBzaGVhcjtcblx0XHRkIC09IGIgKiBzaGVhcjtcblxuXHRcdHZhciBzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG5cdFx0YyAvPSBzY2FsZVk7XG5cdFx0ZCAvPSBzY2FsZVk7XG5cdFx0c2hlYXIgLz0gc2NhbGVZO1xuXG5cdFx0aWYgKGEgKiBkIDwgYiAqIGMpIHtcblx0XHRcdGEgPSAtYTtcblx0XHRcdGIgPSAtYjtcblx0XHRcdHNoZWFyID0gLXNoZWFyO1xuXHRcdFx0c2NhbGVYID0gLXNjYWxlWDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlWCwgc2NhbGVZKSxcblx0XHRcdHJvdGF0aW9uOiAtTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEksXG5cdFx0XHRzaGVhcmluZzogc2hlYXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgdGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5IF07XG5cdH0sXG5cblx0Z2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnNjYWxpbmc7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkucm90YXRpb247XG5cdH0sXG5cblx0aW52ZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdHJldHVybiBkZXQgJiYgbmV3IE1hdHJpeChcblx0XHRcdFx0dGhpcy5fZCAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2MgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9iIC8gZGV0LFxuXHRcdFx0XHR0aGlzLl9hIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYiAqIHRoaXMuX3R5IC0gdGhpcy5fZCAqIHRoaXMuX3R4KSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2MgKiB0aGlzLl90eCAtIHRoaXMuX2EgKiB0aGlzLl90eSkgLyBkZXQpO1xuXHR9LFxuXG5cdHNoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdjJywgJ2InLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdHByb3AgPSAnXycgKyBuYW1lO1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlKSk7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRyZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24obGluZSkge1xuXHRcdHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHAxeCwgcDF5LCB2MXgsIHYxeSwgcDJ4LCBwMnksIHYyeCwgdjJ5LCBhc1ZlY3Rvcixcblx0XHRcdFx0aXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2MXggLT0gcDF4O1xuXHRcdFx0XHR2MXkgLT0gcDF5O1xuXHRcdFx0XHR2MnggLT0gcDJ4O1xuXHRcdFx0XHR2MnkgLT0gcDJ5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNyb3NzID0gdjF4ICogdjJ5IC0gdjF5ICogdjJ4O1xuXHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKGNyb3NzKSkge1xuXHRcdFx0XHR2YXIgZHggPSBwMXggLSBwMngsXG5cdFx0XHRcdFx0ZHkgPSBwMXkgLSBwMnksXG5cdFx0XHRcdFx0dTEgPSAodjJ4ICogZHkgLSB2MnkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHR1MiA9ICh2MXggKiBkeSAtIHYxeSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdFx0XHR1TWluID0gLWVwc2lsb24sXG5cdFx0XHRcdFx0dU1heCA9IDEgKyBlcHNpbG9uO1xuXHRcdFx0XHRpZiAoaXNJbmZpbml0ZVxuXHRcdFx0XHRcdFx0fHwgdU1pbiA8IHUxICYmIHUxIDwgdU1heCAmJiB1TWluIDwgdTIgJiYgdTIgPCB1TWF4KSB7XG5cdFx0XHRcdFx0aWYgKCFpc0luZmluaXRlKSB7XG5cdFx0XHRcdFx0XHR1MSA9IHUxIDw9IDAgPyAwIDogdTEgPj0gMSA/IDEgOiB1MTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0cDF4ICsgdTEgKiB2MXgsXG5cdFx0XHRcdFx0XHRcdHAxeSArIHUxICogdjF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTaWRlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IsIGlzSW5maW5pdGUpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHYyeCA9IHggLSBweCxcblx0XHRcdFx0djJ5ID0geSAtIHB5LFxuXHRcdFx0XHRjY3cgPSB2MnggKiB2eSAtIHYyeSAqIHZ4O1xuXHRcdFx0aWYgKGNjdyA9PT0gMCAmJiAhaXNJbmZpbml0ZSkge1xuXHRcdFx0XHRjY3cgPSAodjJ4ICogdnggKyB2MnggKiB2eCkgLyAodnggKiB2eCArIHZ5ICogdnkpO1xuXHRcdFx0XHRpZiAoY2N3ID49IDAgJiYgY2N3IDw9IDEpXG5cdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG5cdFx0fSxcblxuXHRcdGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZ4ID09PSAwID8gdnkgPiAwID8geCAtIHB4IDogcHggLSB4XG5cdFx0XHRcdCA6IHZ5ID09PSAwID8gdnggPCAwID8geSAtIHB5IDogcHkgLSB5XG5cdFx0XHRcdCA6ICgoeC1weCkgKiB2eSAtICh5LXB5KSAqIHZ4KSAvIE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMubGF5ZXJzID0gW107XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmxheWVycywgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMubGF5ZXJzW2ldLnJlbW92ZSgpO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVycy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5pbml0aWFsaXplKHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMgfSk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fc2VsZWN0ZWRJdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHRcdGlmIChpdGVtLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBMYXllcikge1xuXHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbaXRlbV0sIGluZGV4LCAwKTtcblx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcywgdHJ1ZSk7XG5cdFx0XHRpZiAodGhpcy5fY2hhbmdlcylcblx0XHRcdFx0aXRlbS5fY2hhbmdlZCg1KTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gaXRlbTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSB7XG5cdFx0XHQodGhpcy5fYWN0aXZlTGF5ZXJcblx0XHRcdFx0fHwgdGhpcy5pbnNlcnRDaGlsZChpbmRleCwgbmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSkpXG5cdFx0XHRcdFx0Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRpZiAoaXRlbS5fc2VsZWN0ZWQpIHtcblx0XHRcdGlmIChzZWxlY3RlZEl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuXHRcdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCsrO1xuXHRcdFx0XHRzZWxlY3RlZEl0ZW1zW2lkXSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZEl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0c2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGVkSXRlbXMpXG5cdFx0XHRzZWxlY3RlZEl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5sYXllcnNbaV0uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHJlcykgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0b2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG5cdFx0XHRwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuXHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG5cdFx0XHR1cGRhdGVNYXRyaXg6IHRydWVcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGF5ZXJzID0gdGhpcy5sYXllcnMsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcyxcblx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gaXRlbXMpXG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2wnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbChpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHR0aGlzLnByb2plY3Quc3ltYm9scy5wdXNoKHRoaXMpO1xuXHRcdGlmIChpdGVtKVxuXHRcdFx0dGhpcy5zZXREZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NsYXNzLCB0aGlzLl9kZWZpbml0aW9uXSxcblx0XHRcdFx0XHRvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0dGhpcy5wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudFN5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2RlZmluaXRpb24pXG5cdFx0XHR0aGlzLl9kZWZpbml0aW9uLl9wYXJlbnRTeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2RlZmluaXRpb24gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3BhcmVudFN5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFBsYWNlZFN5bWJvbCh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sKHRoaXMuX2RlZmluaXRpb24uY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHJldHVybiBzeW1ib2wgPT09IHRoaXNcblx0XHRcdFx0fHwgc3ltYm9sICYmIHRoaXMuZGVmaW5pdGlvbi5lcXVhbHMoc3ltYm9sLmRlZmluaXRpb24pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdHN0YXRpY3M6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcblx0XHRcdGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcylcblx0XHRcdFx0c3JjLl9zZXJpYWxpemVGaWVsZHMgPSBuZXcgQmFzZShcblx0XHRcdFx0XHRcdHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRcdHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHROT19JTlNFUlQ6IHsgaW5zZXJ0OiBmYWxzZSB9XG5cdH0sXG5cblx0X2NsYXNzOiAnSXRlbScsXG5cdF9hcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IGZhbHNlLFxuXHRfc2VsZWN0Q2hpbGRyZW46IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0bmFtZTogbnVsbCxcblx0XHRhcHBseU1hdHJpeDogbnVsbCxcblx0XHRtYXRyaXg6IG5ldyBNYXRyaXgoKSxcblx0XHRwaXZvdDogbnVsbCxcblx0XHRsb2NrZWQ6IGZhbHNlLFxuXHRcdHZpc2libGU6IHRydWUsXG5cdFx0YmxlbmRNb2RlOiAnbm9ybWFsJyxcblx0XHRvcGFjaXR5OiAxLFxuXHRcdGd1aWRlOiBmYWxzZSxcblx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0Y2xpcE1hc2s6IGZhbHNlLFxuXHRcdGRhdGE6IHt9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHtcblx0fSxcblxuXHRfaW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJvcHMsIHBvaW50KSB7XG5cdFx0dmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcblx0XHRcdGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmICghaW50ZXJuYWwpXG5cdFx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmIHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdGlmIChwb2ludClcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuXHRcdG1hdHJpeC5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3N0eWxlID0gbmV3IFN0eWxlKHByb2plY3QuX2N1cnJlbnRTdHlsZSwgdGhpcywgcHJvamVjdCk7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KSB7XG5cdFx0XHRpZiAoaW50ZXJuYWwgfHwgaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNQcm9wcyAmJiBwcm9wcy5wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXJlbnQocHJvcHMucGFyZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdChwcm9qZWN0Ll9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoKSkuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChoYXNQcm9wcyAmJiBwcm9wcyAhPT0gSXRlbS5OT19JTlNFUlQpXG5cdFx0XHR0aGlzLl9zZXQocHJvcHMsIHsgaW5zZXJ0OiB0cnVlLCBwcm9qZWN0OiB0cnVlLCBwYXJlbnQ6IHRydWUgfSxcblx0XHRcdFx0XHR0cnVlKTtcblx0XHRyZXR1cm4gaGFzUHJvcHM7XG5cdH0sXG5cblx0X2V2ZW50czogQmFzZS5lYWNoKFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uQ2xpY2snLFxuXHRcdFx0J29uRG91YmxlQ2xpY2snLCAnb25Nb3VzZU1vdmUnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZSddLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5faW5zdGFsbEV2ZW50KHR5cGUpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl91bmluc3RhbGxFdmVudCh0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdG9uTG9hZDoge31cblx0XHR9XG5cdCksXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHZhciBwcm9wcyA9IHt9LFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoZmllbGRzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZmllbGRzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoYXRba2V5XTtcblx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwga2V5ID09PSAnbGVhZGluZydcblx0XHRcdFx0XHRcdD8gZmllbGRzLmZvbnRTaXplICogMS4yIDogZmllbGRzW2tleV0pKSB7XG5cdFx0XHRcdFx0cHJvcHNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zLFxuXHRcdFx0XHRcdFx0XHRrZXkgIT09ICdkYXRhJywgZGljdGlvbmFyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXJpYWxpemUodGhpcy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0c2VyaWFsaXplKHRoaXMuX3N0eWxlLl9kZWZhdWx0cyk7XG5cdFx0cmV0dXJuIFsgdGhpcy5fY2xhc3MsIHByb3BzIF07XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0dmFyIHN5bWJvbCA9IHRoaXMuX3BhcmVudFN5bWJvbCxcblx0XHRcdGNhY2hlUGFyZW50ID0gdGhpcy5fcGFyZW50IHx8IHN5bWJvbCxcblx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlZCA9XG5cdFx0XHRcdFx0dGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fY3VycmVudFBhdGggPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjYWNoZVBhcmVudFxuXHRcdFx0XHQmJiAoZmxhZ3MgJiA0MCkpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUoY2FjaGVQYXJlbnQpO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAyKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdH1cblx0XHRpZiAocHJvamVjdCkge1xuXHRcdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvamVjdC5fY2hhbmdlcykge1xuXHRcdFx0XHR2YXIgZW50cnkgPSBwcm9qZWN0Ll9jaGFuZ2VzQnlJZFt0aGlzLl9pZF07XG5cdFx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHRcdGVudHJ5LmZsYWdzIHw9IGZsYWdzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVudHJ5ID0geyBpdGVtOiB0aGlzLCBmbGFnczogZmxhZ3MgfTtcblx0XHRcdFx0XHRwcm9qZWN0Ll9jaGFuZ2VzQnlJZFt0aGlzLl9pZF0gPSBlbnRyeTtcblx0XHRcdFx0XHRwcm9qZWN0Ll9jaGFuZ2VzLnB1c2goZW50cnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzeW1ib2wpXG5cdFx0XHRzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAocHJvcHMpXG5cdFx0XHR0aGlzLl9zZXQocHJvcHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH0sXG5cblx0Z2V0TmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdH0sXG5cblx0c2V0TmFtZTogZnVuY3Rpb24obmFtZSwgdW5pcXVlKSB7XG5cblx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0aWYgKG5hbWUgPT09ICgrbmFtZSkgKyAnJylcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnTmFtZXMgY29uc2lzdGluZyBvbmx5IG9mIG51bWJlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAobmFtZSAmJiBwYXJlbnQpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHBhcmVudC5fY2hpbGRyZW4sXG5cdFx0XHRcdG5hbWVkQ2hpbGRyZW4gPSBwYXJlbnQuX25hbWVkQ2hpbGRyZW4sXG5cdFx0XHRcdG9yaWcgPSBuYW1lLFxuXHRcdFx0XHRpID0gMTtcblx0XHRcdHdoaWxlICh1bmlxdWUgJiYgY2hpbGRyZW5bbmFtZV0pXG5cdFx0XHRcdG5hbWUgPSBvcmlnICsgJyAnICsgKGkrKyk7XG5cdFx0XHQobmFtZWRDaGlsZHJlbltuYW1lXSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0gfHwgW10pLnB1c2godGhpcyk7XG5cdFx0XHRjaGlsZHJlbltuYW1lXSA9IHRoaXM7XG5cdFx0fVxuXHRcdHRoaXMuX25hbWUgPSBuYW1lIHx8IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9jaGFuZ2VkKDEyOCk7XG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdHlsZTtcblx0fSxcblxuXHRzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR0aGlzLmdldFN0eWxlKCkuc2V0KHN0eWxlKTtcblx0fVxufSwgQmFzZS5lYWNoKFsnbG9ja2VkJywgJ3Zpc2libGUnLCAnYmxlbmRNb2RlJywgJ29wYWNpdHknLCAnZ3VpZGUnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHR9O1xuXHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpc1tuYW1lXSkge1xuXHRcdFx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQobmFtZSA9PT0gJ19sb2NrZWQnXG5cdFx0XHRcdFx0XHQ/IDEyOCA6IDEyOSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcbnt9KSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfbG9ja2VkOiBmYWxzZSxcblxuXHRfdmlzaWJsZTogdHJ1ZSxcblxuXHRfYmxlbmRNb2RlOiAnbm9ybWFsJyxcblxuXHRfb3BhY2l0eTogMSxcblxuXHRfZ3VpZGU6IGZhbHNlLFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9zZWxlY3RDaGlsZHJlbikge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKGNoaWxkcmVuW2ldLmlzU2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCwgbm9DaGlsZHJlbikge1xuXHRcdGlmICghbm9DaGlsZHJlbiAmJiB0aGlzLl9zZWxlY3RDaGlsZHJlbikge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdH1cblx0XHRpZiAoKHNlbGVjdGVkID0gISFzZWxlY3RlZCkgXiB0aGlzLl9zZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblx0XHRcdHRoaXMuX3Byb2plY3QuX3VwZGF0ZVNlbGVjdGlvbih0aGlzKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTI5KTtcblx0XHR9XG5cdH0sXG5cblx0X3NlbGVjdGVkOiBmYWxzZSxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiB0aGlzLl9zZWxlY3RlZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmICghY2hpbGRyZW5baV0uaXNGdWxseVNlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fSxcblxuXHRzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnNldEZ1bGx5U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdH1cblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkLCB0cnVlKTtcblx0fSxcblxuXHRpc0NsaXBNYXNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xpcE1hc2s7XG5cdH0sXG5cblx0c2V0Q2xpcE1hc2s6IGZ1bmN0aW9uKGNsaXBNYXNrKSB7XG5cdFx0aWYgKHRoaXMuX2NsaXBNYXNrICE9IChjbGlwTWFzayA9ICEhY2xpcE1hc2spKSB7XG5cdFx0XHR0aGlzLl9jbGlwTWFzayA9IGNsaXBNYXNrO1xuXHRcdFx0aWYgKGNsaXBNYXNrKSB7XG5cdFx0XHRcdHRoaXMuc2V0RmlsbENvbG9yKG51bGwpO1xuXHRcdFx0XHR0aGlzLnNldFN0cm9rZUNvbG9yKG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdFx0dGhpcy5fcGFyZW50Ll9jaGFuZ2VkKDEwMjQpO1xuXHRcdH1cblx0fSxcblxuXHRfY2xpcE1hc2s6IGZhbHNlLFxuXG5cdGdldERhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fZGF0YSlcblx0XHRcdHRoaXMuX2RhdGEgPSB7fTtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fSxcblxuXHRzZXREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdH0sXG5cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uLFxuXHRcdFx0Y3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0aWYgKCFwb3NpdGlvbikge1xuXHRcdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uID0gcGl2b3Rcblx0XHRcdFx0XHQ/IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcih0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHRoaXMsICdzZXRQb3NpdGlvbicpO1xuXHR9LFxuXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykuc3VidHJhY3QodGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9LFxuXG5cdGdldFBpdm90OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRpZiAocGl2b3QpIHtcblx0XHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRcdHBpdm90ID0gbmV3IGN0b3IocGl2b3QueCwgcGl2b3QueSwgdGhpcywgJ3NldFBpdm90Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBwaXZvdDtcblx0fSxcblxuXHRzZXRQaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGl2b3QgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSwgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0X3Bpdm90OiBudWxsLFxufSwgQmFzZS5lYWNoKFsnYm91bmRzJywgJ3N0cm9rZUJvdW5kcycsICdoYW5kbGVCb3VuZHMnLCAncm91Z2hCb3VuZHMnLFxuXHRcdCdpbnRlcm5hbEJvdW5kcycsICdpbnRlcm5hbFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBnZXR0ZXIgPSAnZ2V0JyArIEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0bWF0Y2ggPSBrZXkubWF0Y2goL15pbnRlcm5hbCguKikkLyksXG5cdFx0XHRpbnRlcm5hbEdldHRlciA9IG1hdGNoID8gJ2dldCcgKyBtYXRjaFsxXSA6IG51bGw7XG5cdFx0dGhpc1tnZXR0ZXJdID0gZnVuY3Rpb24oX21hdHJpeCkge1xuXHRcdFx0dmFyIGJvdW5kc0dldHRlciA9IHRoaXMuX2JvdW5kc0dldHRlcixcblx0XHRcdFx0bmFtZSA9ICFpbnRlcm5hbEdldHRlciAmJiAodHlwZW9mIGJvdW5kc0dldHRlciA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdD8gYm91bmRzR2V0dGVyIDogYm91bmRzR2V0dGVyICYmIGJvdW5kc0dldHRlcltnZXR0ZXJdKVxuXHRcdFx0XHRcdFx0fHwgZ2V0dGVyLFxuXHRcdFx0XHRib3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHMobmFtZSwgX21hdHJpeCwgdGhpcyxcblx0XHRcdFx0XHRcdGludGVybmFsR2V0dGVyKTtcblx0XHRcdHJldHVybiBrZXkgPT09ICdib3VuZHMnXG5cdFx0XHRcdFx0PyBuZXcgTGlua2VkUmVjdGFuZ2xlKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0LCB0aGlzLCAnc2V0Qm91bmRzJylcblx0XHRcdFx0XHQ6IGJvdW5kcztcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT0gMClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcywgY2FjaGVJdGVtKTtcblx0XHR2YXIgeDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkLl92aXNpYmxlICYmICFjaGlsZC5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBjaGlsZC5fZ2V0Q2FjaGVkQm91bmRzKGdldHRlcixcblx0XHRcdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksIGNhY2hlSXRlbSk7XG5cdFx0XHRcdHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG5cdFx0XHRcdHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG5cdFx0XHRcdHgyID0gTWF0aC5tYXgocmVjdC54ICsgcmVjdC53aWR0aCwgeDIpO1xuXHRcdFx0XHR5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpc0Zpbml0ZSh4MSlcblx0XHRcdFx0PyBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSlcblx0XHRcdFx0OiBuZXcgUmVjdGFuZ2xlKCk7XG5cdH0sXG5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0Y2VudGVyID0gcmVjdC5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0aWYgKHJlY3Qud2lkdGggIT0gYm91bmRzLndpZHRoIHx8IHJlY3QuaGVpZ2h0ICE9IGJvdW5kcy5oZWlnaHQpIHtcblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAxLFxuXHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQgIT0gMCA/IHJlY3QuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCA6IDEpO1xuXHRcdH1cblx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZSgtY2VudGVyLngsIC1jZW50ZXIueSk7XG5cdFx0dGhpcy50cmFuc2Zvcm0obWF0cml4KTtcblx0fSxcblxuXHRfZ2V0Q2FjaGVkQm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtLCBpbnRlcm5hbEdldHRlcikge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHZhciBfbWF0cml4ID0gaW50ZXJuYWxHZXR0ZXIgPyBudWxsIDogdGhpcy5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdGNhY2hlID0gKCFtYXRyaXggfHwgbWF0cml4LmVxdWFscyhfbWF0cml4KSkgJiYgZ2V0dGVyO1xuXHRcdEl0ZW0uX3VwZGF0ZUJvdW5kc0NhY2hlKHRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnRTeW1ib2wsIGNhY2hlSXRlbSk7XG5cdFx0aWYgKGNhY2hlICYmIHRoaXMuX2JvdW5kcyAmJiB0aGlzLl9ib3VuZHNbY2FjaGVdKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2JvdW5kc1tjYWNoZV0uY2xvbmUoKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0Qm91bmRzKGludGVybmFsR2V0dGVyIHx8IGdldHRlcixcblx0XHRcdFx0bWF0cml4IHx8IF9tYXRyaXgsIGNhY2hlSXRlbSk7XG5cdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgY2FjaGVkID0gdGhpcy5fYm91bmRzW2NhY2hlXSA9IGJvdW5kcy5jbG9uZSgpO1xuXHRcdFx0Y2FjaGVkLl9pbnRlcm5hbCA9ICEhaW50ZXJuYWxHZXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF91cGRhdGVCb3VuZHNDYWNoZTogZnVuY3Rpb24ocGFyZW50LCBpdGVtKSB7XG5cdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdHZhciBpZCA9IGl0ZW0uX2lkLFxuXHRcdFx0XHRcdHJlZiA9IHBhcmVudC5fYm91bmRzQ2FjaGUgPSBwYXJlbnQuX2JvdW5kc0NhY2hlIHx8IHtcblx0XHRcdFx0XHRcdGlkczoge30sXG5cdFx0XHRcdFx0XHRsaXN0OiBbXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGlmICghcmVmLmlkc1tpZF0pIHtcblx0XHRcdFx0XHRyZWYubGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdHJlZi5pZHNbaWRdID0gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfY2xlYXJCb3VuZHNDYWNoZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIGNhY2hlID0gaXRlbS5fYm91bmRzQ2FjaGU7XG5cdFx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdFx0aXRlbS5fYm91bmRzID0gaXRlbS5fcG9zaXRpb24gPSBpdGVtLl9ib3VuZHNDYWNoZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjYWNoZS5saXN0LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRcdHZhciBvdGhlciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKG90aGVyICE9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHRvdGhlci5fYm91bmRzID0gb3RoZXIuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyLl9ib3VuZHNDYWNoZSlcblx0XHRcdFx0XHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShvdGhlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCk7XG5cdFx0cmV0dXJuIGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5yb3RhdGlvbjtcblx0fSxcblxuXHRzZXRSb3RhdGlvbjogZnVuY3Rpb24ocm90YXRpb24pIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblx0XHRpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG5cdFx0XHRkZWNvbXBvc2VkLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpLFxuXHRcdFx0c2NhbGluZyA9IGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nLFxuXHRcdFx0Y3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIHNjYWxpbmcgJiYgbmV3IGN0b3Ioc2NhbGluZy54LCBzY2FsaW5nLnksIHRoaXMsICdzZXRTY2FsaW5nJyk7XG5cdH0sXG5cblx0c2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKTtcblx0XHRpZiAoY3VycmVudCkge1xuXHRcdFx0dmFyIHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSB9KSxcblx0XHRcdFx0ZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHRcdGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRtYXRyaXguaW5pdGlhbGl6ZS5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0R2xvYmFsTWF0cml4OiBmdW5jdGlvbihfZG9udENsb25lKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCxcblx0XHRcdHVwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4Ll91cGRhdGVWZXJzaW9uICE9PSB1cGRhdGVWZXJzaW9uKVxuXHRcdFx0bWF0cml4ID0gbnVsbDtcblx0XHRpZiAoIW1hdHJpeCkge1xuXHRcdFx0bWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0bWF0cml4LnByZUNvbmNhdGVuYXRlKHBhcmVudC5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuXHRcdFx0bWF0cml4Ll91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHR9XG5cdFx0cmV0dXJuIF9kb250Q2xvbmUgPyBtYXRyaXggOiBtYXRyaXguY2xvbmUoKTtcblx0fSxcblxuXHRnZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcGx5TWF0cml4O1xuXHR9LFxuXG5cdHNldEFwcGx5TWF0cml4OiBmdW5jdGlvbihhcHBseSkge1xuXHRcdGlmICh0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmICEhYXBwbHkpXG5cdFx0XHR0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0fSxcblxuXHRnZXRUcmFuc2Zvcm1Db250ZW50OiAnI2dldEFwcGx5TWF0cml4Jyxcblx0c2V0VHJhbnNmb3JtQ29udGVudDogJyNzZXRBcHBseU1hdHJpeCcsXG59LCB7XG5cdGdldFByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0O1xuXHR9LFxuXG5cdF9zZXRQcm9qZWN0OiBmdW5jdGlvbihwcm9qZWN0LCBpbnN0YWxsRXZlbnRzKSB7XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QgIT09IHByb2plY3QpIHtcblx0XHRcdGlmICh0aGlzLl9wcm9qZWN0KVxuXHRcdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0XHRpbnN0YWxsRXZlbnRzID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKGluc3RhbGxFdmVudHMpXG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKHRydWUpO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0LmdldFZpZXcoKTtcblx0fSxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gX2luc3RhbGxFdmVudHMoaW5zdGFsbCkge1xuXHRcdF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLl9pbnN0YWxsRXZlbnRzKGluc3RhbGwpO1xuXHR9LFxuXG5cdGdldExheWVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMYXllcilcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHR9LFxuXG5cdHNldFBhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdH0sXG5cblx0c2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuXHR9LFxuXG5cdGdldEZpcnN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldExhc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuW3RoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDFdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fY2hpbGRyZW5bdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPT09IHRoaXMgfHwgaXRlbSAmJiB0aGlzLl9jbGFzcyA9PT0gaXRlbS5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3R5bGUuZXF1YWxzKGl0ZW0uX3N0eWxlKVxuXHRcdFx0XHQmJiB0aGlzLl9tYXRyaXguZXF1YWxzKGl0ZW0uX21hdHJpeClcblx0XHRcdFx0JiYgdGhpcy5fbG9ja2VkID09PSBpdGVtLl9sb2NrZWRcblx0XHRcdFx0JiYgdGhpcy5fdmlzaWJsZSA9PT0gaXRlbS5fdmlzaWJsZVxuXHRcdFx0XHQmJiB0aGlzLl9ibGVuZE1vZGUgPT09IGl0ZW0uX2JsZW5kTW9kZVxuXHRcdFx0XHQmJiB0aGlzLl9vcGFjaXR5ID09PSBpdGVtLl9vcGFjaXR5XG5cdFx0XHRcdCYmIHRoaXMuX2NsaXBNYXNrID09PSBpdGVtLl9jbGlwTWFza1xuXHRcdFx0XHQmJiB0aGlzLl9ndWlkZSA9PT0gaXRlbS5fZ3VpZGVcblx0XHRcdFx0JiYgdGhpcy5fZXF1YWxzKGl0ZW0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fY2hpbGRyZW4sIGl0ZW0uX2NoaWxkcmVuKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKG5ldyB0aGlzLmNvbnN0cnVjdG9yKEl0ZW0uTk9fSU5TRVJUKSwgaW5zZXJ0KTtcblx0fSxcblxuXHRfY2xvbmU6IGZ1bmN0aW9uKGNvcHksIGluc2VydCwgaW5jbHVkZU1hdHJpeCkge1xuXHRcdHZhciBrZXlzID0gWydfbG9ja2VkJywgJ192aXNpYmxlJywgJ19ibGVuZE1vZGUnLCAnX29wYWNpdHknLFxuXHRcdFx0XHQnX2NsaXBNYXNrJywgJ19ndWlkZSddLFxuXHRcdFx0Y2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRjb3B5LnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29weS5hZGRDaGlsZChjaGlsZHJlbltpXS5jbG9uZShmYWxzZSksIHRydWUpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdGNvcHlba2V5XSA9IHRoaXNba2V5XTtcblx0XHR9XG5cdFx0aWYgKGluY2x1ZGVNYXRyaXggIT09IGZhbHNlKVxuXHRcdFx0Y29weS5fbWF0cml4LmluaXRpYWxpemUodGhpcy5fbWF0cml4KTtcblx0XHRjb3B5LnNldEFwcGx5TWF0cml4KHRoaXMuX2FwcGx5TWF0cml4KTtcblx0XHRjb3B5LnNldFBpdm90KHRoaXMuX3Bpdm90KTtcblx0XHRjb3B5LnNldFNlbGVjdGVkKHRoaXMuX3NlbGVjdGVkKTtcblx0XHRjb3B5Ll9kYXRhID0gdGhpcy5fZGF0YSA/IEJhc2UuY2xvbmUodGhpcy5fZGF0YSkgOiBudWxsO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Lmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0Y29weS5zZXROYW1lKHRoaXMuX25hbWUsIHRydWUpO1xuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXG5cdGNvcHlUbzogZnVuY3Rpb24oaXRlbU9yUHJvamVjdCkge1xuXHRcdHJldHVybiBpdGVtT3JQcm9qZWN0LmFkZENoaWxkKHRoaXMuY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRyYXN0ZXJpemU6IGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcblx0XHRcdHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuXHRcdFx0dG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcblx0XHRcdGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplLm11bHRpcGx5KHNjYWxlKSksXG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgbmV3IEJhc2UoeyBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5zZXRDYW52YXMoY2FudmFzKTtcblx0XHRyYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKVxuXHRcdFx0XHQuc2NhbGUoMSAvIHNjYWxlKSk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2NvbnRhaW5zKFxuXHRcdFx0XHR0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jaGlsZHJlbltpXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0luc2lkZSh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzLmdldEJvdW5kcygpKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRyZWN0YW5nbGU6IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSxcblx0XHRcdG1hdHJpeDogdGhpcy5fbWF0cml4LFxuXHRcdFx0aW5zZXJ0OiBmYWxzZSxcblx0XHR9KTtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbihpdGVtLCBfbWF0cml4KSB7XG5cdFx0aWYgKCEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLl9hc1BhdGhJdGVtKCkuZ2V0SW50ZXJzZWN0aW9ucyhpdGVtLl9hc1BhdGhJdGVtKCksIG51bGwsXG5cdFx0XHRcdF9tYXRyaXggfHwgaXRlbS5fbWF0cml4LCB0cnVlKS5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oaXRUZXN0KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKHRoaXMuX2xvY2tlZCB8fCAhdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9ndWlkZSAmJiAhb3B0aW9ucy5ndWlkZXNcblx0XHRcdFx0fHwgdGhpcy5pc0VtcHR5KCkpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRwYXJlbnRUb3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4LFxuXHRcdFx0dmlldyA9IHRoaXMuZ2V0VmlldygpLFxuXHRcdFx0dG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4XG5cdFx0XHRcdFx0PyBwYXJlbnRUb3RhbE1hdHJpeC5jaGFpbihtYXRyaXgpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZUNvbmNhdGVuYXRlKHZpZXcuX21hdHJpeCksXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuXHRcdFx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZygxLCB0b3RhbE1hdHJpeC5pbnZlcnRlZCgpKVxuXHRcdFx0XHRcdCkubXVsdGlwbHkoXG5cdFx0XHRcdFx0XHRNYXRoLm1heChvcHRpb25zLnRvbGVyYW5jZSwgMWUtNilcblx0XHRcdFx0XHQpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuZ2V0SW50ZXJuYWxSb3VnaEJvdW5kcygpXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNoZWNrU2VsZiA9ICEob3B0aW9ucy5ndWlkZXMgJiYgIXRoaXMuX2d1aWRlXG5cdFx0XHRcdHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkXG5cdFx0XHRcdHx8IG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgIT09IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHR8fCBvcHRpb25zLmNsYXNzICYmICEodGhpcyBpbnN0YW5jZW9mIG9wdGlvbnMuY2xhc3MpKSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVzO1xuXG5cdFx0ZnVuY3Rpb24gY2hlY2tCb3VuZHModHlwZSwgcGFydCkge1xuXHRcdFx0dmFyIHB0ID0gYm91bmRzWydnZXQnICsgcGFydF0oKTtcblx0XHRcdGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LFxuXHRcdFx0XHRcdFx0eyBuYW1lOiBCYXNlLmh5cGhlbmF0ZShwYXJ0KSwgcG9pbnQ6IHB0IH0pO1xuXHRcdH1cblxuXHRcdGlmIChjaGVja1NlbGYgJiYgKG9wdGlvbnMuY2VudGVyIHx8IG9wdGlvbnMuYm91bmRzKSAmJiB0aGlzLl9wYXJlbnQpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG5cdFx0XHRpZiAob3B0aW9ucy5jZW50ZXIpXG5cdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cdFx0XHRpZiAoIXJlcyAmJiBvcHRpb25zLmJvdW5kcykge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gW1xuXHRcdFx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspXG5cdFx0XHRcdFx0cmVzID0gY2hlY2tCb3VuZHMoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoaWxkcmVuID0gIXJlcyAmJiB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5fZ2V0Q2hpbGRIaXRUZXN0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDAgJiYgIXJlczsgaS0tKVxuXHRcdFx0XHRyZXMgPSBjaGlsZHJlbltpXS5faGl0VGVzdChwb2ludCwgb3B0cyk7XG5cdFx0fVxuXHRcdGlmICghcmVzICYmIGNoZWNrU2VsZilcblx0XHRcdHJlcyA9IHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKTtcblx0XHRpZiAocmVzICYmIHJlcy5wb2ludClcblx0XHRcdHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcblx0XHRvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4O1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9LFxuXG5cdG1hdGNoZXM6IGZ1bmN0aW9uKG5hbWUsIGNvbXBhcmUpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgbmFtZTtcblx0XHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG5hbWUodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB2YWx1ZSA9IC9eKGVtcHR5fGVkaXRhYmxlKSQvLnRlc3QobmFtZSlcblx0XHRcdFx0XHQ/IHRoaXNbJ2lzJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0oKVxuXHRcdFx0XHRcdDogbmFtZSA9PT0gJ3R5cGUnXG5cdFx0XHRcdFx0XHQ/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHRcdFx0OiB0aGlzW25hbWVdO1xuXHRcdFx0aWYgKC9eKGNvbnN0cnVjdG9yfGNsYXNzKSQvLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIGNvbXBhcmUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUudGVzdCh2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG5cdFx0XHRcdGlmICghbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpXG5cdFx0XHRcdFswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhjaGlsZHJlbiwgbWF0Y2gsIG1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdGZpcnN0T25seSkge1xuXHRcdFx0aWYgKCFwYXJhbSAmJiB0eXBlb2YgbWF0Y2ggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBvdmVybGFwcGluZyA9IG1hdGNoLm92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdGluc2lkZSA9IG1hdGNoLmluc2lkZSxcblx0XHRcdFx0XHRib3VuZHMgPSBvdmVybGFwcGluZyB8fCBpbnNpZGUsXG5cdFx0XHRcdFx0cmVjdCA9IGJvdW5kcyAmJiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSk7XG5cdFx0XHRcdHBhcmFtID0ge1xuXHRcdFx0XHRcdGl0ZW1zOiBbXSxcblx0XHRcdFx0XHRpbnNpZGU6ICEhaW5zaWRlLFxuXHRcdFx0XHRcdG92ZXJsYXBwaW5nOiAhIW92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdHJlY3Q6IHJlY3QsXG5cdFx0XHRcdFx0cGF0aDogb3ZlcmxhcHBpbmcgJiYgbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdFx0XHRcdHJlY3RhbmdsZTogcmVjdCxcblx0XHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoYm91bmRzKVxuXHRcdFx0XHRcdG1hdGNoID0gQmFzZS5zZXQoe30sIG1hdGNoLFxuXHRcdFx0XHRcdFx0XHR7IGluc2lkZTogdHJ1ZSwgb3ZlcmxhcHBpbmc6IHRydWUgfSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaXRlbXMgPSBwYXJhbSAmJiBwYXJhbS5pdGVtcyxcblx0XHRcdFx0cmVjdCA9IHBhcmFtICYmIHBhcmFtLnJlY3Q7XG5cdFx0XHRtYXRyaXggPSByZWN0ICYmIChtYXRyaXggfHwgbmV3IE1hdHJpeCgpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRcdGNoaWxkTWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5jaGFpbihjaGlsZC5fbWF0cml4KSxcblx0XHRcdFx0XHRhZGQgPSB0cnVlO1xuXHRcdFx0XHRpZiAocmVjdCkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGlsZC5nZXRCb3VuZHMoY2hpbGRNYXRyaXgpO1xuXHRcdFx0XHRcdGlmICghcmVjdC5pbnRlcnNlY3RzKGJvdW5kcykpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiAoIShwYXJhbS5pbnNpZGUgJiYgcmVjdC5jb250YWlucyhib3VuZHMpKVxuXHRcdFx0XHRcdFx0XHQmJiAhKHBhcmFtLm92ZXJsYXBwaW5nICYmIChib3VuZHMuY29udGFpbnMocmVjdClcblx0XHRcdFx0XHRcdFx0XHR8fCBwYXJhbS5wYXRoLmludGVyc2VjdHMoY2hpbGQsIGNoaWxkTWF0cml4KSkpKVxuXHRcdFx0XHRcdFx0YWRkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFkZCAmJiBjaGlsZC5tYXRjaGVzKG1hdGNoKSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdGlmIChmaXJzdE9ubHkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2V0SXRlbXMoY2hpbGQuX2NoaWxkcmVuLCBtYXRjaCxcblx0XHRcdFx0XHRcdGNoaWxkTWF0cml4LCBwYXJhbSxcblx0XHRcdFx0XHRcdGZpcnN0T25seSk7XG5cdFx0XHRcdGlmIChmaXJzdE9ubHkgJiYgaXRlbXMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn0sIHtcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dmFyIHJlcyA9IEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcblx0XHRyZXR1cm4gcmVzICE9PSB0aGlzXG5cdFx0XHRcdD8gdGhpcy5hZGRDaGlsZChyZXMpXG5cdFx0XHRcdDogcmVzO1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCh1bmRlZmluZWQsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHR2YXIgcmVzID0gaXRlbSA/IHRoaXMuaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIFtpdGVtXSwgX3ByZXNlcnZlKSA6IG51bGw7XG5cdFx0cmV0dXJuIHJlcyAmJiByZXNbMF07XG5cdH0sXG5cblx0YWRkQ2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSwgX3Byb3RvKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGl0ZW1zKTtcblx0XHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpZiAoX3Byb3RvICYmICEoaXRlbSBpbnN0YW5jZW9mIF9wcm90bykpIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHNoaWZ0ID0gaXRlbS5fcGFyZW50ID09PSB0aGlzICYmIGl0ZW0uX2luZGV4IDwgaW5kZXg7XG5cdFx0XHRcdFx0aWYgKGl0ZW0uX3JlbW92ZShmYWxzZSwgdHJ1ZSkgJiYgc2hpZnQpXG5cdFx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRCYXNlLnNwbGljZShjaGlsZHJlbiwgaXRlbXMsIGluZGV4LCAwKTtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0bm90aWZ5U2VsZiA9IHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGl0ZW0uX3BhcmVudCA9IHRoaXM7XG5cdFx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcy5fcHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtLl9uYW1lKVxuXHRcdFx0XHRcdGl0ZW0uc2V0TmFtZShpdGVtLl9uYW1lKTtcblx0XHRcdFx0aWYgKG5vdGlmeVNlbGYpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtcyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfaW5zZXJ0U2libGluZzogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnRcblx0XHRcdFx0PyB0aGlzLl9wYXJlbnQuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGluc2VydEFib3ZlOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gaXRlbS5faW5zZXJ0U2libGluZyhpdGVtLl9pbmRleCArIDEsIHRoaXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0QmVsb3c6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiBpdGVtLl9pbnNlcnRTaWJsaW5nKGl0ZW0uX2luZGV4LCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5fcGFyZW50IHx8IHRoaXMgaW5zdGFuY2VvZiBMYXllciAmJiB0aGlzLl9wcm9qZWN0KVxuXHRcdFx0XHQuaW5zZXJ0Q2hpbGQoMCwgdGhpcyk7XG5cdH0sXG5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BhcmVudCB8fCB0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcy5fcHJvamVjdClcblx0XHRcdFx0LmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdGFwcGVuZFRvcDogJyNhZGRDaGlsZCcsXG5cblx0YXBwZW5kQm90dG9tOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQoMCwgaXRlbSk7XG5cdH0sXG5cblx0bW92ZUFib3ZlOiAnI2luc2VydEFib3ZlJyxcblxuXHRtb3ZlQmVsb3c6ICcjaW5zZXJ0QmVsb3cnLFxuXG5cdHJlZHVjZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bMF0ucmVkdWNlKCk7XG5cdFx0XHRjaGlsZC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdGNoaWxkLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9yZW1vdmVOYW1lZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRuYW1lID0gdGhpcy5fbmFtZSxcblx0XHRcdFx0bmFtZWRBcnJheSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0sXG5cdFx0XHRcdGluZGV4ID0gbmFtZWRBcnJheSA/IG5hbWVkQXJyYXkuaW5kZXhPZih0aGlzKSA6IC0xO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5bbmFtZV0gPT0gdGhpcylcblx0XHRcdFx0XHRkZWxldGUgY2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdG5hbWVkQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0aWYgKG5hbWVkQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSBuYW1lZEFycmF5W25hbWVkQXJyYXkubGVuZ3RoIC0gMV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVkQ2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24obm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKVxuXHRcdFx0XHRCYXNlLnNwbGljZShwYXJlbnQuX2NoaWxkcmVuLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmKSB7XG5cdFx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRcdFx0aWYgKHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5vdGlmeVBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jaGFuZ2VkKDExKTtcblx0XHRcdHRoaXMuX3BhcmVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlbW92ZSh0cnVlLCB0cnVlKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBvayA9IGl0ZW0gJiYgaXRlbS5pbnNlcnRCZWxvdyh0aGlzKTtcblx0XHRpZiAob2spXG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdHJldHVybiBvaztcblx0fSxcblxuXHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0ZnJvbSA9IGZyb20gfHwgMDtcblx0XHR0byA9IEJhc2UucGljayh0bywgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKTtcblx0XHR2YXIgcmVtb3ZlZCA9IEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBudWxsLCBmcm9tLCB0byAtIGZyb20pO1xuXHRcdGZvciAodmFyIGkgPSByZW1vdmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRyZW1vdmVkW2ldLl9yZW1vdmUodHJ1ZSwgZmFsc2UpO1xuXHRcdH1cblx0XHRpZiAocmVtb3ZlZC5sZW5ndGggPiAwKVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xlYXI6ICcjcmVtb3ZlQ2hpbGRyZW4nLFxuXG5cdHJldmVyc2VDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHR0aGlzLl9jaGlsZHJlbi5yZXZlcnNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uX2luZGV4ID0gaTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH1cblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXM7XG5cdFx0d2hpbGUgKGl0ZW0pIHtcblx0XHRcdGlmICghaXRlbS5fdmlzaWJsZSB8fCBpdGVtLl9sb2NrZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGl0ZW0gPSBpdGVtLl9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzRmlsbCgpO1xuXHR9LFxuXG5cdGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTdHJva2UoKTtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU2hhZG93KCk7XG5cdH0sXG5cblx0X2dldE9yZGVyOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0ZnVuY3Rpb24gZ2V0TGlzdChpdGVtKSB7XG5cdFx0XHR2YXIgbGlzdCA9IFtdO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXN0LnVuc2hpZnQoaXRlbSk7XG5cdFx0XHR9IHdoaWxlIChpdGVtID0gaXRlbS5fcGFyZW50KTtcblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblx0XHR2YXIgbGlzdDEgPSBnZXRMaXN0KHRoaXMpLFxuXHRcdFx0bGlzdDIgPSBnZXRMaXN0KGl0ZW0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4obGlzdDEubGVuZ3RoLCBsaXN0Mi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAobGlzdDFbaV0gIT0gbGlzdDJbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGxpc3QxW2ldLl9pbmRleCA8IGxpc3QyW2ldLl9pbmRleCA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0aGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaXNJbnNlcnRlZCgpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNBYm92ZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRPcmRlcihpdGVtKSA9PT0gLTE7XG5cdH0sXG5cblx0aXNCZWxvdzogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRPcmRlcihpdGVtKSA9PT0gMTtcblx0fSxcblxuXHRpc1BhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW07XG5cdH0sXG5cblx0aXNDaGlsZDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtICYmIGl0ZW0uX3BhcmVudCA9PT0gdGhpcztcblx0fSxcblxuXHRpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgPT0gaXRlbSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0FuY2VzdG9yOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPyBpdGVtLmlzRGVzY2VuZGFudCh0aGlzKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzU2libGluZzogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW0uX3BhcmVudDtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbXggPSBuZXcgTWF0cml4KCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnJvdGF0ZShhbmdsZSxcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMsIDEsIHsgcmVhZE51bGw6IHRydWUgfSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtuYW1lXShwb2ludCxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fTtcbn0sIHtcblxufSksIHtcblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgsIF9hcHBseU1hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksXG5cdFx0XHRfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoX2FwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4KVxuXHRcdFx0XHRcdCYmICgoIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IG1hdHJpeClcblx0XHRcdFx0XHRcdHx8IF9hcHBseU1hdHJpeCAmJiBfYXBwbHlSZWN1cnNpdmVseSAmJiB0aGlzLl9jaGlsZHJlbik7XG5cdFx0aWYgKCFtYXRyaXggJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdF9tYXRyaXgucHJlQ29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHRpZiAoYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeCAmJiB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgsXG5cdFx0XHRcdFx0X2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkpIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90LFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG5cdFx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IodHJ1ZSk7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cdFx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0XHRmaWxsQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdFx0aWYgKF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeClcblx0XHRcdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdHZhciBkZWNvbXAgPSBib3VuZHMgJiYgbWF0cml4ICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRpZiAoZGVjb21wICYmICFkZWNvbXAuc2hlYXJpbmcgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGFwcGx5TWF0cml4IHx8ICFyZWN0Ll9pbnRlcm5hbClcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdHJlY3QgPSBib3VuZHNbZ2V0dGVyICYmIGdldHRlci5nZXRCb3VuZHMgfHwgZ2V0dGVyIHx8ICdnZXRCb3VuZHMnXTtcblx0XHRcdGlmIChyZWN0KVxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4ICYmIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCwgYXBwbHlSZWN1cnNpdmVseSwgc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS50cmFuc2Zvcm0obWF0cml4LCB0cnVlLCBhcHBseVJlY3Vyc2l2ZWx5LFxuXHRcdFx0XHRcdFx0c2V0QXBwbHlNYXRyaXgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHBhcmVudFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGZpdEJvdW5kczogZnVuY3Rpb24ocmVjdGFuZ2xlLCBmaWxsKSB7XG5cdFx0cmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdGl0ZW1SYXRpbyA9IGJvdW5kcy5oZWlnaHQgLyBib3VuZHMud2lkdGgsXG5cdFx0XHRyZWN0UmF0aW8gPSByZWN0YW5nbGUuaGVpZ2h0IC8gcmVjdGFuZ2xlLndpZHRoLFxuXHRcdFx0c2NhbGUgPSAoZmlsbCA/IGl0ZW1SYXRpbyA+IHJlY3RSYXRpbyA6IGl0ZW1SYXRpbyA8IHJlY3RSYXRpbylcblx0XHRcdFx0XHQ/IHJlY3RhbmdsZS53aWR0aCAvIGJvdW5kcy53aWR0aFxuXHRcdFx0XHRcdDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG5cdFx0XHRuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLFxuXHRcdFx0XHRcdG5ldyBTaXplKGJvdW5kcy53aWR0aCAqIHNjYWxlLCBib3VuZHMuaGVpZ2h0ICogc2NhbGUpKTtcblx0XHRuZXdCb3VuZHMuc2V0Q2VudGVyKHJlY3RhbmdsZS5nZXRDZW50ZXIoKSk7XG5cdFx0dGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcblx0fSxcblxuXHRfc2V0U3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcigpLFxuXHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcigpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBzdHlsZS5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRpZiAoc3Ryb2tlQ29sb3IpIHtcblx0XHRcdHZhciBzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKSB7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR2YXIgc3Ryb2tlSm9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdFx0XHRzdHJva2VDYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRpZiAoc3Ryb2tlSm9pbilcblx0XHRcdFx0XHRjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuXHRcdFx0XHRpZiAoc3Ryb2tlQ2FwKVxuXHRcdFx0XHRcdGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuXHRcdFx0XHRpZiAobWl0ZXJMaW1pdClcblx0XHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0XHRcdGlmIChwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2gpIHtcblx0XHRcdFx0XHR2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdFx0XHRkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXHRcdFx0XHRcdGlmIChkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCdzZXRMaW5lRGFzaCcgaW4gY3R4KSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNoYWRvd0NvbG9yKSB7XG5cdFx0XHR2YXIgc2hhZG93Qmx1ciA9IHN0eWxlLmdldFNoYWRvd0JsdXIoKTtcblx0XHRcdGlmIChzaGFkb3dCbHVyID4gMCkge1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93Qmx1cjtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0Lng7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHBhcmVudFN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIG1hdHJpY2VzID0gcGFyYW0ubWF0cmljZXMsXG5cdFx0XHR2aWV3TWF0cml4ID0gcGFyYW0udmlld01hdHJpeCxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdGdsb2JhbE1hdHJpeCA9IG1hdHJpY2VzW21hdHJpY2VzLmxlbmd0aCAtIDFdLmNoYWluKG1hdHJpeCk7XG5cdFx0aWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRmdW5jdGlvbiBnZXRWaWV3TWF0cml4KG1hdHJpeCkge1xuXHRcdFx0cmV0dXJuIHZpZXdNYXRyaXggPyB2aWV3TWF0cml4LmNoYWluKG1hdHJpeCkgOiBtYXRyaXg7XG5cdFx0fVxuXG5cdFx0bWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXHRcdGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcblx0XHRcdGdsb2JhbE1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuXHRcdFx0bm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuXHRcdFx0bmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcblx0XHRcdGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcblx0XHRcdFx0XHR8fCBwYXJhbS5kb250U3RhcnRcblx0XHRcdFx0XHR8fCBwYXJhbS5jbGlwXG5cdFx0XHRcdFx0fHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKVxuXHRcdFx0XHRcdFx0JiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG5cdFx0XHRwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0bWFpbkN0eCwgaXRlbU9mZnNldCwgcHJldk9mZnNldDtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSk7XG5cdFx0XHRpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0cHJldk9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGl0ZW1PZmZzZXQgPSBwYXJhbS5vZmZzZXQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCk7XG5cdFx0XHRtYWluQ3R4ID0gY3R4O1xuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChib3VuZHMuZ2V0U2l6ZSgpLmNlaWwoKS5hZGQoMSlcblx0XHRcdFx0XHQubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpXG5cdFx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgc3Ryb2tlTWF0cml4ID0gcGFyZW50U3Ryb2tlTWF0cml4XG5cdFx0XHRcdD8gcGFyZW50U3Ryb2tlTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0OiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpICYmIGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSxcblx0XHRcdGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuXHRcdFx0dHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cdFx0XHRpZiAobmF0aXZlQmxlbmQpXG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoLWl0ZW1PZmZzZXQueCwgLWl0ZW1PZmZzZXQueSk7XG5cdFx0fVxuXHRcdGlmICh0cmFuc2Zvcm0pXG5cdFx0XHQoZGlyZWN0ID8gbWF0cml4IDogZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKS5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChjbGlwKVxuXHRcdFx0cGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdGlmIChzdHJva2VNYXRyaXgpIHtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aWYgKG9mZnNldClcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKVxuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0QmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksXG5cdFx0XHRcdFx0aXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHRwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuXHRcdH1cblx0fSxcblxuXHRfaXNVcGRhdGVkOiBmdW5jdGlvbih1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuXHRcdHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZVxuXHRcdFx0XHQmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cdH0sXG5cblx0X2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3RlZEl0ZW1zLCB1cGRhdGVWZXJzaW9uKSB7XG5cdFx0aWYgKCh0aGlzLl9kcmF3U2VsZWN0ZWQgfHwgdGhpcy5fYm91bmRzU2VsZWN0ZWQpXG5cdFx0XHRcdCYmIHRoaXMuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRMYXllcigpLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSksXG5cdFx0XHRcdG14ID0gbWF0cml4LmNoYWluKHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0aWYgKHRoaXMuX2RyYXdTZWxlY3RlZClcblx0XHRcdFx0dGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGVkSXRlbXMpO1xuXHRcdFx0aWYgKHRoaXMuX2JvdW5kc1NlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBoYWxmID0gc2l6ZSAvIDIsXG5cdFx0XHRcdFx0Y29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRjdHhbaSA9PT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZixcblx0XHRcdFx0XHRcdFx0c2l6ZSwgc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHRoYXNoW25hbWVdID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pKTtcblxudmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcm91cCcsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgMTAyNikge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQuX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCksXG5cdFx0XHRkcmF3ID0gdHJ1ZTtcblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdFx0ZHJhdyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChkcmF3KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pXG5cdFx0XHRcdFx0aXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKGFyZykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdD8gbmV3IEJhc2UoYXJnKVxuXHRcdFx0XHQ6IHsgY2hpbGRyZW46IEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyB9LFxuXHRcdFx0aW5zZXJ0ID0gcHJvcHMuaW5zZXJ0O1xuXHRcdHByb3BzLmluc2VydCA9IGZhbHNlO1xuXHRcdEdyb3VwLmNhbGwodGhpcywgcHJvcHMpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3Byb2plY3QuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uIF9yZW1vdmUobm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdHJldHVybiBfcmVtb3ZlLmJhc2UuY2FsbCh0aGlzLCBub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpO1xuXHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdHByb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcy5nZXROZXh0U2libGluZygpXG5cdFx0XHRcdFx0XHR8fCB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuXHRcdFx0QmFzZS5zcGxpY2UocHJvamVjdC5sYXllcnMsIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0aWYgKG5vdGlmeVNlbGYgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdGlmIChub3RpZnlQYXJlbnQpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldE5leHRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIGdldFByZXZpb3VzU2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0UHJldmlvdXNTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaW5zZXJ0U2libGluZzogZnVuY3Rpb24gX2luc2VydFNpYmxpbmcoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiAhdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcHJvamVjdC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSwgX3ByZXNlcnZlKVxuXHRcdFx0XHQ6IF9pbnNlcnRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2hhcGUnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHR0eXBlOiBudWxsLFxuXHRcdHNpemU6IG51bGwsXG5cdFx0cmFkaXVzOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGVcblx0XHRcdCYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpXG5cdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFNoYXBlKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFR5cGUodGhpcy5fdHlwZSk7XG5cdFx0Y29weS5zZXRTaXplKHRoaXMuX3NpemUpO1xuXHRcdGNvcHkuc2V0UmFkaXVzKHRoaXMuX3JhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikpO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJ1xuXHRcdFx0XHQ/IHJhZFxuXHRcdFx0XHQ6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuXHR9LFxuXG5cdHNldFJhZGl1czogZnVuY3Rpb24ocmFkaXVzKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0aWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLl9zaXplLnNldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9jbG9uZShuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSksIGluc2VydCk7XG5cdFx0aWYgKHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4KVxuXHRcdFx0cGF0aC5zZXRBcHBseU1hdHJpeCh0cnVlKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHR1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0aXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuXHRcdFx0XHRjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdGFuZ2xlJyAmJiByeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuXHRcdFx0XHRcdGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgeCA9IHdpZHRoIC8gMixcblx0XHRcdFx0XHRcdHkgPSBoZWlnaHQgLyAyLFxuXHRcdFx0XHRcdFx0a2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdFx0XHRcdFx0Y3ggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdFx0Y3kgPSByeSAqIGthcHBhLFxuXHRcdFx0XHRcdFx0YyA9IFtcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIHksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSByeVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRpZiAoc3Ryb2tlTWF0cml4KVxuXHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjWzBdLCBjWzFdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdLCBjWzddKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMTBdLCBjWzExXSwgY1sxMl0sIGNbMTNdLCBjWzE0XSwgY1sxNV0pO1xuXHRcdFx0XHRcdGlmICh5ICE9PSByeSlcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1sxNl0sIGNbMTddKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMjRdLCBjWzI1XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syNl0sIGNbMjddLCBjWzI4XSwgY1syOV0sIGNbMzBdLCBjWzMxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHR9XG5cdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0aWYgKGdldHRlciAhPT0gJ2dldEJvdW5kcycgJiYgdGhpcy5oYXNTdHJva2UoKSlcblx0XHRcdHJlY3QgPSByZWN0LmV4cGFuZCh0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldENvcm5lckNlbnRlcih0aGF0LCBwb2ludCwgZXhwYW5kKSB7XG5cdFx0dmFyIHJhZGl1cyA9IHRoYXQuX3JhZGl1cztcblx0XHRpZiAoIXJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGhhbGZTaXplID0gdGhhdC5fc2l6ZS5kaXZpZGUoMik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHR2YXIgZGlyID0gbmV3IFBvaW50KGkgJiAxID8gMSA6IC0xLCBpID4gMSA/IDEgOiAtMSksXG5cdFx0XHRcdFx0Y29ybmVyID0gZGlyLm11bHRpcGx5KGhhbGZTaXplKSxcblx0XHRcdFx0XHRjZW50ZXIgPSBjb3JuZXIuc3VidHJhY3QoZGlyLm11bHRpcGx5KHJhZGl1cykpLFxuXHRcdFx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvcm5lciwgY2VudGVyKTtcblx0XHRcdFx0aWYgKChleHBhbmQgPyByZWN0LmV4cGFuZChleHBhbmQpIDogcmVjdCkuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiBjZW50ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKSB7XG5cdFx0dmFyIGFuZ2xlID0gcG9pbnQuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdHdpZHRoID0gcmFkaXVzLndpZHRoICogMixcblx0XHRcdGhlaWdodCA9IHJhZGl1cy5oZWlnaHQgKiAyLFxuXHRcdFx0eCA9IHdpZHRoICogTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0eSA9IGhlaWdodCAqIE1hdGguY29zKGFuZ2xlKTtcblx0XHRyZXR1cm4gd2lkdGggKiBoZWlnaHQgLyAoMiAqIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9jb250YWluczogZnVuY3Rpb24gX2NvbnRhaW5zKHBvaW50KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCk7XG5cdFx0XHRcdHJldHVybiBjZW50ZXJcblx0XHRcdFx0XHRcdD8gcG9pbnQuc3VidHJhY3QoY2VudGVyKS5kaXZpZGUodGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRcdFx0XHQuZ2V0TGVuZ3RoKCkgPD0gMVxuXHRcdFx0XHRcdFx0OiBfY29udGFpbnMuYmFzZS5jYWxsKHRoaXMsIHBvaW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBwb2ludC5kaXZpZGUodGhpcy5zaXplKS5nZXRMZW5ndGgoKSA8PSAwLjU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgaGl0ID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCgpICsgMiAqIG9wdGlvbnMudG9sZXJhbmNlO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBzdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0aWYgKGNlbnRlcikge1xuXHRcdFx0XHRcdFx0dmFyIHB0ID0gcG9pbnQuc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwdC5nZXRMZW5ndGgoKVxuXHRcdFx0XHRcdFx0XHRcdC0gZ2V0RWxsaXBzZVJhZGl1cyhwdCwgcmFkaXVzKSkgPD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG5cdFx0XHRcdFx0XHRcdG91dGVyID0gcmVjdC5leHBhbmQoc3Ryb2tlV2lkdGgpLFxuXHRcdFx0XHRcdFx0XHRpbm5lciA9IHJlY3QuZXhwYW5kKC1zdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0XHRoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludClcblx0XHRcdFx0XHRcdFx0XHQmJiAhaW5uZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKVxuXHRcdFx0XHRcdFx0cmFkaXVzID0gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKTtcblx0XHRcdFx0XHRoaXQgPSAyICogTWF0aC5hYnMocG9pbnQuZ2V0TGVuZ3RoKCkgLSByYWRpdXMpXG5cdFx0XHRcdFx0XHRcdDw9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGl0XG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdzdHJva2UnLCB0aGlzKVxuXHRcdFx0XHRcdDogX2hpdFRlc3RTZWxmLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59LCB7XG5cbnN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gY3JlYXRlU2hhcGUodHlwZSwgcG9pbnQsIHNpemUsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBpdGVtID0gbmV3IFNoYXBlKEJhc2UuZ2V0TmFtZWQoYXJncykpO1xuXHRcdGl0ZW0uX3R5cGUgPSB0eXBlO1xuXHRcdGl0ZW0uX3NpemUgPSBzaXplO1xuXHRcdGl0ZW0uX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gaXRlbS50cmFuc2xhdGUocG9pbnQpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2NpcmNsZScsIGNlbnRlciwgbmV3IFNpemUocmFkaXVzICogMiksIHJhZGl1cyxcblx0XHRcdFx0XHRhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdyZWN0YW5nbGUnLCByZWN0LmdldENlbnRlcih0cnVlKSxcblx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSksIHJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpLFxuXHRcdFx0XHRyYWRpdXMgPSBlbGxpcHNlLnJhZGl1cztcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnZWxsaXBzZScsIGVsbGlwc2UuY2VudGVyLCByYWRpdXMubXVsdGlwbHkoMiksXG5cdFx0XHRcdFx0cmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBjZW50ZXIsXG5cdFx0XHRcdHJhZGl1cztcblx0XHRcdGlmIChCYXNlLmhhc05hbWVkKGFyZ3MsICdyYWRpdXMnKSkge1xuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpO1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpO1xuXHRcdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdFx0cmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7IGNlbnRlcjogY2VudGVyLCByYWRpdXM6IHJhZGl1cyB9O1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmFzdGVyJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogJ2dldEJvdW5kcycsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNyb3NzT3JpZ2luOiBudWxsLFxuXHRcdHNvdXJjZTogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJhc3RlcihvYmplY3QsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKG9iamVjdCxcblx0XHRcdFx0cG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKSB7XG5cdFx0XHRpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRTb3VyY2Uob2JqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0SW1hZ2Uob2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCkgPT09IGl0ZW0uZ2V0U291cmNlKCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRpbWFnZSA9IHRoaXMuX2ltYWdlLFxuXHRcdFx0Y2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdGlmIChpbWFnZSkge1xuXHRcdFx0Y29weS5zZXRJbWFnZShpbWFnZSk7XG5cdFx0fSBlbHNlIGlmIChjYW52YXMpIHtcblx0XHRcdHZhciBjb3B5Q2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHRoaXMuX3NpemUpO1xuXHRcdFx0Y29weUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuXHRcdFx0Y29weS5zZXRJbWFnZShjb3B5Q2FudmFzKTtcblx0XHR9XG5cdFx0Y29weS5fY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUgPyBzaXplLndpZHRoIDogMCwgc2l6ZSA/IHNpemUuaGVpZ2h0IDogMCxcblx0XHRcdFx0dGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghc2l6ZS5lcXVhbHModGhpcy5fc2l6ZSkpIHtcblx0XHRcdGlmIChzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDApIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSkpO1xuXHRcdFx0XHRpZiAoZWxlbWVudClcblx0XHRcdFx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGVsZW1lbnQsIDAsIDAsXG5cdFx0XHRcdFx0XHRcdHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jYW52YXMpXG5cdFx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUgPyB0aGlzLl9zaXplLndpZHRoIDogMDtcblx0fSxcblxuXHRzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcblx0XHR0aGlzLnNldFNpemUod2lkdGgsIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUgPyB0aGlzLl9zaXplLmhlaWdodCA6IDA7XG5cdH0sXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLnNldFNpemUodGhpcy5nZXRXaWR0aCgpLCBoZWlnaHQpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gIXNpemUgfHwgc2l6ZS53aWR0aCA9PT0gMCAmJiBzaXplLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0b3JpZyA9IG5ldyBQb2ludCgwLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHUgPSBuZXcgUG9pbnQoMSwgMCkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyksXG5cdFx0XHR2ID0gbmV3IFBvaW50KDAsIDEpLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpO1xuXHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdDcyIC8gdS5nZXRMZW5ndGgoKSxcblx0XHRcdDcyIC8gdi5nZXRMZW5ndGgoKVxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0UHBpOiAnI2dldFJlc29sdXRpb24nLFxuXG5cdGdldEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XG5cdH0sXG5cblx0c2V0SW1hZ2U6IGZ1bmN0aW9uKGltYWdlKSB7XG5cdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblx0XHRpZiAoaW1hZ2UgJiYgaW1hZ2UuZ2V0Q29udGV4dCkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gbnVsbDtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IGltYWdlICYmIGltYWdlLmNvbXBsZXRlO1xuXHRcdH1cblx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLndpZHRoIDogMCxcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IGltYWdlLmhlaWdodCA6IDApO1xuXHRcdHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXHRcdHRoaXMuX2NoYW5nZWQoNTIxKTtcblx0fSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbWFnZSlcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcblx0XHRcdFx0dGhpcy5fY2FudmFzID0gY3R4LmNhbnZhcztcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzO1xuXHR9LFxuXG5cdHNldENhbnZhczogJyNzZXRJbWFnZScsXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24obW9kaWZ5KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZXh0KVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAobW9kaWZ5KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDUxMyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHR9LFxuXG5cdHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblx0fSxcblxuXHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmMgfHwgdGhpcy50b0RhdGFVUkwoKTtcblx0fSxcblxuXHRzZXRTb3VyY2U6IGZ1bmN0aW9uKHNyYykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGNyb3NzT3JpZ2luID0gdGhpcy5fY3Jvc3NPcmlnaW4sXG5cdFx0XHRpbWFnZTtcblxuXHRcdGZ1bmN0aW9uIGxvYWRlZCgpIHtcblx0XHRcdHZhciB2aWV3ID0gdGhhdC5nZXRWaWV3KCk7XG5cdFx0XHRpZiAodmlldykge1xuXHRcdFx0XHRwYXBlciA9IHZpZXcuX3Njb3BlO1xuXHRcdFx0XHR0aGF0LnNldEltYWdlKGltYWdlKTtcblx0XHRcdFx0dGhhdC5lbWl0KCdsb2FkJyk7XG5cdFx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW1hZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzcmMpIHx8IG5ldyBJbWFnZSgpO1xuXHRcdGlmIChjcm9zc09yaWdpbilcblx0XHRcdGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0aWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiBpbWFnZS5uYXR1cmFsSGVpZ2h0KSB7XG5cdFx0XHRzZXRUaW1lb3V0KGxvYWRlZCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbUV2ZW50LmFkZChpbWFnZSwgeyBsb2FkOiBsb2FkZWQgfSk7XG5cdFx0XHRpZiAoIWltYWdlLnNyYylcblx0XHRcdFx0aW1hZ2Uuc3JjID0gc3JjO1xuXHRcdH1cblx0XHR0aGlzLnNldEltYWdlKGltYWdlKTtcblx0fSxcblxuXHRnZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLmNyb3NzT3JpZ2luIHx8IHRoaXMuX2Nyb3NzT3JpZ2luIHx8ICcnO1xuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbihjcm9zc09yaWdpbikge1xuXHRcdHRoaXMuX2Nyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0dGhpcy5faW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzIHx8IHRoaXMuX2xvYWRlZCAmJiB0aGlzLl9pbWFnZTtcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0U3ViQ2FudmFzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHJlY3QuZ2V0U2l6ZSgpKTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0Q2FudmFzKCksIHJlY3QueCwgcmVjdC55LFxuXHRcdFx0XHRyZWN0LndpZHRoLCByZWN0LmhlaWdodCwgMCwgMCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBjdHguY2FudmFzO1xuXHR9LFxuXG5cdGdldFN1YlJhc3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0cmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldEltYWdlKHRoaXMuZ2V0U3ViQ2FudmFzKHJlY3QpKTtcblx0XHRyYXN0ZXIudHJhbnNsYXRlKHJlY3QuZ2V0Q2VudGVyKCkuc3VidHJhY3QodGhpcy5nZXRTaXplKCkuZGl2aWRlKDIpKSk7XG5cdFx0cmFzdGVyLl9tYXRyaXgucHJlQ29uY2F0ZW5hdGUodGhpcy5fbWF0cml4KTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHR0b0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzcmMgPSB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmM7XG5cdFx0aWYgKC9eZGF0YTovLnRlc3Qoc3JjKSlcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy50b0RhdGFVUkwuYXBwbHkoY2FudmFzLCBhcmd1bWVudHMpIDogbnVsbDtcblx0fSxcblxuXHRkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGltYWdlLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHZhciBib3VuZHMsIHBhdGg7XG5cdFx0aWYgKCFvYmplY3QpIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuXHRcdFx0cGF0aCA9IG9iamVjdDtcblx0XHRcdGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC53aWR0aCkge1xuXHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0LngpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0LnggLSAwLjUsIG9iamVjdC55IC0gMC41LCAxLCAxKTtcblx0XHR9XG5cdFx0dmFyIHNhbXBsZVNpemUgPSAzMixcblx0XHRcdHdpZHRoID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBzYW1wbGVTaXplKSxcblx0XHRcdGhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5oZWlnaHQsIHNhbXBsZVNpemUpO1xuXHRcdHZhciBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQ7XG5cdFx0aWYgKCFjdHgpIHtcblx0XHRcdGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG5cdFx0XHRcdFx0bmV3IFNpemUoc2FtcGxlU2l6ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNhbXBsZVNpemUgKyAxLCBzYW1wbGVTaXplICsgMSk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKVxuXHRcdFx0XHQuc2NhbGUod2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdC50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChwYXRoKVxuXHRcdFx0cGF0aC5kcmF3KGN0eCwgbmV3IEJhc2UoeyBjbGlwOiB0cnVlLCBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdHRoaXMuX21hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCksXG5cdFx0XHRzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRpZiAoZWxlbWVudClcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgLXNpemUud2lkdGggLyAyLCAtc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLFxuXHRcdFx0XHRNYXRoLmNlaWwoaGVpZ2h0KSkuZGF0YSxcblx0XHRcdGNoYW5uZWxzID0gWzAsIDAsIDBdLFxuXHRcdFx0dG90YWwgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0dmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcblx0XHRcdHRvdGFsICs9IGFscGhhO1xuXHRcdFx0YWxwaGEgLz0gMjU1O1xuXHRcdFx0Y2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKVxuXHRcdFx0Y2hhbm5lbHNbaV0gLz0gdG90YWw7XG5cdFx0cmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKCdyZ2InLCBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV0sXG5cdFx0XHRcdGRhdGFbM10gLyAyNTUpO1xuXHR9LFxuXG5cdHNldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5fY29udmVydCgncmdiJyksXG5cdFx0XHRhbHBoYSA9IGNvbG9yLl9hbHBoYSxcblx0XHRcdGN0eCA9IHRoaXMuZ2V0Q29udGV4dCh0cnVlKSxcblx0XHRcdGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSksXG5cdFx0XHRkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0ZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG5cdFx0ZGF0YVsxXSA9IGNvbXBvbmVudHNbMV0gKiAyNTU7XG5cdFx0ZGF0YVsyXSA9IGNvbXBvbmVudHNbMl0gKiAyNTU7XG5cdFx0ZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcblx0XHRjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Y3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5jcmVhdGVJbWFnZURhdGEoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGdldEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmIChyZWN0LmlzRW1wdHkoKSlcblx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fSxcblxuXHRzZXRJbWFnZURhdGE6IGZ1bmN0aW9uKGRhdGEgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5wdXRJbWFnZURhdGEoZGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fb3BhY2l0eTtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcblx0XHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBQbGFjZWRTeW1ib2wgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BsYWNlZFN5bWJvbCcsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNHZXR0ZXI6IHsgZ2V0Qm91bmRzOiAnZ2V0U3Ryb2tlQm91bmRzJyB9LFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzeW1ib2w6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQbGFjZWRTeW1ib2woYXJnMCwgYXJnMSkge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuXHRcdFx0XHRhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSlcblx0XHRcdHRoaXMuc2V0U3ltYm9sKGFyZzAgaW5zdGFuY2VvZiBTeW1ib2wgPyBhcmcwIDogbmV3IFN5bWJvbChhcmcwKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wgPT09IGl0ZW0uX3N5bWJvbDtcblx0fSxcblxuXHRnZXRTeW1ib2w6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2w7XG5cdH0sXG5cblx0c2V0U3ltYm9sOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHR0aGlzLl9zeW1ib2wgPSBzeW1ib2w7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUGxhY2VkU3ltYm9sKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFN5bWJvbCh0aGlzLl9zeW1ib2wpO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uaXNFbXB0eSgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgZGVmaW5pdGlvbiA9IHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uO1xuXHRcdHJldHVybiBkZWZpbml0aW9uLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuXHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmNoYWluKGRlZmluaXRpb24uX21hdHJpeCksIGNhY2hlSXRlbSk7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdHZhciByZXMgPSB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdGlmIChyZXMpXG5cdFx0XHRyZXMuaXRlbSA9IHRoaXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uLmRyYXcoY3R4LCBwYXJhbSk7XG5cdH1cblxufSk7XG5cbnZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtID0gaXRlbTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHR2YWx1ZXMuZW51bWVyYWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLmluamVjdCh2YWx1ZXMpO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBCYXNlKHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0dG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdGZpbGw6ICFvcHRpb25zLFxuXHRcdFx0XHRzdHJva2U6ICFvcHRpb25zLFxuXHRcdFx0XHRzZWdtZW50czogIW9wdGlvbnMsXG5cdFx0XHRcdGhhbmRsZXM6IGZhbHNlLFxuXHRcdFx0XHRlbmRzOiBmYWxzZSxcblx0XHRcdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRcdFx0Ym91bmRzOiBmYWxzZSxcblx0XHRcdFx0Z3VpZGVzOiBmYWxzZSxcblx0XHRcdFx0c2VsZWN0ZWQ6IGZhbHNlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2VnbWVudCcsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRwb2ludCwgaGFuZGxlSW4sIGhhbmRsZU91dDtcblx0XHRpZiAoY291bnQgPT09IDApIHtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoJ3BvaW50JyBpbiBhcmcwKSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMC5wb2ludDtcblx0XHRcdFx0aGFuZGxlSW4gPSBhcmcwLmhhbmRsZUluO1xuXHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAyICYmIHR5cGVvZiBhcmcwID09PSAnbnVtYmVyJykge1xuXHRcdFx0cG9pbnQgPSBhcmd1bWVudHM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA8PSAzKSB7XG5cdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzE7XG5cdFx0XHRoYW5kbGVPdXQgPSBhcmcyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb2ludCA9IGFyZzAgIT09IHVuZGVmaW5lZCA/IFsgYXJnMCwgYXJnMSBdIDogbnVsbDtcblx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnNCAhPT0gdW5kZWZpbmVkID8gWyBhcmc0LCBhcmc1IF0gOiBudWxsO1xuXHRcdH1cblx0XHRuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVJbiwgdGhpcywgJ19oYW5kbGVJbicpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlT3V0LCB0aGlzLCAnX2hhbmRsZU91dCcpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5oYXNIYW5kbGVzKClcblx0XHRcdFx0PyBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdXG5cdFx0XHRcdDogdGhpcy5fcG9pbnQsXG5cdFx0XHRcdG9wdGlvbnMsIHRydWUpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRpZiAoIXBhdGgpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIGN1cnZlcyA9IHBhdGguX2N1cnZlcyxcblx0XHRcdGluZGV4ID0gdGhpcy5faW5kZXgsXG5cdFx0XHRjdXJ2ZTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluKVxuXHRcdFx0XHRcdCYmIChjdXJ2ZSA9IGluZGV4ID4gMCA/IGN1cnZlc1tpbmRleCAtIDFdIDogcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0XHQ/IGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0gOiBudWxsKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHRcdGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0KVxuXHRcdFx0XHRcdCYmIChjdXJ2ZSA9IGN1cnZlc1tpbmRleF0pKVxuXHRcdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRwYXRoLl9jaGFuZ2VkKDI1KTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVJbi5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlT3V0O1xuXHR9LFxuXG5cdHNldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuXHR9LFxuXG5cdGNsZWFySGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KDAsIDApO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG5cdH0sXG5cblx0X3NlbGVjdGlvblN0YXRlOiAwLFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKF9wb2ludCkge1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuX3NlbGVjdGlvblN0YXRlO1xuXHRcdHJldHVybiAhX3BvaW50ID8gISEoc3RhdGUgJiA3KVxuXHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gISEoc3RhdGUgJiA0KVxuXHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluID8gISEoc3RhdGUgJiAxKVxuXHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dCA/ICEhKHN0YXRlICYgMilcblx0XHRcdDogZmFsc2U7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBfcG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRzZWxlY3RlZCA9ICEhc2VsZWN0ZWQsXG5cdFx0XHRzdGF0ZSA9IHRoaXMuX3NlbGVjdGlvblN0YXRlLFxuXHRcdFx0b2xkU3RhdGUgPSBzdGF0ZSxcblx0XHRcdGZsYWcgPSAhX3BvaW50ID8gN1xuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9wb2ludCA/IDRcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAxXG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dCA/IDJcblx0XHRcdFx0XHQ6IDA7XG5cdFx0aWYgKHNlbGVjdGVkKSB7XG5cdFx0XHRzdGF0ZSB8PSBmbGFnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGF0ZSAmPSB+ZmxhZztcblx0XHR9XG5cdFx0dGhpcy5fc2VsZWN0aW9uU3RhdGUgPSBzdGF0ZTtcblx0XHRpZiAocGF0aCAmJiBzdGF0ZSAhPT0gb2xkU3RhdGUpIHtcblx0XHRcdHBhdGguX3VwZGF0ZVNlbGVjdGlvbih0aGlzLCBvbGRTdGF0ZSwgc3RhdGUpO1xuXHRcdFx0cGF0aC5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9pbmRleCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGggfHwgbnVsbDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleDtcblx0XHRpZiAocGF0aCkge1xuXHRcdFx0aWYgKGluZGV4ID4gMCAmJiAhcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0JiYgaW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEpXG5cdFx0XHRcdGluZGV4LS07XG5cdFx0XHRyZXR1cm4gcGF0aC5nZXRDdXJ2ZXMoKVtpbmRleF0gfHwgbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmVcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGhpcyA9PT0gY3VydmUuX3NlZ21lbnQxID8gMCA6IDEpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuXHRcdHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRpc0ZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggPT09IDA7XG5cdH0sXG5cblx0aXNMYXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0cmV0dXJuIHBhdGggJiYgdGhpcy5faW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEgfHwgZmFsc2U7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQsXG5cdFx0XHRpblggPSBoYW5kbGVJbi5feCxcblx0XHRcdGluWSA9IGhhbmRsZUluLl95O1xuXHRcdGhhbmRsZUluLnNldChoYW5kbGVPdXQuX3gsIGhhbmRsZU91dC5feSk7XG5cdFx0aGFuZGxlT3V0LnNldChpblgsIGluWSk7XG5cdH0sXG5cblx0cmV2ZXJzZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24obWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4gPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuXHRcdFx0aGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVPdXQgOiBudWxsLFxuXHRcdFx0eCA9IHBvaW50Ll94LFxuXHRcdFx0eSA9IHBvaW50Ll95LFxuXHRcdFx0aSA9IDI7XG5cdFx0Y29vcmRzWzBdID0geDtcblx0XHRjb29yZHNbMV0gPSB5O1xuXHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl95ICsgeTtcblx0XHR9XG5cdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCBpIC8gMik7XG5cdFx0XHR4ID0gY29vcmRzWzBdO1xuXHRcdFx0eSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChjaGFuZ2UpIHtcblx0XHRcdFx0cG9pbnQuX3ggPSB4O1xuXHRcdFx0XHRwb2ludC5feSA9IHk7XG5cdFx0XHRcdGkgID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LCBzZWxlY3RlZDtcblx0XHRpZiAoIXBvaW50KSB7XG5cdFx0XHR4ID0geSA9IDA7XG5cdFx0fSBlbHNlIGlmICgoeCA9IHBvaW50WzBdKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR5ID0gcG9pbnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwdCA9IHBvaW50O1xuXHRcdFx0aWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0eCA9IHB0Lng7XG5cdFx0XHR9XG5cdFx0XHR5ID0gcHQueTtcblx0XHRcdHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0b3duZXJba2V5XSA9IHRoaXM7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcblx0XHRcdHggPSBmLm51bWJlcih0aGlzLl94KSxcblx0XHRcdHkgPSBmLm51bWJlcih0aGlzLl95KTtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0PyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cblx0XHRcdFx0OiBbeCwgeV07XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3gpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRzZWcxLCBzZWcyLFxuXHRcdFx0cG9pbnQxLCBwb2ludDIsXG5cdFx0XHRoYW5kbGUxLCBoYW5kbGUyO1xuXHRcdGlmIChjb3VudCA9PT0gMykge1xuXHRcdFx0dGhpcy5fcGF0aCA9IGFyZzA7XG5cdFx0XHRzZWcxID0gYXJnMTtcblx0XHRcdHNlZzIgPSBhcmcyO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudCgpO1xuXHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0aWYgKCdzZWdtZW50MScgaW4gYXJnMCkge1xuXHRcdFx0XHRzZWcxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG5cdFx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQyKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3BvaW50MScgaW4gYXJnMCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwLnBvaW50MTtcblx0XHRcdFx0aGFuZGxlMSA9IGFyZzAuaGFuZGxlMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzAuaGFuZGxlMjtcblx0XHRcdFx0cG9pbnQyID0gYXJnMC5wb2ludDI7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0cG9pbnQxID0gW2FyZzBbMF0sIGFyZzBbMV1dO1xuXHRcdFx0XHRwb2ludDIgPSBbYXJnMFs2XSwgYXJnMFs3XV07XG5cdFx0XHRcdGhhbmRsZTEgPSBbYXJnMFsyXSAtIGFyZzBbMF0sIGFyZzBbM10gLSBhcmcwWzFdXTtcblx0XHRcdFx0aGFuZGxlMiA9IFthcmcwWzRdIC0gYXJnMFs2XSwgYXJnMFs1XSAtIGFyZzBbN11dO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcblx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudChhcmcxKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG5cdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0aGFuZGxlMSA9IGFyZzE7XG5cdFx0XHRoYW5kbGUyID0gYXJnMjtcblx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gOCkge1xuXHRcdFx0cG9pbnQxID0gW2FyZzAsIGFyZzFdO1xuXHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0aGFuZGxlMSA9IFthcmcyIC0gYXJnMCwgYXJnMyAtIGFyZzFdO1xuXHRcdFx0aGFuZGxlMiA9IFthcmc0IC0gYXJnNiwgYXJnNSAtIGFyZzddO1xuXHRcdH1cblx0XHR0aGlzLl9zZWdtZW50MSA9IHNlZzEgfHwgbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZzIgfHwgbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaGFzSGFuZGxlcygpXG5cdFx0XHRcdD8gW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0SGFuZGxlMSgpLCB0aGlzLmdldEhhbmRsZTIoKSxcblx0XHRcdFx0XHR0aGlzLmdldFBvaW50MigpXVxuXHRcdFx0XHQ6IFt0aGlzLmdldFBvaW50MSgpLCB0aGlzLmdldFBvaW50MigpXSxcblx0XHRcdFx0b3B0aW9ucywgdHJ1ZSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUxOiAnICsgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dCk7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUyOiAnICsgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluKTtcblx0XHRwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLl9wYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudDIgPSB0aGlzLl9zZWdtZW50Mixcblx0XHRcdFx0aGFuZGxlT3V0ID0gc2VnbWVudDIuX2hhbmRsZU91dDtcblx0XHRcdHJlbW92ZWQgPSBzZWdtZW50Mi5yZW1vdmUoKTtcblx0XHRcdGlmIChyZW1vdmVkKVxuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChoYW5kbGVPdXQueCwgaGFuZGxlT3V0LnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRnZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzRmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXggPT09IDA7XG5cdH0sXG5cblx0aXNMYXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0cmV0dXJuIHBhdGggJiYgdGhpcy5fc2VnbWVudDEuX2luZGV4ID09PSBwYXRoLl9jdXJ2ZXMubGVuZ3RoIC0gMVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludDEoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldFBvaW50MigpLmlzU2VsZWN0ZWQoKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFZhbHVlcyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsIG1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSkpO1xuXHRcdHJldHVybiBwb2ludHM7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpXG5cdFx0XHR0aGlzLl9sZW5ndGggPSBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0QXJlYSh0aGlzLmdldFZhbHVlcygpKTtcblx0fSxcblxuXHRnZXRMaW5lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IExpbmUodGhpcy5fc2VnbWVudDEuX3BvaW50LCB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG5cdH0sXG5cblx0Z2V0UGFydExlbmd0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBDdXJ2ZS5fZ2V0SW50ZXJzZWN0aW9ucyh0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0XHRjdXJ2ZSAmJiBjdXJ2ZSAhPT0gdGhpcyA/IGN1cnZlLmdldFZhbHVlcygpIDogbnVsbCxcblx0XHRcdFx0dGhpcywgY3VydmUsIFtdLCB7fSk7XG5cdH0sXG5cblx0X2dldFBhcmFtZXRlcjogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiBpc1BhcmFtZXRlclxuXHRcdFx0XHQ/IG9mZnNldFxuXHRcdFx0XHQ6IG9mZnNldCAmJiBvZmZzZXQuY3VydmUgPT09IHRoaXNcblx0XHRcdFx0XHQ/IG9mZnNldC5wYXJhbWV0ZXJcblx0XHRcdFx0XHQ6IG9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGlzUGFyYW1ldGVyID09PSB1bmRlZmluZWRcblx0XHRcdFx0XHRcdD8gMC41XG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0LCAwKTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIsIF9zZXRIYW5kbGVzKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSxcblx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAocGFyYW1ldGVyID49IHRNaW4gJiYgcGFyYW1ldGVyIDw9IHRNYXgpIHtcblx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCBwYXJhbWV0ZXIpLFxuXHRcdFx0XHRsZWZ0ID0gcGFydHNbMF0sXG5cdFx0XHRcdHJpZ2h0ID0gcGFydHNbMV0sXG5cdFx0XHRcdHNldEhhbmRsZXMgPSBfc2V0SGFuZGxlcyB8fCB0aGlzLmhhc0hhbmRsZXMoKSxcblx0XHRcdFx0c2VnbWVudDEgPSB0aGlzLl9zZWdtZW50MSxcblx0XHRcdFx0c2VnbWVudDIgPSB0aGlzLl9zZWdtZW50Mixcblx0XHRcdFx0cGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0XHRpZiAoc2V0SGFuZGxlcykge1xuXHRcdFx0XHRzZWdtZW50MS5faGFuZGxlT3V0LnNldChsZWZ0WzJdIC0gbGVmdFswXSxcblx0XHRcdFx0XHRcdGxlZnRbM10gLSBsZWZ0WzFdKTtcblx0XHRcdFx0c2VnbWVudDIuX2hhbmRsZUluLnNldChyaWdodFs0XSAtIHJpZ2h0WzZdLFxuXHRcdFx0XHRcdFx0cmlnaHRbNV0gLSByaWdodFs3XSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgeCA9IGxlZnRbNl0sIHkgPSBsZWZ0WzddLFxuXHRcdFx0XHRzZWdtZW50ID0gbmV3IFNlZ21lbnQobmV3IFBvaW50KHgsIHkpLFxuXHRcdFx0XHRcdFx0c2V0SGFuZGxlcyAmJiBuZXcgUG9pbnQobGVmdFs0XSAtIHgsIGxlZnRbNV0gLSB5KSxcblx0XHRcdFx0XHRcdHNldEhhbmRsZXMgJiYgbmV3IFBvaW50KHJpZ2h0WzJdIC0geCwgcmlnaHRbM10gLSB5KSk7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRwYXRoLmluc2VydChzZWdtZW50MS5faW5kZXggKyAxLCBzZWdtZW50KTtcblx0XHRcdFx0cmVzID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZ21lbnQ7XG5cdFx0XHRcdHJlcyA9IG5ldyBDdXJ2ZShzZWdtZW50LCBzZWdtZW50Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aFxuXHRcdFx0PyB0aGlzLl9wYXRoLnNwbGl0KHRoaXMuX3NlZ21lbnQxLl9pbmRleCxcblx0XHRcdFx0XHR0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlcikpXG5cdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0cmV2ZXJzZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDIucmV2ZXJzZWQoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZWQoKSk7XG5cdH0sXG5cblx0Y2xlYXJIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uc2V0KDAsIDApO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGdldFZhbHVlczogZnVuY3Rpb24oc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgpIHtcblx0XHR2YXIgcDEgPSBzZWdtZW50MS5fcG9pbnQsXG5cdFx0XHRoMSA9IHNlZ21lbnQxLl9oYW5kbGVPdXQsXG5cdFx0XHRoMiA9IHNlZ21lbnQyLl9oYW5kbGVJbixcblx0XHRcdHAyID0gc2VnbWVudDIuX3BvaW50LFxuXHRcdFx0dmFsdWVzID0gW1xuXHRcdFx0XHRwMS5feCwgcDEuX3ksXG5cdFx0XHRcdHAxLl94ICsgaDEuX3gsIHAxLl95ICsgaDEuX3ksXG5cdFx0XHRcdHAyLl94ICsgaDIuX3gsIHAyLl95ICsgaDIuX3ksXG5cdFx0XHRcdHAyLl94LCBwMi5feVxuXHRcdFx0XTtcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyh2YWx1ZXMsIHZhbHVlcywgNCk7XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRzdWJkaXZpZGU6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRpZiAodCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dCA9IDAuNTtcblx0XHR2YXIgdSA9IDEgLSB0LFxuXHRcdFx0cDN4ID0gdSAqIHAxeCArIHQgKiBjMXgsIHAzeSA9IHUgKiBwMXkgKyB0ICogYzF5LFxuXHRcdFx0cDR4ID0gdSAqIGMxeCArIHQgKiBjMngsIHA0eSA9IHUgKiBjMXkgKyB0ICogYzJ5LFxuXHRcdFx0cDV4ID0gdSAqIGMyeCArIHQgKiBwMngsIHA1eSA9IHUgKiBjMnkgKyB0ICogcDJ5LFxuXHRcdFx0cDZ4ID0gdSAqIHAzeCArIHQgKiBwNHgsIHA2eSA9IHUgKiBwM3kgKyB0ICogcDR5LFxuXHRcdFx0cDd4ID0gdSAqIHA0eCArIHQgKiBwNXgsIHA3eSA9IHUgKiBwNHkgKyB0ICogcDV5LFxuXHRcdFx0cDh4ID0gdSAqIHA2eCArIHQgKiBwN3gsIHA4eSA9IHUgKiBwNnkgKyB0ICogcDd5O1xuXHRcdHJldHVybiBbXG5cdFx0XHRbcDF4LCBwMXksIHAzeCwgcDN5LCBwNngsIHA2eSwgcDh4LCBwOHldLFxuXHRcdFx0W3A4eCwgcDh5LCBwN3gsIHA3eSwgcDV4LCBwNXksIHAyeCwgcDJ5XVxuXHRcdF07XG5cdH0sXG5cblx0c29sdmVDdWJpYzogZnVuY3Rpb24gKHYsIGNvb3JkLCB2YWwsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdHZhciBwMSA9IHZbY29vcmRdLFxuXHRcdFx0YzEgPSB2W2Nvb3JkICsgMl0sXG5cdFx0XHRjMiA9IHZbY29vcmQgKyA0XSxcblx0XHRcdHAyID0gdltjb29yZCArIDZdLFxuXHRcdFx0YyA9IDMgKiAoYzEgLSBwMSksXG5cdFx0XHRiID0gMyAqIChjMiAtIGMxKSAtIGMsXG5cdFx0XHRhID0gcDIgLSBwMSAtIGMgLSBiO1xuXHRcdHJldHVybiBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCBwMSAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24odiwgcG9pbnQpIHtcblx0XHR2YXIgcDEgPSBuZXcgUG9pbnQodlswXSwgdlsxXSksXG5cdFx0XHRwMiA9IG5ldyBQb2ludCh2WzZdLCB2WzddKSxcblx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdHQgPSBwb2ludC5pc0Nsb3NlKHAxLCBlcHNpbG9uKSA/IDBcblx0XHRcdCAgOiBwb2ludC5pc0Nsb3NlKHAyLCBlcHNpbG9uKSA/IDFcblx0XHRcdCAgOiBudWxsO1xuXHRcdGlmICh0ICE9PSBudWxsKVxuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0dmFyIGNvb3JkcyA9IFtwb2ludC54LCBwb2ludC55XSxcblx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRnZW9tRXBzaWxvbiA9IDJlLTc7XG5cdFx0Zm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcblx0XHRcdHZhciBjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgYywgY29vcmRzW2NdLCByb290cywgMCwgMSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dCA9IHJvb3RzW2ldO1xuXHRcdFx0XHRpZiAocG9pbnQuaXNDbG9zZShDdXJ2ZS5nZXRQb2ludCh2LCB0KSwgZ2VvbUVwc2lsb24pKVxuXHRcdFx0XHRcdHJldHVybiB0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQuaXNDbG9zZShwMSwgZ2VvbUVwc2lsb24pID8gMFxuXHRcdFx0IDogcG9pbnQuaXNDbG9zZShwMiwgZ2VvbUVwc2lsb24pID8gMVxuXHRcdFx0IDogbnVsbDtcblx0fSxcblxuXHRnZXROZWFyZXN0UGFyYW1ldGVyOiBmdW5jdGlvbih2LCBwb2ludCkge1xuXHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdFx0dnggPSBwMnggLSBwMXgsIHZ5ID0gcDJ5IC0gcDF5LFxuXHRcdFx0XHRkZXQgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcblx0XHRcdGlmIChkZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0dmFyIHUgPSAoKHBvaW50LnggLSBwMXgpICogdnggKyAocG9pbnQueSAtIHAxeSkgKiB2eSkgLyBkZXQ7XG5cdFx0XHRyZXR1cm4gdSA8IDFlLTEyID8gMFxuXHRcdFx0XHQgOiB1ID4gMC45OTk5OTk5OTk5OTkgPyAxXG5cdFx0XHRcdCA6IEN1cnZlLmdldFBhcmFtZXRlck9mKHYsXG5cdFx0XHRcdFx0bmV3IFBvaW50KHAxeCArIHUgKiB2eCwgcDF5ICsgdSAqIHZ5KSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvdW50ID0gMTAwLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluVCA9IDA7XG5cblx0XHRmdW5jdGlvbiByZWZpbmUodCkge1xuXHRcdFx0aWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcblx0XHRcdFx0dmFyIGRpc3QgPSBwb2ludC5nZXREaXN0YW5jZShDdXJ2ZS5nZXRQb2ludCh2LCB0KSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChkaXN0IDwgbWluRGlzdCkge1xuXHRcdFx0XHRcdG1pbkRpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdG1pblQgPSB0O1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKylcblx0XHRcdHJlZmluZShpIC8gY291bnQpO1xuXG5cdFx0dmFyIHN0ZXAgPSAxIC8gKGNvdW50ICogMik7XG5cdFx0d2hpbGUgKHN0ZXAgPiA0ZS03KSB7XG5cdFx0XHRpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpXG5cdFx0XHRcdHN0ZXAgLz0gMjtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblQ7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24odiwgZnJvbSwgdG8pIHtcblx0XHR2YXIgZmxpcCA9IGZyb20gPiB0bztcblx0XHRpZiAoZmxpcCkge1xuXHRcdFx0dmFyIHRtcCA9IGZyb207XG5cdFx0XHRmcm9tID0gdG87XG5cdFx0XHR0byA9IHRtcDtcblx0XHR9XG5cdFx0aWYgKGZyb20gPiAwKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTtcblx0XHRpZiAodG8gPCAxKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdO1xuXHRcdHJldHVybiBmbGlwXG5cdFx0XHRcdD8gW3ZbNl0sIHZbN10sIHZbNF0sIHZbNV0sIHZbMl0sIHZbM10sIHZbMF0sIHZbMV1dXG5cdFx0XHRcdDogdjtcblx0fSxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuICEoaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG5cdFx0XHRcdCYmIGlzWmVybyh2WzRdIC0gdls2XSkgJiYgaXNaZXJvKHZbNV0gLSB2WzddKSk7XG5cdH0sXG5cblx0aXNGbGF0RW5vdWdoOiBmdW5jdGlvbih2LCB0b2xlcmFuY2UpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdHV4ID0gMyAqIGMxeCAtIDIgKiBwMXggLSBwMngsXG5cdFx0XHR1eSA9IDMgKiBjMXkgLSAyICogcDF5IC0gcDJ5LFxuXHRcdFx0dnggPSAzICogYzJ4IC0gMiAqIHAyeCAtIHAxeCxcblx0XHRcdHZ5ID0gMyAqIGMyeSAtIDIgKiBwMnkgLSBwMXk7XG5cdFx0cmV0dXJuIE1hdGgubWF4KHV4ICogdXgsIHZ4ICogdngpICsgTWF0aC5tYXgodXkgKiB1eSwgdnkgKiB2eSlcblx0XHRcdFx0PCAxMCAqIHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0aDF4ID0gKHZbMl0gKyBwMXgpIC8gMixcblx0XHRcdGgxeSA9ICh2WzNdICsgcDF5KSAvIDIsXG5cdFx0XHRoMnggPSAodls0XSArIHZbNl0pIC8gMixcblx0XHRcdGgyeSA9ICh2WzVdICsgdls3XSkgLyAyO1xuXHRcdHJldHVybiA2ICogKChwMXggLSBoMXgpICogKGgxeSArIHAxeSlcblx0XHRcdFx0ICArIChoMXggLSBoMngpICogKGgyeSArIGgxeSlcblx0XHRcdFx0ICArIChoMnggLSBwMngpICogKHAyeSArIGgyeSkpIC8gMTA7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIG1pbiA9IHYuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gWzAsIDBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKVxuXHRcdFx0Q3VydmUuX2FkZEJvdW5kcyh2W2ldLCB2W2kgKyAyXSwgdltpICsgNF0sIHZbaSArIDZdLFxuXHRcdFx0XHRcdGksIDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRfYWRkQm91bmRzOiBmdW5jdGlvbih2MCwgdjEsIHYyLCB2MywgY29vcmQsIHBhZGRpbmcsIG1pbiwgbWF4LCByb290cykge1xuXHRcdGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuXHRcdFx0dmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG5cdFx0XHRcdHJpZ2h0ID0gdmFsdWUgKyBwYWRkaW5nO1xuXHRcdFx0aWYgKGxlZnQgPCBtaW5bY29vcmRdKVxuXHRcdFx0XHRtaW5bY29vcmRdID0gbGVmdDtcblx0XHRcdGlmIChyaWdodCA+IG1heFtjb29yZF0pXG5cdFx0XHRcdG1heFtjb29yZF0gPSByaWdodDtcblx0XHR9XG5cdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0YyA9IHYxIC0gdjAsXG5cdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRhZGQodjMsIDApO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHQgPSByb290c1tpXSxcblx0XHRcdFx0dSA9IDEgLSB0O1xuXHRcdFx0aWYgKHRNaW4gPCB0ICYmIHQgPCB0TWF4KVxuXHRcdFx0XHRhZGQodSAqIHUgKiB1ICogdjBcblx0XHRcdFx0XHQrIDMgKiB1ICogdSAqIHQgKiB2MVxuXHRcdFx0XHRcdCsgMyAqIHUgKiB0ICogdCAqIHYyXG5cdFx0XHRcdFx0KyB0ICogdCAqIHQgKiB2Myxcblx0XHRcdFx0XHRwYWRkaW5nKTtcblx0XHR9XG5cdH1cbn19LCBCYXNlLmVhY2goXG5cdFsnZ2V0Qm91bmRzJywgJ2dldFN0cm9rZUJvdW5kcycsICdnZXRIYW5kbGVCb3VuZHMnLCAnZ2V0Um91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV07XG5cdFx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXSA9IFBhdGhbbmFtZV0oXG5cdFx0XHRcdFx0XHRbdGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyXSwgZmFsc2UsXG5cdFx0XHRcdFx0XHRwYXRoICYmIHBhdGguZ2V0U3R5bGUoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm91bmRzLmNsb25lKCk7XG5cdFx0fTtcblx0fSxcbntcblxufSksIEJhc2UuZWFjaCh7XG5cdGlzU3RyYWlnaHQ6IGZ1bmN0aW9uKGwsIGgxLCBoMikge1xuXHRcdGlmIChoMS5pc1plcm8oKSAmJiBoMi5pc1plcm8oKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChsLmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChoMS5pc0NvbGxpbmVhcihsKSAmJiBoMi5pc0NvbGxpbmVhcihsKSkge1xuXHRcdFx0dmFyIGRpdiA9IGwuZG90KGwpLFxuXHRcdFx0XHRwMSA9IGwuZG90KGgxKSAvIGRpdixcblx0XHRcdFx0cDIgPSBsLmRvdChoMikgLyBkaXY7XG5cdFx0XHRyZXR1cm4gcDEgPj0gMCAmJiBwMSA8PSAxICYmIHAyIDw9IDAgJiYgcDIgPj0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24obCwgaDEsIGgyKSB7XG5cdFx0dmFyIHRoaXJkID0gbC5kaXZpZGUoMyk7XG5cdFx0cmV0dXJuIGgxLmVxdWFscyh0aGlyZCkgJiYgaDIubmVnYXRlKCkuZXF1YWxzKHRoaXJkKTtcblx0fVxufSwgZnVuY3Rpb24odGVzdCwgbmFtZSkge1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcblx0XHRcdHNlZzIgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRyZXR1cm4gdGVzdChzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCksXG5cdFx0XHRcdHNlZzEuX2hhbmRsZU91dCwgc2VnMi5faGFuZGxlSW4pO1xuXHR9O1xuXG5cdHRoaXMuc3RhdGljc1tuYW1lXSA9IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN107XG5cdFx0cmV0dXJuIHRlc3QobmV3IFBvaW50KHAyeCAtIHAxeCwgcDJ5IC0gcDF5KSxcblx0XHRcdFx0bmV3IFBvaW50KHZbMl0gLSBwMXgsIHZbM10gLSBwMXkpLFxuXHRcdFx0XHRuZXcgUG9pbnQodls0XSAtIHAyeCwgdls1XSAtIHAyeSkpO1xuXHR9O1xufSwge1xuXHRzdGF0aWNzOiB7fSxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0fHwgIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRyZXR1cm4gY3VydmUgJiYgdGhpcy5pc1N0cmFpZ2h0KCkgJiYgY3VydmUuaXNTdHJhaWdodCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0TGluZSgpLmlzQ29sbGluZWFyKGN1cnZlLmdldExpbmUoKSk7XG5cdH0sXG5cblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1N0cmFpZ2h0KCkgJiYgTWF0aC5hYnModGhpcy5nZXRUYW5nZW50QXQoMC41LCB0cnVlKS55KVxuXHRcdFx0XHQ8IDFlLTc7XG5cdH0sXG5cblx0aXNWZXJ0aWNhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNTdHJhaWdodCgpICYmIE1hdGguYWJzKHRoaXMuZ2V0VGFuZ2VudEF0KDAuNSwgdHJ1ZSkueClcblx0XHRcdFx0PCAxZS03O1xuXHR9XG59KSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKG9mZnNldCwgc3RhcnQpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyQXQodGhpcy5nZXRWYWx1ZXMoKSwgb2Zmc2V0LCBzdGFydCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLmdldFZhbHVlcygpLCBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgdCA9IGlzUGFyYW1ldGVyID8gb2Zmc2V0IDogdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdHJldHVybiB0ICE9IG51bGwgJiYgdCA+PSAwICYmIHQgPD0gMVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0KHRoaXMuZ2V0UGFyYW1ldGVyT2YoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcblx0XHRcdFx0dHJ1ZSk7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldE9mZnNldCgpIDogbnVsbDtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHR0ID0gQ3VydmUuZ2V0TmVhcmVzdFBhcmFtZXRlcih2YWx1ZXMsIHBvaW50KSxcblx0XHRcdHB0ID0gQ3VydmUuZ2V0UG9pbnQodmFsdWVzLCB0KTtcblx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgdCwgcHQsIG51bGwsIHBvaW50LmdldERpc3RhbmNlKHB0KSk7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKS5nZXRQb2ludCgpO1xuXHR9XG5cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtZXRob2RzID0gWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRXZWlnaHRlZFRhbmdlbnQnLFxuXHRcdCdnZXRXZWlnaHRlZE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXTtcblx0cmV0dXJuIEJhc2UuZWFjaChtZXRob2RzLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcblx0XHRcdHJldHVybiBDdXJ2ZVtuYW1lXSh2YWx1ZXMsIGlzUGFyYW1ldGVyID8gb2Zmc2V0XG5cdFx0XHRcdFx0OiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh2YWx1ZXMsIG9mZnNldCwgMCkpO1xuXHRcdH07XG5cdH0sIHtcblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRldmFsdWF0ZU1ldGhvZHM6IG1ldGhvZHNcblx0XHR9XG5cdH0pXG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldExlbmd0aEludGVncmFuZCh2KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqIChjMXggLSBjMngpICsgMyAqIChwMnggLSBwMXgpLFxuXHRcdFx0YnggPSA2ICogKHAxeCArIGMyeCkgLSAxMiAqIGMxeCxcblx0XHRcdGN4ID0gMyAqIChjMXggLSBwMXgpLFxuXG5cdFx0XHRheSA9IDkgKiAoYzF5IC0gYzJ5KSArIDMgKiAocDJ5IC0gcDF5KSxcblx0XHRcdGJ5ID0gNiAqIChwMXkgKyBjMnkpIC0gMTIgKiBjMXksXG5cdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmFsdWF0ZSh2LCB0LCB0eXBlLCBub3JtYWxpemVkKSB7XG5cdFx0aWYgKHQgPT0gbnVsbCB8fCB0IDwgMCB8fCB0ID4gMSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKHR5cGUgPT09IDAgJiYgKHQgPCB0TWluIHx8IHQgPiB0TWF4KSkge1xuXHRcdFx0dmFyIGlzWmVybyA9IHQgPCB0TWluO1xuXHRcdFx0eCA9IGlzWmVybyA/IHAxeCA6IHAyeDtcblx0XHRcdHkgPSBpc1plcm8gPyBwMXkgOiBwMnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblx0XHRcdFx0YnggPSAzICogKGMyeCAtIGMxeCkgLSBjeCxcblx0XHRcdFx0YXggPSBwMnggLSBwMXggLSBjeCAtIGJ4LFxuXG5cdFx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpLFxuXHRcdFx0XHRieSA9IDMgKiAoYzJ5IC0gYzF5KSAtIGN5LFxuXHRcdFx0XHRheSA9IHAyeSAtIHAxeSAtIGN5IC0gYnk7XG5cdFx0XHRpZiAodHlwZSA9PT0gMCkge1xuXHRcdFx0XHR4ID0gKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHAxeDtcblx0XHRcdFx0eSA9ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyBwMXk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodCA8IHRNaW4pIHtcblx0XHRcdFx0XHR4ID0gY3g7XG5cdFx0XHRcdFx0eSA9IGN5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQgPiB0TWF4KSB7XG5cdFx0XHRcdFx0eCA9IDMgKiAocDJ4IC0gYzJ4KTtcblx0XHRcdFx0XHR5ID0gMyAqIChwMnkgLSBjMnkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHggPSAoMyAqIGF4ICogdCArIDIgKiBieCkgKiB0ICsgY3g7XG5cdFx0XHRcdFx0eSA9ICgzICogYXkgKiB0ICsgMiAqIGJ5KSAqIHQgKyBjeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9ybWFsaXplZCkge1xuXHRcdFx0XHRcdGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgKHQgPCB0TWluIHx8IHQgPiB0TWF4KSkge1xuXHRcdFx0XHRcdFx0eCA9IGMyeCAtIGMxeDtcblx0XHRcdFx0XHRcdHkgPSBjMnkgLSBjMXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdFx0aWYgKGxlbikge1xuXHRcdFx0XHRcdFx0eCAvPSBsZW47XG5cdFx0XHRcdFx0XHR5IC89IGxlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHR2YXIgeDIgPSA2ICogYXggKiB0ICsgMiAqIGJ4LFxuXHRcdFx0XHRcdFx0eTIgPSA2ICogYXkgKiB0ICsgMiAqIGJ5LFxuXHRcdFx0XHRcdFx0ZCA9IE1hdGgucG93KHggKiB4ICsgeSAqIHksIDMgLyAyKTtcblx0XHRcdFx0XHR4ID0gZCAhPT0gMCA/ICh4ICogeTIgLSB5ICogeDIpIC8gZCA6IDA7XG5cdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHR5cGUgPT09IDIgPyBuZXcgUG9pbnQoeSwgLXgpIDogbmV3IFBvaW50KHgsIHkpO1xuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbih2LCBhLCBiKSB7XG5cdFx0XHRpZiAoYSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRhID0gMDtcblx0XHRcdGlmIChiID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGIgPSAxO1xuXHRcdFx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMSAmJiBDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHRcdHZhciBkeCA9IHZbNl0gLSB2WzBdLFxuXHRcdFx0XHRcdGR5ID0gdls3XSAtIHZbMV07XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpO1xuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIGEsIGIsIGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdH0sXG5cblx0XHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24odiwgb2Zmc2V0LCBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHN0YXJ0ID0gb2Zmc2V0IDwgMCA/IDEgOiAwXG5cdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gc3RhcnQ7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdGZvcndhcmQgPSBvZmZzZXQgPiAwLFxuXHRcdFx0XHRhID0gZm9yd2FyZCA/IHN0YXJ0IDogMCxcblx0XHRcdFx0YiA9IGZvcndhcmQgPyAxIDogc3RhcnQsXG5cdFx0XHRcdGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpLFxuXHRcdFx0XHRyYW5nZUxlbmd0aCA9IE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIGEsIGIsXG5cdFx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHRcdGlmIChhYnMob2Zmc2V0IC0gcmFuZ2VMZW5ndGgpIDwgMWUtMTIpIHtcblx0XHRcdFx0cmV0dXJuIGZvcndhcmQgPyBiIDogYTtcblx0XHRcdH0gZWxzZSBpZiAoYWJzKG9mZnNldCkgPiByYW5nZUxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMzIsXG5cdFx0XHRcdFx0MWUtMTIpO1xuXHRcdH0sXG5cblx0XHRnZXRQb2ludDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDAsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0Q3VydmF0dXJlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMywgZmFsc2UpLng7XG5cdFx0fVxuXHR9fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSwgdjEsIGMxLCB0MSwgcDEsIHYyLCBjMiwgdDIsIHAyLFxuXHRcdFx0b3ZlcmxhcCkge1xuXHRcdHZhciBzdGFydENvbm5lY3RlZCA9IHBhcmFtLnN0YXJ0Q29ubmVjdGVkLFxuXHRcdFx0ZW5kQ29ubmVjdGVkID0gcGFyYW0uZW5kQ29ubmVjdGVkLFxuXHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0aWYgKHQxID09IG51bGwpXG5cdFx0XHR0MSA9IEN1cnZlLmdldFBhcmFtZXRlck9mKHYxLCBwMSk7XG5cdFx0aWYgKHQxICE9PSBudWxsICYmIHQxID49IChzdGFydENvbm5lY3RlZCA/IHRNaW4gOiAwKSAmJlxuXHRcdFx0dDEgPD0gKGVuZENvbm5lY3RlZCA/IHRNYXggOiAxKSkge1xuXHRcdFx0aWYgKHQyID09IG51bGwpXG5cdFx0XHRcdHQyID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodjIsIHAyKTtcblx0XHRcdGlmICh0MiAhPT0gbnVsbCAmJiB0MiA+PSAoZW5kQ29ubmVjdGVkID8gdE1pbiA6IDApICYmXG5cdFx0XHRcdHQyIDw9IChzdGFydENvbm5lY3RlZCA/IHRNYXggOiAxKSkge1xuXHRcdFx0XHR2YXIgcmVub3JtYWxpemUgPSBwYXJhbS5yZW5vcm1hbGl6ZTtcblx0XHRcdFx0aWYgKHJlbm9ybWFsaXplKSB7XG5cdFx0XHRcdFx0dmFyIHJlcyA9IHJlbm9ybWFsaXplKHQxLCB0Mik7XG5cdFx0XHRcdFx0dDEgPSByZXNbMF07XG5cdFx0XHRcdFx0dDIgPSByZXNbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGxvYzEgPSBuZXcgQ3VydmVMb2NhdGlvbihjMSwgdDEsXG5cdFx0XHRcdFx0XHRwMSB8fCBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLCBvdmVybGFwKSxcblx0XHRcdFx0XHRsb2MyID0gbmV3IEN1cnZlTG9jYXRpb24oYzIsIHQyLFxuXHRcdFx0XHRcdFx0cDIgfHwgQ3VydmUuZ2V0UG9pbnQodjIsIHQyKSwgb3ZlcmxhcCksXG5cdFx0XHRcdFx0ZmxpcCA9IGxvYzEuZ2V0UGF0aCgpID09PSBsb2MyLmdldFBhdGgoKVxuXHRcdFx0XHRcdFx0JiYgbG9jMS5nZXRJbmRleCgpID4gbG9jMi5nZXRJbmRleCgpLFxuXHRcdFx0XHRcdGxvYyA9IGZsaXAgPyBsb2MyIDogbG9jMSxcblx0XHRcdFx0XHRpbmNsdWRlID0gcGFyYW0uaW5jbHVkZTtcblx0XHRcdFx0bG9jMS5faW50ZXJzZWN0aW9uID0gbG9jMjtcblx0XHRcdFx0bG9jMi5faW50ZXJzZWN0aW9uID0gbG9jMTtcblx0XHRcdFx0aWYgKCFpbmNsdWRlIHx8IGluY2x1ZGUobG9jKSkge1xuXHRcdFx0XHRcdEN1cnZlTG9jYXRpb24uaW5zZXJ0KGxvY2F0aW9ucywgbG9jLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcblx0XHRpZiAoKytyZWN1cnNpb24gPj0gMjQpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHEweCA9IHYyWzBdLCBxMHkgPSB2MlsxXSwgcTN4ID0gdjJbNl0sIHEzeSA9IHYyWzddLFxuXHRcdFx0Z2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuXHRcdFx0ZDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzJdLCB2MlszXSksXG5cdFx0XHRkMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbNF0sIHYyWzVdKSxcblx0XHRcdGZhY3RvciA9IGQxICogZDIgPiAwID8gMyAvIDQgOiA0IC8gOSxcblx0XHRcdGRNaW4gPSBmYWN0b3IgKiBNYXRoLm1pbigwLCBkMSwgZDIpLFxuXHRcdFx0ZE1heCA9IGZhY3RvciAqIE1hdGgubWF4KDAsIGQxLCBkMiksXG5cdFx0XHRkcDAgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzBdLCB2MVsxXSksXG5cdFx0XHRkcDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzJdLCB2MVszXSksXG5cdFx0XHRkcDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzRdLCB2MVs1XSksXG5cdFx0XHRkcDMgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzZdLCB2MVs3XSksXG5cdFx0XHRodWxsID0gZ2V0Q29udmV4SHVsbChkcDAsIGRwMSwgZHAyLCBkcDMpLFxuXHRcdFx0dG9wID0gaHVsbFswXSxcblx0XHRcdGJvdHRvbSA9IGh1bGxbMV0sXG5cdFx0XHR0TWluQ2xpcCxcblx0XHRcdHRNYXhDbGlwO1xuXHRcdGlmICgodE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCkpID09IG51bGwgfHxcblx0XHRcdCh0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcC5yZXZlcnNlKCksIGJvdHRvbS5yZXZlcnNlKCksXG5cdFx0XHRcdGRNaW4sIGRNYXgpKSA9PSBudWxsKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcblx0XHR2YXIgdERpZmYgPSB0TWF4Q2xpcCAtIHRNaW5DbGlwLFxuXHRcdFx0dE1pbk5ldyA9IHRNaW4gKyAodE1heCAtIHRNaW4pICogdE1pbkNsaXAsXG5cdFx0XHR0TWF4TmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWF4Q2xpcDtcblx0XHRpZiAob2xkVERpZmYgPiAwLjUgJiYgdERpZmYgPiAwLjUpIHtcblx0XHRcdGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVNYXggLSB1TWluKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHR0ID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjMiwgYzEsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdCwgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzFdLCBjMiwgYzEsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdCwgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuXHRcdFx0XHRcdHQgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRwYXJ0c1swXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHR1TWluLCB0LCB0TWluTmV3LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRwYXJ0c1sxXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHR0LCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpXG5cdFx0XHRcdDwgMWUtNykge1xuXHRcdFx0dmFyIHQxID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyLFxuXHRcdFx0XHR0MiA9IHVNaW4gKyAodU1heCAtIHVNaW4pIC8gMjtcblx0XHRcdHYxID0gYzEuZ2V0VmFsdWVzKCk7XG5cdFx0XHR2MiA9IGMyLmdldFZhbHVlcygpO1xuXHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0cmV2ZXJzZSA/IHYyIDogdjEsIHJldmVyc2UgPyBjMiA6IGMxLCByZXZlcnNlID8gdDIgOiB0MSwgbnVsbCxcblx0XHRcdFx0cmV2ZXJzZSA/IHYxIDogdjIsIHJldmVyc2UgPyBjMSA6IGMyLCByZXZlcnNlID8gdDEgOiB0MiwgbnVsbCk7XG5cdFx0fSBlbHNlIGlmICh0RGlmZiA+IDFlLTEyKSB7XG5cdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnModjIsIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnZleEh1bGwoZHEwLCBkcTEsIGRxMiwgZHEzKSB7XG5cdFx0dmFyIHAwID0gWyAwLCBkcTAgXSxcblx0XHRcdHAxID0gWyAxIC8gMywgZHExIF0sXG5cdFx0XHRwMiA9IFsgMiAvIDMsIGRxMiBdLFxuXHRcdFx0cDMgPSBbIDEsIGRxMyBdLFxuXHRcdFx0ZGlzdDEgPSBkcTEgLSAoMiAqIGRxMCArIGRxMykgLyAzLFxuXHRcdFx0ZGlzdDIgPSBkcTIgLSAoZHEwICsgMiAqIGRxMykgLyAzLFxuXHRcdFx0aHVsbDtcblx0XHRpZiAoZGlzdDEgKiBkaXN0MiA8IDApIHtcblx0XHRcdGh1bGwgPSBbW3AwLCBwMSwgcDNdLCBbcDAsIHAyLCBwM11dO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGlzdFJhdGlvID0gZGlzdDEgLyBkaXN0Mjtcblx0XHRcdGh1bGwgPSBbXG5cdFx0XHRcdGRpc3RSYXRpbyA+PSAyID8gW3AwLCBwMSwgcDNdXG5cdFx0XHRcdDogZGlzdFJhdGlvIDw9IC41ID8gW3AwLCBwMiwgcDNdXG5cdFx0XHRcdDogW3AwLCBwMSwgcDIsIHAzXSxcblx0XHRcdFx0W3AwLCBwM11cblx0XHRcdF07XG5cdFx0fVxuXHRcdHJldHVybiAoZGlzdDEgfHwgZGlzdDIpIDwgMCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8IGRNaW4pIHtcblx0XHRcdHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbFRvcCwgdHJ1ZSwgZE1pbik7XG5cdFx0fSBlbHNlIGlmIChodWxsQm90dG9tWzBdWzFdID4gZE1heCkge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsQm90dG9tLCBmYWxzZSwgZE1heCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBodWxsVG9wWzBdWzBdO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsUGFydChwYXJ0LCB0b3AsIHRocmVzaG9sZCkge1xuXHRcdHZhciBweCA9IHBhcnRbMF1bMF0sXG5cdFx0XHRweSA9IHBhcnRbMF1bMV07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBwYXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHF4ID0gcGFydFtpXVswXSxcblx0XHRcdFx0cXkgPSBwYXJ0W2ldWzFdO1xuXHRcdFx0aWYgKHRvcCA/IHF5ID49IHRocmVzaG9sZCA6IHF5IDw9IHRocmVzaG9sZCkge1xuXHRcdFx0XHRyZXR1cm4gcXkgPT09IHRocmVzaG9sZCA/IHF4XG5cdFx0XHRcdFx0XHQ6IHB4ICsgKHRocmVzaG9sZCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdH1cblx0XHRcdHB4ID0gcXg7XG5cdFx0XHRweSA9IHF5O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgcGFyYW0pIHtcblx0XHR2YXIgZmxpcCA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuXHRcdFx0dmMgPSBmbGlwID8gdjIgOiB2MSxcblx0XHRcdHZsID0gZmxpcCA/IHYxIDogdjIsXG5cdFx0XHRseDEgPSB2bFswXSwgbHkxID0gdmxbMV0sXG5cdFx0XHRseDIgPSB2bFs2XSwgbHkyID0gdmxbN10sXG5cdFx0XHRsZHggPSBseDIgLSBseDEsXG5cdFx0XHRsZHkgPSBseTIgLSBseTEsXG5cdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoLWxkeSwgbGR4KSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHJ2YyA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdmNbaV0gLSBseDEsXG5cdFx0XHRcdHkgPSB2Y1tpICsgMV0gLSBseTE7XG5cdFx0XHRydmMucHVzaChcblx0XHRcdFx0eCAqIGNvcyAtIHkgKiBzaW4sXG5cdFx0XHRcdHggKiBzaW4gKyB5ICogY29zKTtcblx0XHR9XG5cdFx0dmFyIHJvb3RzID0gW10sXG5cdFx0XHRjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWMocnZjLCAxLCAwLCByb290cywgMCwgMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdGMgPSByb290c1tpXSxcblx0XHRcdFx0cGMgPSBDdXJ2ZS5nZXRQb2ludCh2YywgdGMpLFxuXHRcdFx0XHR0bCA9IEN1cnZlLmdldFBhcmFtZXRlck9mKHZsLCBwYyk7XG5cdFx0XHRpZiAodGwgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIHBsID0gQ3VydmUuZ2V0UG9pbnQodmwsIHRsKSxcblx0XHRcdFx0XHR0MSA9IGZsaXAgPyB0bCA6IHRjLFxuXHRcdFx0XHRcdHQyID0gZmxpcCA/IHRjIDogdGw7XG5cdFx0XHRcdGlmICghcGFyYW0uZW5kQ29ubmVjdGVkIHx8IHQyID4gTnVtZXJpY2FsLkNVUlZFVElNRV9FUFNJTE9OKSB7XG5cdFx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHRcdFx0djEsIGMxLCB0MSwgZmxpcCA/IHBsIDogcGMsXG5cdFx0XHRcdFx0XHRcdHYyLCBjMiwgdDIsIGZsaXAgPyBwYyA6IHBsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZExpbmVJbnRlcnNlY3Rpb24odjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgcGFyYW0pIHtcblx0XHR2YXIgcHQgPSBMaW5lLmludGVyc2VjdChcblx0XHRcdFx0djFbMF0sIHYxWzFdLCB2MVs2XSwgdjFbN10sXG5cdFx0XHRcdHYyWzBdLCB2MlsxXSwgdjJbNl0sIHYyWzddKTtcblx0XHRpZiAocHQpIHtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sIHYxLCBjMSwgbnVsbCwgcHQsIHYyLCBjMiwgbnVsbCwgcHQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblx0XHRfZ2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24odjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgcGFyYW0pIHtcblx0XHRcdGlmICghdjIpIHtcblx0XHRcdFx0cmV0dXJuIEN1cnZlLl9nZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCBjMSwgbG9jYXRpb25zLCBwYXJhbSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYzFwMXggPSB2MVswXSwgYzFwMXkgPSB2MVsxXSxcblx0XHRcdFx0YzFwMnggPSB2MVs2XSwgYzFwMnkgPSB2MVs3XSxcblx0XHRcdFx0YzJwMXggPSB2MlswXSwgYzJwMXkgPSB2MlsxXSxcblx0XHRcdFx0YzJwMnggPSB2Mls2XSwgYzJwMnkgPSB2Mls3XSxcblx0XHRcdFx0YzFzMXggPSAoMyAqIHYxWzJdICsgYzFwMXgpIC8gNCxcblx0XHRcdFx0YzFzMXkgPSAoMyAqIHYxWzNdICsgYzFwMXkpIC8gNCxcblx0XHRcdFx0YzFzMnggPSAoMyAqIHYxWzRdICsgYzFwMngpIC8gNCxcblx0XHRcdFx0YzFzMnkgPSAoMyAqIHYxWzVdICsgYzFwMnkpIC8gNCxcblx0XHRcdFx0YzJzMXggPSAoMyAqIHYyWzJdICsgYzJwMXgpIC8gNCxcblx0XHRcdFx0YzJzMXkgPSAoMyAqIHYyWzNdICsgYzJwMXkpIC8gNCxcblx0XHRcdFx0YzJzMnggPSAoMyAqIHYyWzRdICsgYzJwMngpIC8gNCxcblx0XHRcdFx0YzJzMnkgPSAoMyAqIHYyWzVdICsgYzJwMnkpIC8gNCxcblx0XHRcdFx0bWluID0gTWF0aC5taW4sXG5cdFx0XHRcdG1heCA9IE1hdGgubWF4O1xuXHRcdFx0aWYgKCEoXHRtYXgoYzFwMXgsIGMxczF4LCBjMXMyeCwgYzFwMngpID49XG5cdFx0XHRcdFx0bWluKGMycDF4LCBjMnMxeCwgYzJzMngsIGMycDJ4KSAmJlxuXHRcdFx0XHRcdG1pbihjMXAxeCwgYzFzMXgsIGMxczJ4LCBjMXAyeCkgPD1cblx0XHRcdFx0XHRtYXgoYzJwMXgsIGMyczF4LCBjMnMyeCwgYzJwMngpICYmXG5cdFx0XHRcdFx0bWF4KGMxcDF5LCBjMXMxeSwgYzFzMnksIGMxcDJ5KSA+PVxuXHRcdFx0XHRcdG1pbihjMnAxeSwgYzJzMXksIGMyczJ5LCBjMnAyeSkgJiZcblx0XHRcdFx0XHRtaW4oYzFwMXksIGMxczF5LCBjMXMyeSwgYzFwMnkpIDw9XG5cdFx0XHRcdFx0bWF4KGMycDF5LCBjMnMxeSwgYzJzMnksIGMycDJ5KSkpXG5cdFx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0XHRpZiAoIXBhcmFtLnN0YXJ0Q29ubmVjdGVkICYmICFwYXJhbS5lbmRDb25uZWN0ZWQpIHtcblx0XHRcdFx0dmFyIG92ZXJsYXBzID0gQ3VydmUuZ2V0T3ZlcmxhcHModjEsIHYyKTtcblx0XHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBvdmVybGFwID0gb3ZlcmxhcHNbaV07XG5cdFx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdFx0XHR2MSwgYzEsIG92ZXJsYXBbMF0sIG51bGwsXG5cdFx0XHRcdFx0XHRcdHYyLCBjMiwgb3ZlcmxhcFsxXSwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuXHRcdFx0XHRzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcblx0XHRcdFx0c3RyYWlnaHQgPSBzdHJhaWdodDEgJiYgc3RyYWlnaHQyLFxuXHRcdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRcdGJlZm9yZSA9IGxvY2F0aW9ucy5sZW5ndGg7XG5cdFx0XHQoc3RyYWlnaHRcblx0XHRcdFx0PyBhZGRMaW5lSW50ZXJzZWN0aW9uXG5cdFx0XHRcdDogc3RyYWlnaHQxIHx8IHN0cmFpZ2h0MlxuXHRcdFx0XHRcdD8gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShcblx0XHRcdFx0XHRcdHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdFx0MCwgMSwgMCwgMSwgMCwgZmFsc2UsIDApO1xuXHRcdFx0aWYgKHN0cmFpZ2h0ICYmIGxvY2F0aW9ucy5sZW5ndGggPiBiZWZvcmUpXG5cdFx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0XHR2YXIgYzFwMSA9IG5ldyBQb2ludChjMXAxeCwgYzFwMXkpLFxuXHRcdFx0XHRjMXAyID0gbmV3IFBvaW50KGMxcDJ4LCBjMXAyeSksXG5cdFx0XHRcdGMycDEgPSBuZXcgUG9pbnQoYzJwMXgsIGMycDF5KSxcblx0XHRcdFx0YzJwMiA9IG5ldyBQb2ludChjMnAyeCwgYzJwMnkpO1xuXHRcdFx0aWYgKGMxcDEuaXNDbG9zZShjMnAxLCBlcHNpbG9uKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSwgdjEsIGMxLCAwLCBjMXAxLCB2MiwgYzIsIDAsIGMycDEpO1xuXHRcdFx0aWYgKCFwYXJhbS5zdGFydENvbm5lY3RlZCAmJiBjMXAxLmlzQ2xvc2UoYzJwMiwgZXBzaWxvbikpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sIHYxLCBjMSwgMCwgYzFwMSwgdjIsIGMyLCAxLCBjMnAyKTtcblx0XHRcdGlmICghcGFyYW0uZW5kQ29ubmVjdGVkICYmIGMxcDIuaXNDbG9zZShjMnAxLCBlcHNpbG9uKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSwgdjEsIGMxLCAxLCBjMXAyLCB2MiwgYzIsIDAsIGMycDEpO1xuXHRcdFx0aWYgKGMxcDIuaXNDbG9zZShjMnAyLCBlcHNpbG9uKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSwgdjEsIGMxLCAxLCBjMXAyLCB2MiwgYzIsIDEsIGMycDIpO1xuXHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHR9LFxuXG5cdFx0X2dldFNlbGZJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHYxLCBjMSwgbG9jYXRpb25zLCBwYXJhbSkge1xuXHRcdFx0dmFyIHAxeCA9IHYxWzBdLCBwMXkgPSB2MVsxXSxcblx0XHRcdFx0aDF4ID0gdjFbMl0sIGgxeSA9IHYxWzNdLFxuXHRcdFx0XHRoMnggPSB2MVs0XSwgaDJ5ID0gdjFbNV0sXG5cdFx0XHRcdHAyeCA9IHYxWzZdLCBwMnkgPSB2MVs3XTtcblx0XHRcdHZhciBsaW5lID0gbmV3IExpbmUocDF4LCBwMXksIHAyeCwgcDJ5LCBmYWxzZSksXG5cdFx0XHRcdHNpZGUxID0gbGluZS5nZXRTaWRlKG5ldyBQb2ludChoMXgsIGgxeSksIHRydWUpLFxuXHRcdFx0XHRzaWRlMiA9IGxpbmUuZ2V0U2lkZShuZXcgUG9pbnQoaDJ4LCBoMnkpLCB0cnVlKTtcblx0XHRcdGlmIChzaWRlMSA9PT0gc2lkZTIpIHtcblx0XHRcdFx0dmFyIGVkZ2VTdW0gPSAocDF4IC0gaDJ4KSAqIChoMXkgLSBwMnkpXG5cdFx0XHRcdFx0XHRcdCsgKGgxeCAtIHAyeCkgKiAoaDJ5IC0gcDF5KTtcblx0XHRcdFx0aWYgKGVkZ2VTdW0gKiBzaWRlMSA+IDApXG5cdFx0XHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHRcdH1cblx0XHRcdHZhciBheCA9IHAyeCAtIDMgKiBoMnggKyAzICogaDF4IC0gcDF4LFxuXHRcdFx0XHRieCA9IGgyeCAtIDIgKiBoMXggKyBwMXgsXG5cdFx0XHRcdGN4ID0gaDF4IC0gcDF4LFxuXHRcdFx0XHRheSA9IHAyeSAtIDMgKiBoMnkgKyAzICogaDF5IC0gcDF5LFxuXHRcdFx0XHRieSA9IGgyeSAtIDIgKiBoMXkgKyBwMXksXG5cdFx0XHRcdGN5ID0gaDF5IC0gcDF5LFxuXHRcdFx0XHRhYyA9IGF5ICogY3ggLSBheCAqIGN5LFxuXHRcdFx0XHRhYiA9IGF5ICogYnggLSBheCAqIGJ5LFxuXHRcdFx0XHRiYyA9IGJ5ICogY3ggLSBieCAqIGN5O1xuXHRcdFx0aWYgKGFjICogYWMgLSA0ICogYWIgKiBiYyA8IDApIHtcblx0XHRcdFx0dmFyIHJvb3RzID0gW10sXG5cdFx0XHRcdFx0dFNwbGl0LFxuXHRcdFx0XHRcdGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoXG5cdFx0XHRcdFx0XHRcdGF4ICogYXhcdCArIGF5ICogYXksXG5cdFx0XHRcdFx0XHRcdDMgKiAoYXggKiBieCArIGF5ICogYnkpLFxuXHRcdFx0XHRcdFx0XHQyICogKGJ4ICogYnggKyBieSAqIGJ5KSArIGF4ICogY3ggKyBheSAqIGN5LFxuXHRcdFx0XHRcdFx0XHRieCAqIGN4ICsgYnkgKiBjeSxcblx0XHRcdFx0XHRcdFx0cm9vdHMsIDAsIDEpO1xuXHRcdFx0XHRpZiAoY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG1heEN1cnZhdHVyZSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VydmF0dXJlID0gTWF0aC5hYnMoXG5cdFx0XHRcdFx0XHRcdFx0YzEuZ2V0Q3VydmF0dXJlQXQocm9vdHNbaV0sIHRydWUpKTtcblx0XHRcdFx0XHRcdGlmIChjdXJ2YXR1cmUgPiBtYXhDdXJ2YXR1cmUpIHtcblx0XHRcdFx0XHRcdFx0bWF4Q3VydmF0dXJlID0gY3VydmF0dXJlO1xuXHRcdFx0XHRcdFx0XHR0U3BsaXQgPSByb290c1tpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYxLCB0U3BsaXQpO1xuXHRcdFx0XHRcdHBhcmFtLmVuZENvbm5lY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0cGFyYW0ucmVub3JtYWxpemUgPSBmdW5jdGlvbih0MSwgdDIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBbdDEgKiB0U3BsaXQsIHQyICogKDEgLSB0U3BsaXQpICsgdFNwbGl0XTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdEN1cnZlLl9nZXRJbnRlcnNlY3Rpb25zKHBhcnRzWzBdLCBwYXJ0c1sxXSwgYzEsIGMxLFxuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbnMsIHBhcmFtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHR9LFxuXG5cdFx0Z2V0T3ZlcmxhcHM6IGZ1bmN0aW9uKHYxLCB2Mikge1xuXHRcdFx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHR0aW1lRXBzaWxvbiA9IDRlLTcsXG5cdFx0XHRcdGdlb21FcHNpbG9uID0gMmUtNyxcblx0XHRcdFx0c3RyYWlnaHQxID0gQ3VydmUuaXNTdHJhaWdodCh2MSksXG5cdFx0XHRcdHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuXHRcdFx0XHRzdHJhaWdodCA9XHRzdHJhaWdodDEgJiYgc3RyYWlnaHQyO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoU3F1YXJlZCh2KSB7XG5cdFx0XHRcdHZhciB4ID0gdls2XSAtIHZbMF0sXG5cdFx0XHRcdFx0eSA9IHZbN10gLSB2WzFdO1xuXHRcdFx0XHRyZXR1cm4geCAqIHggKyB5ICogeTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0cmFpZ2h0KSB7XG5cdFx0XHRcdHZhciBmbGlwID0gZ2V0TGluZUxlbmd0aFNxdWFyZWQodjEpIDwgZ2V0TGluZUxlbmd0aFNxdWFyZWQodjIpLFxuXHRcdFx0XHRcdGwxID0gZmxpcCA/IHYyIDogdjEsXG5cdFx0XHRcdFx0bDIgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUobDFbMF0sIGwxWzFdLCBsMVs2XSwgbDFbN10pO1xuXHRcdFx0XHRpZiAobGluZS5nZXREaXN0YW5jZShuZXcgUG9pbnQobDJbMF0sIGwyWzFdKSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRcdGxpbmUuZ2V0RGlzdGFuY2UobmV3IFBvaW50KGwyWzZdLCBsMls3XSkpID4gZ2VvbUVwc2lsb24pXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHN0cmFpZ2h0MSBeIHN0cmFpZ2h0Mikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHYgPSBbdjEsIHYyXSxcblx0XHRcdFx0cGFpcnMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCB0MSA9IDA7XG5cdFx0XHRcdFx0aSA8IDIgJiYgcGFpcnMubGVuZ3RoIDwgMjtcblx0XHRcdFx0XHRpICs9IHQxID09PSAwID8gMCA6IDEsIHQxID0gdDEgXiAxKSB7XG5cdFx0XHRcdHZhciB0MiA9IEN1cnZlLmdldFBhcmFtZXRlck9mKHZbaSBeIDFdLCBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHR2W2ldW3QxID09PSAwID8gMCA6IDZdLFxuXHRcdFx0XHRcdFx0dltpXVt0MSA9PT0gMCA/IDEgOiA3XSkpO1xuXHRcdFx0XHRpZiAodDIgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBwYWlyID0gaSA9PT0gMCA/IFt0MSwgdDJdIDogW3QyLCB0MV07XG5cdFx0XHRcdFx0aWYgKHBhaXJzLmxlbmd0aCA9PT0gMCB8fFxuXHRcdFx0XHRcdFx0YWJzKHBhaXJbMF0gLSBwYWlyc1swXVswXSkgPiB0aW1lRXBzaWxvbiAmJlxuXHRcdFx0XHRcdFx0YWJzKHBhaXJbMV0gLSBwYWlyc1swXVsxXSkgPiB0aW1lRXBzaWxvbilcblx0XHRcdFx0XHRcdHBhaXJzLnB1c2gocGFpcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkgPT09IDEgJiYgcGFpcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhaXJzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRwYWlycyA9IG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKCFzdHJhaWdodCkge1xuXHRcdFx0XHR2YXIgbzEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCBwYWlyc1swXVswXSwgcGFpcnNbMV1bMF0pLFxuXHRcdFx0XHRcdG8yID0gQ3VydmUuZ2V0UGFydCh2MiwgcGFpcnNbMF1bMV0sIHBhaXJzWzFdWzFdKTtcblx0XHRcdFx0aWYgKGFicyhvMlsyXSAtIG8xWzJdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdFx0YWJzKG8yWzNdIC0gbzFbM10pID4gZ2VvbUVwc2lsb24gfHxcblx0XHRcdFx0XHRhYnMobzJbNF0gLSBvMVs0XSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRcdGFicyhvMls1XSAtIG8xWzVdKSA+IGdlb21FcHNpbG9uKVxuXHRcdFx0XHRcdHBhaXJzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYWlycztcblx0XHR9XG5cdH19O1xufSk7XG5cbnZhciBDdXJ2ZUxvY2F0aW9uID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZUxvY2F0aW9uJyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmVMb2NhdGlvbihjdXJ2ZSwgcGFyYW1ldGVyLCBwb2ludCxcblx0XHRcdF9vdmVybGFwLCBfZGlzdGFuY2UpIHtcblx0XHRpZiAocGFyYW1ldGVyID4gMC45OTk5OTk2KSB7XG5cdFx0XHR2YXIgbmV4dCA9IGN1cnZlLmdldE5leHQoKTtcblx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdHBhcmFtZXRlciA9IDA7XG5cdFx0XHRcdGN1cnZlID0gbmV4dDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KEN1cnZlTG9jYXRpb24pO1xuXHRcdHRoaXMuX3NldEN1cnZlKGN1cnZlKTtcblx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludCB8fCBjdXJ2ZS5nZXRQb2ludEF0KHBhcmFtZXRlciwgdHJ1ZSk7XG5cdFx0dGhpcy5fb3ZlcmxhcCA9IF9vdmVybGFwO1xuXHRcdHRoaXMuX2Rpc3RhbmNlID0gX2Rpc3RhbmNlO1xuXHRcdHRoaXMuX2ludGVyc2VjdGlvbiA9IHRoaXMuX25leHQgPSB0aGlzLl9wcmV2ID0gbnVsbDtcblx0fSxcblxuXHRfc2V0Q3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHR0aGlzLl92ZXJzaW9uID0gcGF0aCA/IHBhdGguX3ZlcnNpb24gOiAwO1xuXHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0dGhpcy5fc2VnbWVudCA9IG51bGw7XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdH0sXG5cblx0X3NldFNlZ21lbnQ6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHR0aGlzLl9zZXRDdXJ2ZShzZWdtZW50LmdldEN1cnZlKCkpO1xuXHRcdHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdHRoaXMuX3BhcmFtZXRlciA9IHNlZ21lbnQgPT09IHRoaXMuX3NlZ21lbnQxID8gMCA6IDE7XG5cdFx0dGhpcy5fcG9pbnQgPSBzZWdtZW50Ll9wb2ludC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50O1xuXHRcdGlmICghc2VnbWVudCkge1xuXHRcdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRpZiAocGFyYW1ldGVyID09PSAwKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciA9PT0gMSkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgIT0gbnVsbCkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpXG5cdFx0XHRcdFx0PCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHBhcmFtZXRlciwgMSlcblx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gc2VnbWVudDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5fY3VydmUsXG5cdFx0XHRwYXRoID0gY3VydmUgJiYgY3VydmUuX3BhdGgsXG5cdFx0XHR0aGF0ID0gdGhpcztcblx0XHRpZiAocGF0aCAmJiBwYXRoLl92ZXJzaW9uICE9PSB0aGlzLl92ZXJzaW9uKSB7XG5cdFx0XHRjdXJ2ZSA9IHRoaXMuX3BhcmFtZXRlciA9IHRoaXMuX2N1cnZlID0gdGhpcy5fb2Zmc2V0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cnlTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQgJiYgc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXHRcdFx0aWYgKGN1cnZlICYmICh0aGF0Ll9wYXJhbWV0ZXIgPSBjdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGF0Ll9wb2ludCkpXG5cdFx0XHRcdFx0IT0gbnVsbCkge1xuXHRcdFx0XHR0aGF0Ll9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHRoYXQuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdFx0XHRyZXR1cm4gY3VydmU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnZlXG5cdFx0XHR8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQpXG5cdFx0XHR8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQxKVxuXHRcdFx0fHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50Mi5nZXRQcmV2aW91cygpKTtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLl9wYXJhbWV0ZXI7XG5cdFx0cmV0dXJuIGN1cnZlICYmIHBhcmFtZXRlciA9PSBudWxsXG5cdFx0XHQ/IHRoaXMuX3BhcmFtZXRlciA9IGN1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuX3BvaW50KVxuXHRcdFx0OiBwYXJhbWV0ZXI7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cdFx0aWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0dmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKSxcblx0XHRcdFx0aW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cdFx0XHRpZiAocGF0aCAmJiBpbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZXMgPSBwYXRoLmdldEN1cnZlcygpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG5cdFx0XHRcdFx0b2Zmc2V0ICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX29mZnNldCA9IG9mZnNldCArPSB0aGlzLmdldEN1cnZlT2Zmc2V0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0Z2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaXN0YW5jZTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKGN1cnZlKSB7XG5cdFx0XHRyZXMgPSBjdXJ2ZS5kaXZpZGUodGhpcy5nZXRQYXJhbWV0ZXIoKSwgdHJ1ZSk7XG5cdFx0XHRpZiAocmVzKVxuXHRcdFx0XHR0aGlzLl9zZXRTZWdtZW50KHJlcy5fc2VnbWVudDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlID8gY3VydmUuc3BsaXQodGhpcy5nZXRQYXJhbWV0ZXIoKSwgdHJ1ZSkgOiBudWxsO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obG9jLCBfaWdub3JlT3RoZXIpIHtcblx0XHR2YXIgcmVzID0gdGhpcyA9PT0gbG9jLFxuXHRcdFx0ZXBzaWxvbiA9IDJlLTc7XG5cdFx0aWYgKCFyZXMgJiYgbG9jIGluc3RhbmNlb2YgQ3VydmVMb2NhdGlvblxuXHRcdFx0XHQmJiB0aGlzLmdldFBhdGgoKSA9PT0gbG9jLmdldFBhdGgoKVxuXHRcdFx0XHQmJiB0aGlzLmdldFBvaW50KCkuaXNDbG9zZShsb2MuZ2V0UG9pbnQoKSwgZXBzaWxvbikpIHtcblx0XHRcdHZhciBjMSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0YzIgPSBsb2MuZ2V0Q3VydmUoKSxcblx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdGRpZmYgPSBhYnMoXG5cdFx0XHRcdFx0KChjMS5pc0xhc3QoKSAmJiBjMi5pc0ZpcnN0KCkgPyAtMSA6IGMxLmdldEluZGV4KCkpXG5cdFx0XHRcdFx0XHRcdCsgdGhpcy5nZXRQYXJhbWV0ZXIoKSkgLVxuXHRcdFx0XHRcdCgoYzIuaXNMYXN0KCkgJiYgYzEuaXNGaXJzdCgpID8gLTEgOiBjMi5nZXRJbmRleCgpKVxuXHRcdFx0XHRcdFx0XHQrIGxvYy5nZXRQYXJhbWV0ZXIoKSkpO1xuXHRcdFx0cmVzID0gKGRpZmYgPCA0ZS03XG5cdFx0XHRcdHx8ICgoZGlmZiA9IGFicyh0aGlzLmdldE9mZnNldCgpIC0gbG9jLmdldE9mZnNldCgpKSkgPCBlcHNpbG9uXG5cdFx0XHRcdFx0fHwgYWJzKHRoaXMuZ2V0UGF0aCgpLmdldExlbmd0aCgpIC0gZGlmZikgPCBlcHNpbG9uKSlcblx0XHRcdFx0JiYgKF9pZ25vcmVPdGhlclxuXHRcdFx0XHRcdHx8ICghdGhpcy5faW50ZXJzZWN0aW9uICYmICFsb2MuX2ludGVyc2VjdGlvblxuXHRcdFx0XHRcdFx0fHwgdGhpcy5faW50ZXJzZWN0aW9uICYmIHRoaXMuX2ludGVyc2VjdGlvbi5lcXVhbHMoXG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9pbnRlcnNlY3Rpb24sIHRydWUpKSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdGlmIChwYXJhbWV0ZXIgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3BhcmFtZXRlcjogJyArIGYubnVtYmVyKHBhcmFtZXRlcikpO1xuXHRcdGlmICh0aGlzLl9kaXN0YW5jZSAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnZGlzdGFuY2U6ICcgKyBmLm51bWJlcih0aGlzLl9kaXN0YW5jZSkpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0aXNUb3VjaGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGludGVyID0gdGhpcy5faW50ZXJzZWN0aW9uO1xuXHRcdGlmIChpbnRlciAmJiB0aGlzLmdldFRhbmdlbnQoKS5pc0NvbGxpbmVhcihpbnRlci5nZXRUYW5nZW50KCkpKSB7XG5cdFx0XHR2YXIgY3VydmUxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRjdXJ2ZTIgPSBpbnRlci5nZXRDdXJ2ZSgpO1xuXHRcdFx0cmV0dXJuICEoY3VydmUxLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZTIuaXNTdHJhaWdodCgpXG5cdFx0XHRcdFx0JiYgY3VydmUxLmdldExpbmUoKS5pbnRlcnNlY3QoY3VydmUyLmdldExpbmUoKSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNDcm9zc2luZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGludGVyID0gdGhpcy5faW50ZXJzZWN0aW9uO1xuXHRcdGlmICghaW50ZXIpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHQxID0gdGhpcy5nZXRQYXJhbWV0ZXIoKSxcblx0XHRcdHQyID0gaW50ZXIuZ2V0UGFyYW1ldGVyKCksXG5cdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAodDEgPj0gdE1pbiAmJiB0MSA8PSB0TWF4IHx8IHQyID49IHRNaW4gJiYgdDIgPD0gdE1heClcblx0XHRcdHJldHVybiAhdGhpcy5pc1RvdWNoaW5nKCk7XG5cdFx0dmFyIGMyID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0YzEgPSBjMi5nZXRQcmV2aW91cygpLFxuXHRcdFx0YzQgPSBpbnRlci5nZXRDdXJ2ZSgpLFxuXHRcdFx0YzMgPSBjNC5nZXRQcmV2aW91cygpLFxuXHRcdFx0UEkgPSBNYXRoLlBJO1xuXHRcdGlmICghYzEgfHwgIWMzKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gaXNJblJhbmdlKGFuZ2xlLCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIG1pbiA8IG1heFxuXHRcdFx0XHQ/IGFuZ2xlID4gbWluICYmIGFuZ2xlIDwgbWF4XG5cdFx0XHRcdDogYW5nbGUgPiBtaW4gJiYgYW5nbGUgPD0gUEkgfHwgYW5nbGUgPj0gLVBJICYmIGFuZ2xlIDwgbWF4O1xuXHRcdH1cblxuXHRcdHZhciBhMSA9IGMxLmdldFRhbmdlbnRBdCh0TWF4LCB0cnVlKS5uZWdhdGUoKS5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0YTIgPSBjMi5nZXRUYW5nZW50QXQodE1pbiwgdHJ1ZSkuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEzID0gYzMuZ2V0VGFuZ2VudEF0KHRNYXgsIHRydWUpLm5lZ2F0ZSgpLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhNCA9IGM0LmdldFRhbmdlbnRBdCh0TWluLCB0cnVlKS5nZXRBbmdsZUluUmFkaWFucygpO1xuXG5cdFx0cmV0dXJuIChpc0luUmFuZ2UoYTMsIGExLCBhMikgXiBpc0luUmFuZ2UoYTQsIGExLCBhMikpXG5cdFx0XHQmJiAoaXNJblJhbmdlKGEzLCBhMiwgYTEpIF4gaXNJblJhbmdlKGE0LCBhMiwgYTEpKTtcblx0fSxcblxuXHRpc092ZXJsYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX292ZXJsYXA7XG5cdH1cbn0sIEJhc2UuZWFjaChDdXJ2ZS5ldmFsdWF0ZU1ldGhvZHMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIGdldCA9IG5hbWUgKyAnQXQnO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCksXG5cdFx0XHRjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmVbZ2V0XShwYXJhbWV0ZXIsIHRydWUpO1xuXHR9O1xufSwge1xuXHRwcmVzZXJ2ZTogdHJ1ZVxufSksXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gaW5zZXJ0KGxvY2F0aW9ucywgbG9jLCBtZXJnZSkge1xuXHRcdHZhciBsZW5ndGggPSBsb2NhdGlvbnMubGVuZ3RoLFxuXHRcdFx0bCA9IDAsXG5cdFx0XHRyID0gbGVuZ3RoIC0gMTtcblxuXHRcdGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgZGlyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBkaXI7IGkgPj0gLTEgJiYgaSA8PSBsZW5ndGg7IGkgKz0gZGlyKSB7XG5cdFx0XHRcdHZhciBsb2MyID0gbG9jYXRpb25zWygoaSAlIGxlbmd0aCkgKyBsZW5ndGgpICUgbGVuZ3RoXTtcblx0XHRcdFx0aWYgKCFsb2MuZ2V0UG9pbnQoKS5pc0Nsb3NlKGxvYzIuZ2V0UG9pbnQoKSxcblx0XHRcdFx0XHRcdDJlLTcpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRpZiAobG9jLmVxdWFscyhsb2MyKSlcblx0XHRcdFx0XHRyZXR1cm4gbG9jMjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHdoaWxlIChsIDw9IHIpIHtcblx0XHRcdHZhciBtID0gKGwgKyByKSA+Pj4gMSxcblx0XHRcdFx0bG9jMiA9IGxvY2F0aW9uc1ttXSxcblx0XHRcdFx0Zm91bmQ7XG5cdFx0XHRpZiAobWVyZ2UgJiYgKGZvdW5kID0gbG9jLmVxdWFscyhsb2MyKSA/IGxvYzJcblx0XHRcdFx0XHQ6IChzZWFyY2gobSwgLTEpIHx8IHNlYXJjaChtLCAxKSkpKSB7XG5cdFx0XHRcdGlmIChsb2MuX292ZXJsYXApIHtcblx0XHRcdFx0XHRmb3VuZC5fb3ZlcmxhcCA9IGZvdW5kLl9pbnRlcnNlY3Rpb24uX292ZXJsYXAgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmb3VuZDtcblx0XHRcdH1cblx0XHR2YXIgcGF0aDEgPSBsb2MuZ2V0UGF0aCgpLFxuXHRcdFx0cGF0aDIgPSBsb2MyLmdldFBhdGgoKSxcblx0XHRcdGRpZmYgPSBwYXRoMSA9PT0gcGF0aDJcblx0XHRcdFx0PyAobG9jLmdldEluZGV4KCkgKyBsb2MuZ2V0UGFyYW1ldGVyKCkpXG5cdFx0XHRcdC0gKGxvYzIuZ2V0SW5kZXgoKSArIGxvYzIuZ2V0UGFyYW1ldGVyKCkpXG5cdFx0XHRcdDogcGF0aDEuX2lkIC0gcGF0aDIuX2lkO1xuXHRcdFx0aWYgKGRpZmYgPCAwKSB7XG5cdFx0XHRcdHIgPSBtIC0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGwgPSBtICsgMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9jYXRpb25zLnNwbGljZShsLCAwLCBsb2MpO1xuXHRcdHJldHVybiBsb2M7XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cdFx0aW5zZXJ0OiBpbnNlcnQsXG5cblx0XHRleHBhbmQ6IGZ1bmN0aW9uKGxvY2F0aW9ucykge1xuXHRcdFx0dmFyIGV4cGFuZGVkID0gbG9jYXRpb25zLnNsaWNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxvY2F0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW5zZXJ0KGV4cGFuZGVkLCBsb2NhdGlvbnNbaV0uX2ludGVyc2VjdGlvbiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fX07XG59KTtcblxudmFyIFBhdGhJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoSXRlbScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aEl0ZW0oKSB7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocGF0aCwgaW5jbHVkZSwgX21hdHJpeCwgX3JldHVybkZpcnN0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzID09PSBwYXRoIHx8ICFwYXRoLFxuXHRcdFx0bWF0cml4MSA9IHRoaXMuX21hdHJpeC5vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRtYXRyaXgyID0gc2VsZiA/IG1hdHJpeDFcblx0XHRcdFx0OiAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLm9yTnVsbElmSWRlbnRpdHkoKTtcblx0XHRpZiAoIXNlbGYgJiYgIXRoaXMuZ2V0Qm91bmRzKG1hdHJpeDEpLnRvdWNoZXMocGF0aC5nZXRCb3VuZHMobWF0cml4MikpKVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdHZhciBjdXJ2ZXMxID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGN1cnZlczIgPSBzZWxmID8gY3VydmVzMSA6IHBhdGguZ2V0Q3VydmVzKCksXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gc2VsZiA/IGxlbmd0aDEgOiBjdXJ2ZXMyLmxlbmd0aCxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdGFycmF5cyA9IFtdLFxuXHRcdFx0bG9jYXRpb25zLFxuXHRcdFx0cGF0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKylcblx0XHRcdHZhbHVlczJbaV0gPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcyhtYXRyaXgyKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlMSA9IGN1cnZlczFbaV0sXG5cdFx0XHRcdHZhbHVlczEgPSBzZWxmID8gdmFsdWVzMltpXSA6IGN1cnZlMS5nZXRWYWx1ZXMobWF0cml4MSksXG5cdFx0XHRcdHBhdGgxID0gY3VydmUxLmdldFBhdGgoKTtcblx0XHRcdGlmIChwYXRoMSAhPT0gcGF0aCkge1xuXHRcdFx0XHRwYXRoID0gcGF0aDE7XG5cdFx0XHRcdGxvY2F0aW9ucyA9IFtdO1xuXHRcdFx0XHRhcnJheXMucHVzaChsb2NhdGlvbnMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNlbGYpIHtcblx0XHRcdFx0Q3VydmUuX2dldFNlbGZJbnRlcnNlY3Rpb24odmFsdWVzMSwgY3VydmUxLCBsb2NhdGlvbnMsIHtcblx0XHRcdFx0XHRpbmNsdWRlOiBpbmNsdWRlLFxuXHRcdFx0XHRcdHN0YXJ0Q29ubmVjdGVkOiBsZW5ndGgxID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGN1cnZlMS5nZXRQb2ludDEoKS5lcXVhbHMoY3VydmUxLmdldFBvaW50MigpKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGogPSBzZWxmID8gaSArIDEgOiAwOyBqIDwgbGVuZ3RoMjsgaisrKSB7XG5cdFx0XHRcdGlmIChfcmV0dXJuRmlyc3QgJiYgbG9jYXRpb25zLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0XHR2YXIgY3VydmUyID0gY3VydmVzMltqXTtcblx0XHRcdFx0Q3VydmUuX2dldEludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0dmFsdWVzMSwgdmFsdWVzMltqXSwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpbmNsdWRlOiBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0c3RhcnRDb25uZWN0ZWQ6IHNlbGYgJiYgY3VydmUxLmdldFByZXZpb3VzKCkgPT09IGN1cnZlMixcblx0XHRcdFx0XHRcdGVuZENvbm5lY3RlZDogc2VsZiAmJiBjdXJ2ZTEuZ2V0TmV4dCgpID09PSBjdXJ2ZTJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxvY2F0aW9ucyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bG9jYXRpb25zLnB1c2guYXBwbHkobG9jYXRpb25zLCBhcnJheXNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9LFxuXG5cdGdldENyb3NzaW5nczogZnVuY3Rpb24ocGF0aCkge1xuXHRcdHJldHVybiB0aGlzLmdldEludGVyc2VjdGlvbnMocGF0aCwgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdHJldHVybiBpbnRlci5pc0Nyb3NzaW5nKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldFBhdGhEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cblx0XHR2YXIgcGFydHMgPSBkYXRhLm1hdGNoKC9bbWxodmNzcXRhel1bXm1saHZjc3F0YXpdKi9pZyksXG5cdFx0XHRjb29yZHMsXG5cdFx0XHRyZWxhdGl2ZSA9IGZhbHNlLFxuXHRcdFx0cHJldmlvdXMsXG5cdFx0XHRjb250cm9sLFxuXHRcdFx0Y3VycmVudCA9IG5ldyBQb2ludCgpLFxuXHRcdFx0c3RhcnQgPSBuZXcgUG9pbnQoKTtcblxuXHRcdGZ1bmN0aW9uIGdldENvb3JkKGluZGV4LCBjb29yZCkge1xuXHRcdFx0dmFyIHZhbCA9ICtjb29yZHNbaW5kZXhdO1xuXHRcdFx0aWYgKHJlbGF0aXZlKVxuXHRcdFx0XHR2YWwgKz0gY3VycmVudFtjb29yZF07XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBvaW50KGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCwgJ3gnKSxcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXggKyAxLCAneScpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xlYXIoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMgJiYgcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHBhcnRzW2ldLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydFswXSxcblx0XHRcdFx0bG93ZXIgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjb29yZHMgPSBwYXJ0Lm1hdGNoKC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKTtcblx0XHRcdHZhciBsZW5ndGggPSBjb29yZHMgJiYgY29vcmRzLmxlbmd0aDtcblx0XHRcdHJlbGF0aXZlID0gY29tbWFuZCA9PT0gbG93ZXI7XG5cdFx0XHRpZiAocHJldmlvdXMgPT09ICd6JyAmJiAhL1ttel0vLnRlc3QobG93ZXIpKVxuXHRcdFx0XHR0aGlzLm1vdmVUbyhjdXJyZW50ID0gc3RhcnQpO1xuXHRcdFx0c3dpdGNoIChsb3dlcikge1xuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0dmFyIG1vdmUgPSBsb3dlciA9PT0gJ20nO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKVxuXHRcdFx0XHRcdHRoaXNbaiA9PT0gMCAmJiBtb3ZlID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cdFx0XHRcdGNvbnRyb2wgPSBjdXJyZW50O1xuXHRcdFx0XHRpZiAobW92ZSlcblx0XHRcdFx0XHRzdGFydCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0dmFyIGNvb3JkID0gbG93ZXIgPT09ICdoJyA/ICd4JyA6ICd5Jztcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGN1cnJlbnRbY29vcmRdID0gZ2V0Q29vcmQoaiwgY29vcmQpO1xuXHRcdFx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRyb2wgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA2KSB7XG5cdFx0XHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiArIDIpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG5cdFx0XHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdC9bY3NdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3EnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSAoL1txdF0vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA3KSB7XG5cdFx0XHRcdFx0dGhpcy5hcmNUbyhjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDUpLFxuXHRcdFx0XHRcdFx0XHRuZXcgU2l6ZSgrY29vcmRzW2pdLCArY29vcmRzW2ogKyAxXSksXG5cdFx0XHRcdFx0XHRcdCtjb29yZHNbaiArIDJdLCArY29vcmRzW2ogKyA0XSwgK2Nvb3Jkc1tqICsgM10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdHRoaXMuY2xvc2VQYXRoKHRydWUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgd2luZGluZyA9IHRoaXMuX2dldFdpbmRpbmcocG9pbnQsIGZhbHNlLCB0cnVlKTtcblx0XHRyZXR1cm4gISEodGhpcy5nZXRXaW5kaW5nUnVsZSgpID09PSAnZXZlbm9kZCcgPyB3aW5kaW5nICYgMSA6IHdpbmRpbmcpO1xuXHR9XG5cbn0pO1xuXG52YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c2VnbWVudHM6IFtdLFxuXHRcdGNsb3NlZDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NlZ21lbnRzID0gW107XG5cdFx0dGhpcy5fdmVyc2lvbiA9IDA7XG5cdFx0dmFyIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG5cdFx0XHQ/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG5cdFx0XHRcdD8gYXJnXG5cdFx0XHRcdDogYXJndW1lbnRzXG5cdFx0XHQ6IGFyZyAmJiAoYXJnLnNpemUgPT09IHVuZGVmaW5lZCAmJiAoYXJnLnggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdHx8IGFyZy5wb2ludCAhPT0gdW5kZWZpbmVkKSlcblx0XHRcdFx0PyBhcmd1bWVudHNcblx0XHRcdFx0OiBudWxsO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSAwO1xuXHRcdFx0aWYgKCFzZWdtZW50cyAmJiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHRcdGFyZyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2luaXRpYWxpemUoIXNlZ21lbnRzICYmIGFyZyk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWQgPT09IGl0ZW0uX2Nsb3NlZFxuXHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9zZWdtZW50cywgaXRlbS5fc2VnbWVudHMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFNlZ21lbnRzKHRoaXMuX3NlZ21lbnRzKTtcblx0XHRjb3B5Ll9jbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0Y29weS5fY2xvY2t3aXNlID0gdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdGlmIChwYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY3VycmVudFBhdGggPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9hcmVhID0gdGhpcy5fY2xvY2t3aXNlID0gdGhpcy5fbW9ub0N1cnZlcyA9XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0aWYgKGZsYWdzICYgMTYpIHtcblx0XHRcdFx0dGhpcy5fdmVyc2lvbisrO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdCAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZsYWdzICYgMzIpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0cmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG5cdH0sXG5cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cztcblx0fSxcblxuXHRzZXRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHR2YXIgZnVsbHlTZWxlY3RlZCA9IHRoaXMuaXNGdWxseVNlbGVjdGVkKCk7XG5cdFx0dGhpcy5fc2VnbWVudHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKVxuXHRcdFx0dGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cykpO1xuXHRcdGlmIChmdWxseVNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzWzBdO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbdGhpcy5fc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRpZiAoIWN1cnZlcykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRcdGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSxcblx0XHRcdFx0XHRzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnZlcygpWzBdO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0cmV0dXJuIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0aXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdH0sXG5cblx0c2V0Q2xvc2VkOiBmdW5jdGlvbihjbG9zZWQpIHtcblx0XHRpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2N1cnZlcy5sZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tsZW5ndGggLSAxXSA9IG5ldyBDdXJ2ZSh0aGlzLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHNbbGVuZ3RoIC0gMV0sIHRoaXMuX3NlZ21lbnRzWzBdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdH1cblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0ZiA9IG5ldyBGb3JtYXR0ZXIoX3ByZWNpc2lvbiksXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZLFxuXHRcdFx0cGFydHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCwgc2tpcExpbmUpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKF9tYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Y3VyWCA9IGNvb3Jkc1swXTtcblx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0cGFydHMucHVzaCgnTScgKyBmLnBhaXIoY3VyWCwgY3VyWSkpO1xuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRpblkgPSBjb29yZHNbM107XG5cdFx0XHRcdGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG5cdFx0XHRcdFx0XHQmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuXHRcdFx0XHRcdGlmICghc2tpcExpbmUpXG5cdFx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdsJyArIGYucGFpcihjdXJYIC0gcHJldlgsIGN1clkgLSBwcmV2WSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ2MnICsgZi5wYWlyKG91dFggLSBwcmV2WCwgb3V0WSAtIHByZXZZKVxuXHRcdFx0XHRcdFx0XHQrICcgJyArIGYucGFpcihpblggLSBwcmV2WCwgaW5ZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdH1cblxuXHRcdGlmIChsZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm4gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSB7XG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzWzBdLCB0cnVlKTtcblx0XHRcdHBhcnRzLnB1c2goJ3onKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuXHR9XG59LCB7XG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FkZDogZnVuY3Rpb24oc2VncywgaW5kZXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGFtb3VudCA9IHNlZ3MubGVuZ3RoLFxuXHRcdFx0YXBwZW5kID0gaW5kZXggPT0gbnVsbCxcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gc2VnbWVudHMubGVuZ3RoIDogaW5kZXg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3BhdGgpXG5cdFx0XHRcdHNlZ21lbnQgPSBzZWdzW2ldID0gc2VnbWVudC5jbG9uZSgpO1xuXHRcdFx0c2VnbWVudC5fcGF0aCA9IHRoaXM7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIDAsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgc2Vncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlZ21lbnRzLnNwbGljZS5hcHBseShzZWdtZW50cywgW2luZGV4LCAwXS5jb25jYXQoc2VncykpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdH1cblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgdG90YWwgPSB0aGlzLl9jb3VudEN1cnZlcygpLFxuXHRcdFx0XHRmcm9tID0gaW5kZXggKyBhbW91bnQgLSAxID09PSB0b3RhbCA/IGluZGV4IC0gMSA6IGluZGV4LFxuXHRcdFx0XHRzdGFydCA9IGZyb20sXG5cdFx0XHRcdHRvID0gTWF0aC5taW4oZnJvbSArIGFtb3VudCwgdG90YWwpO1xuXHRcdFx0aWYgKHNlZ3MuX2N1cnZlcykge1xuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlLmFwcGx5KGN1cnZlcywgW2Zyb20sIDBdLmNvbmNhdChzZWdzLl9jdXJ2ZXMpKTtcblx0XHRcdFx0c3RhcnQgKz0gc2Vncy5fY3VydmVzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHRvOyBpKyspXG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UoaSwgMCwgbmV3IEN1cnZlKHRoaXMsIG51bGwsIG51bGwpKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhmcm9tLCB0byk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cdF9hZGp1c3RDdXJ2ZXM6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjdXJ2ZTtcblx0XHRmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcblx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0Y3VydmUuX3BhdGggPSB0aGlzO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbaV07XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmIGZyb20gPT09IDAgPyBzZWdtZW50cy5sZW5ndGggLSAxXG5cdFx0XHRcdDogZnJvbSAtIDFdKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tmcm9tXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0b10pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW3RvXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jb3VudEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIC0gMSA6IGxlbmd0aDtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0OiBmdW5jdGlvbihpbmRleCwgc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMsIDEpLCBpbmRleClcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50OiBmdW5jdGlvbihpbmRleCApIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudHM6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSwgaW5kZXgpO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIGluZGV4ICsgMSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50czogZnVuY3Rpb24oZnJvbSwgdG8sIF9pbmNsdWRlQ3VydmVzKSB7XG5cdFx0ZnJvbSA9IGZyb20gfHwgMDtcblx0XHR0byA9IEJhc2UucGljayh0bywgdGhpcy5fc2VnbWVudHMubGVuZ3RoKTtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShmcm9tLCB0byAtIGZyb20pLFxuXHRcdFx0YW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG5cdFx0aWYgKCFhbW91bnQpXG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSwgMCk7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IHNlZ21lbnQuX3BhdGggPSBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gZnJvbSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIGluZGV4ID0gZnJvbSA+IDAgJiYgdG8gPT09IGNvdW50ICsgKHRoaXMuX2Nsb3NlZCA/IDEgOiAwKVxuXHRcdFx0XHRcdD8gZnJvbSAtIDFcblx0XHRcdFx0XHQ6IGZyb20sXG5cdFx0XHRcdGN1cnZlcyA9IGN1cnZlcy5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG5cdFx0XHRpZiAoX2luY2x1ZGVDdXJ2ZXMpXG5cdFx0XHRcdHJlbW92ZWQuX2N1cnZlcyA9IGN1cnZlcy5zbGljZSgxKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhpbmRleCwgaW5kZXgpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVTZWdtZW50cycsXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChzZWdtZW50c1tpXS5oYXNIYW5kbGVzKCkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Y2xlYXJIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLmNsZWFySGFuZGxlcygpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0bGVuZ3RoICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fYXJlYSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0Y291bnQgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRcdGxhc3QgPSBjb3VudCAtIDEsXG5cdFx0XHRcdGFyZWEgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jbG9zZWQgPyBjb3VudCA6IGxhc3Q7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0YXJlYSArPSBDdXJ2ZS5nZXRBcmVhKEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRcdHNlZ21lbnRzW2ldLCBzZWdtZW50c1tpIDwgbGFzdCA/IGkgKyAxIDogMF0pKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FyZWEgPSBhcmVhO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fYXJlYTtcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2Nsb2Nrd2lzZTtcblx0XHRyZXR1cm4gdGhpcy5nZXRBcmVhKCkgPj0gMDtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT0gKGNsb2Nrd2lzZSA9ICEhY2xvY2t3aXNlKSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHRcdHRoaXMuX2Nsb2Nrd2lzZSA9IGNsb2Nrd2lzZTtcblx0fSxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkICYmIGxlbmd0aCA+IDAgJiYgdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGVcblx0XHRcdFx0PT09IGxlbmd0aCAqIDc7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyh0cnVlKTtcblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24gc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpIHtcblx0XHRpZiAoIXNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHMoZmFsc2UpO1xuXHRcdHNldFNlbGVjdGVkLmJhc2UuY2FsbCh0aGlzLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0X3NlbGVjdFNlZ21lbnRzOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSBzZWxlY3RlZFxuXHRcdFx0XHQ/IGxlbmd0aCAqIDcgOiAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHR0aGlzLl9zZWdtZW50c1tpXS5fc2VsZWN0aW9uU3RhdGUgPSBzZWxlY3RlZFxuXHRcdFx0XHRcdD8gNyA6IDA7XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oc2VnbWVudCwgb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG5cdFx0c2VnbWVudC5fc2VsZWN0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcblx0XHR2YXIgdG90YWwgPSB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSArPSBuZXdTdGF0ZSAtIG9sZFN0YXRlO1xuXHRcdGlmICh0b3RhbCA+IDApXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGZsYXR0ZW46IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG5cdFx0dmFyIGl0ZXJhdG9yID0gbmV3IFBhdGhJdGVyYXRvcih0aGlzLCA2NCwgMC4xKSxcblx0XHRcdHBvcyA9IDAsXG5cdFx0XHRzdGVwID0gaXRlcmF0b3IubGVuZ3RoIC8gTWF0aC5jZWlsKGl0ZXJhdG9yLmxlbmd0aCAvIG1heERpc3RhbmNlKSxcblx0XHRcdGVuZCA9IGl0ZXJhdG9yLmxlbmd0aCArICh0aGlzLl9jbG9zZWQgPyAtc3RlcCA6IHN0ZXApIC8gMjtcblx0XHR2YXIgc2VnbWVudHMgPSBbXTtcblx0XHR3aGlsZSAocG9zIDw9IGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChpdGVyYXRvci5nZXRQb2ludEF0KHBvcykpKTtcblx0XHRcdHBvcyArPSBzdGVwO1xuXHRcdH1cblx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGlmICghY3VydmUuaGFzSGFuZGxlcygpICYmIChjdXJ2ZS5nZXRMZW5ndGgoKSA9PT0gMFxuXHRcdFx0XHRcdHx8IGN1cnZlLmlzQ29sbGluZWFyKGN1cnZlLmdldE5leHQoKSkpKVxuXHRcdFx0XHRjdXJ2ZS5yZW1vdmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2ltcGxpZnk6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdGlmICh0aGlzLl9zZWdtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0XHR2YXIgZml0dGVyID0gbmV3IFBhdGhGaXR0ZXIodGhpcywgdG9sZXJhbmNlIHx8IDIuNSk7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKGZpdHRlci5maXQoKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbihpbmRleCwgcGFyYW1ldGVyKSB7XG5cdFx0aWYgKHBhcmFtZXRlciA9PT0gbnVsbClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgYXJnID0gaW5kZXg7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpXG5cdFx0XHRcdGFyZyA9IHRoaXMuZ2V0TG9jYXRpb25BdChhcmcpO1xuXHRcdFx0aWYgKCFhcmcpXG5cdFx0XHRcdHJldHVybiBudWxsXG5cdFx0XHRpbmRleCA9IGFyZy5pbmRleDtcblx0XHRcdHBhcmFtZXRlciA9IGFyZy5wYXJhbWV0ZXI7XG5cdFx0fVxuXHRcdHZhciB0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAocGFyYW1ldGVyID49IHRNYXgpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHRwYXJhbWV0ZXItLTtcblx0XHR9XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0aWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBjdXJ2ZXMubGVuZ3RoKSB7XG5cdFx0XHRpZiAocGFyYW1ldGVyID49IHRNaW4pIHtcblx0XHRcdFx0Y3VydmVzW2luZGV4KytdLmRpdmlkZShwYXJhbWV0ZXIsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNlZ3MgPSB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCB0aGlzLl9zZWdtZW50cy5sZW5ndGgsIHRydWUpLFxuXHRcdFx0XHRwYXRoO1xuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHR0aGlzLnNldENsb3NlZChmYWxzZSk7XG5cdFx0XHRcdHBhdGggPSB0aGlzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0dGhpcy5fY2xvbmUocGF0aCk7XG5cdFx0XHR9XG5cdFx0XHRwYXRoLl9hZGQoc2VncywgMCk7XG5cdFx0XHR0aGlzLmFkZFNlZ21lbnQoc2Vnc1swXSk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dCA9IGhhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHRoaXMuX2Nsb2Nrd2lzZSA9ICF0aGlzLl9jbG9ja3dpc2U7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRqb2luOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0XHRsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAoIWxhc3QyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpXG5cdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0dmFyIGZpcnN0MiA9IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSkge1xuXHRcdFx0XHRsYXN0MS5zZXRIYW5kbGVPdXQoZmlyc3QyLl9oYW5kbGVPdXQpO1xuXHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGZpcnN0MSA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpXG5cdFx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0XHRmaXJzdDEuc2V0SGFuZGxlSW4obGFzdDIuX2hhbmRsZUluKTtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSksIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdFx0dGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuXHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcblx0XHRcdGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cdFx0aWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5lcXVhbHMobGFzdC5fcG9pbnQpKSB7XG5cdFx0XHRmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG5cdFx0XHRsYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvU2hhcGU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdGlmICghdGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0dG9wQ2VudGVyO1xuXG5cdFx0ZnVuY3Rpb24gaXNDb2xsaW5lYXIoaSwgaikge1xuXHRcdFx0dmFyIHNlZzEgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VnMiA9IHNlZzEuZ2V0TmV4dCgpLFxuXHRcdFx0XHRzZWczID0gc2VnbWVudHNbal0sXG5cdFx0XHRcdHNlZzQgPSBzZWczLmdldE5leHQoKTtcblx0XHRcdHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWczLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnNC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNDb2xsaW5lYXIoXG5cdFx0XHRcdFx0XHRzZWc0Ll9wb2ludC5zdWJ0cmFjdChzZWczLl9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzT3J0aG9nb25hbChpKSB7XG5cdFx0XHR2YXIgc2VnMiA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcxID0gc2VnMi5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRzZWczID0gc2VnMi5nZXROZXh0KCk7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzT3J0aG9nb25hbChcblx0XHRcdFx0XHRcdHNlZzMuX3BvaW50LnN1YnRyYWN0KHNlZzIuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNBcmMoaSkge1xuXHRcdFx0dmFyIHNlZzEgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VnMiA9IHNlZzEuZ2V0TmV4dCgpLFxuXHRcdFx0XHRoYW5kbGUxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRoYW5kbGUyID0gc2VnMi5faGFuZGxlSW4sXG5cdFx0XHRcdGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2O1xuXHRcdFx0aWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG5cdFx0XHRcdHZhciBwdDEgPSBzZWcxLl9wb2ludCxcblx0XHRcdFx0XHRwdDIgPSBzZWcyLl9wb2ludCxcblx0XHRcdFx0XHRjb3JuZXIgPSBuZXcgTGluZShwdDEsIGhhbmRsZTEsIHRydWUpLmludGVyc2VjdChcblx0XHRcdFx0XHRcdFx0bmV3IExpbmUocHQyLCBoYW5kbGUyLCB0cnVlKSwgdHJ1ZSk7XG5cdFx0XHRcdHJldHVybiBjb3JuZXIgJiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUxLmdldExlbmd0aCgpIC9cblx0XHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChwdDEpLmdldExlbmd0aCgpIC0ga2FwcGEpXG5cdFx0XHRcdFx0JiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUyLmdldExlbmd0aCgpIC9cblx0XHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChwdDIpLmdldExlbmd0aCgpIC0ga2FwcGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERpc3RhbmNlKGksIGopIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5fcG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudHNbal0uX3BvaW50KTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzSGFuZGxlcygpICYmIHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0NvbGxpbmVhcigwLCAyKSAmJiBpc0NvbGxpbmVhcigxLCAzKSAmJiBpc09ydGhvZ29uYWwoMSkpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgMyksIGdldERpc3RhbmNlKDAsIDEpKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludC5hZGQoc2VnbWVudHNbMl0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDggJiYgaXNBcmMoMCkgJiYgaXNBcmMoMikgJiYgaXNBcmMoNClcblx0XHRcdFx0JiYgaXNBcmMoNikgJiYgaXNDb2xsaW5lYXIoMSwgNSkgJiYgaXNDb2xsaW5lYXIoMywgNykpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMSwgNiksIGdldERpc3RhbmNlKDAsIDMpKTtcblx0XHRcdHJhZGl1cyA9IHNpemUuc3VidHJhY3QobmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgNyksXG5cdFx0XHRcdFx0Z2V0RGlzdGFuY2UoMSwgMikpKS5kaXZpZGUoMik7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1szXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzRdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQXJjKDApICYmIGlzQXJjKDEpICYmIGlzQXJjKDIpICYmIGlzQXJjKDMpKSB7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhnZXREaXN0YW5jZSgwLCAyKSAtIGdldERpc3RhbmNlKDEsIDMpKSkge1xuXHRcdFx0XHR0eXBlID0gU2hhcGUuQ2lyY2xlO1xuXHRcdFx0XHRyYWRpdXMgPSBnZXREaXN0YW5jZSgwLCAyKSAvIDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gU2hhcGUuRWxsaXBzZTtcblx0XHRcdFx0cmFkaXVzID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMiwgMCkgLyAyLCBnZXREaXN0YW5jZSgzLCAxKSAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50O1xuXHRcdH1cblxuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcblx0XHRcdFx0c2hhcGUgPSB0aGlzLl9jbG9uZShuZXcgdHlwZSh7XG5cdFx0XHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdH0pLCBpbnNlcnQsIGZhbHNlKTtcblx0XHRcdHNoYXBlLnJvdGF0ZSh0b3BDZW50ZXIuc3VidHJhY3QoY2VudGVyKS5nZXRBbmdsZSgpICsgOTApO1xuXHRcdFx0cmV0dXJuIHNoYXBlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0am9pbiwgY2FwLCBtaXRlckxpbWl0LFxuXHRcdFx0YXJlYSwgbG9jLCByZXMsXG5cdFx0XHRoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGl0Q3VydmVzID0gb3B0aW9ucy5jdXJ2ZXMsXG5cdFx0XHRyYWRpdXMgPSBoaXRTdHJva2Vcblx0XHRcdFx0XHQ/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyXG5cdFx0XHRcdFx0OiBoaXRGaWxsICYmIG9wdGlvbnMudG9sZXJhbmNlID4gMCB8fCBoaXRDdXJ2ZXNcblx0XHRcdFx0XHRcdD8gMCA6IG51bGw7XG5cdFx0aWYgKHJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKHJhZGl1cyA+IDApIHtcblx0XHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKTtcblx0XHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCk7XG5cdFx0XHRcdG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLmFkZChuZXcgUG9pbnQocmFkaXVzLCByYWRpdXMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpvaW4gPSBjYXAgPSAncm91bmQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcblx0XHRcdHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50KHNlZywgcHQsIG5hbWUpIHtcblx0XHRcdGlmICghb3B0aW9ucy5zZWxlY3RlZCB8fCBwdC5pc1NlbGVjdGVkKCkpIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHNlZy5fcG9pbnQ7XG5cdFx0XHRcdGlmIChwdCAhPT0gYW5jaG9yKVxuXHRcdFx0XHRcdHB0ID0gcHQuYWRkKGFuY2hvcik7XG5cdFx0XHRcdGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KG5hbWUsIHRoYXQsIHtcblx0XHRcdFx0XHRcdHNlZ21lbnQ6IHNlZyxcblx0XHRcdFx0XHRcdHBvaW50OiBwdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuXHRcdFx0cmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpXG5cdFx0XHRcdCYmIGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9wb2ludCwgJ3NlZ21lbnQnKVxuXHRcdFx0XHR8fCAoIWVuZHMgJiYgb3B0aW9ucy5oYW5kbGVzKSAmJiAoXG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZUluLCAnaGFuZGxlLWluJykgfHxcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRUb0FyZWEocG9pbnQpIHtcblx0XHRcdGFyZWEuYWRkKHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkge1xuXHRcdFx0aWYgKGpvaW4gIT09ICdyb3VuZCcgfHwgY2FwICE9PSAncm91bmQnKSB7XG5cdFx0XHRcdGFyZWEgPSBuZXcgUGF0aCh7IGludGVybmFsOiB0cnVlLCBjbG9zZWQ6IHRydWUgfSk7XG5cdFx0XHRcdGlmIChjbG9zZWQgfHwgc2VnbWVudC5faW5kZXggPiAwXG5cdFx0XHRcdFx0XHQmJiBzZWdtZW50Ll9pbmRleCA8IG51bVNlZ21lbnRzIC0gMSkge1xuXHRcdFx0XHRcdGlmIChqb2luICE9PSAncm91bmQnICYmIChzZWdtZW50Ll9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdFx0XHR8fCBzZWdtZW50Ll9oYW5kbGVPdXQuaXNaZXJvKCkpKVxuXHRcdFx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCxcblx0XHRcdFx0XHRcdFx0XHRhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRcdFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFyZWEuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdFx0dmFyIGxvYztcblx0XHRcdFx0XHRyZXR1cm4gYXJlYS5jb250YWlucyhwb2ludClcblx0XHRcdFx0XHRcdHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpXG5cdFx0XHRcdFx0XHRcdCYmIGlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHRvbGVyYW5jZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXNDbG9zZUVub3VnaChzZWdtZW50Ll9wb2ludCwgc3Ryb2tlUGFkZGluZyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG5cdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKVxuXHRcdFx0XHRcdHx8IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLCB0cnVlKSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMuc2VnbWVudHMgfHwgb3B0aW9ucy5oYW5kbGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspXG5cdFx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MpIHtcblx0XHRcdFx0dmFyIHBhcmFtZXRlciA9IGxvYy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMCB8fCBwYXJhbWV0ZXIgPT09IDEgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGVja1NlZ21lbnRTdHJva2UobG9jLmdldFNlZ21lbnQoKSkpXG5cdFx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghbG9jICYmIGpvaW4gPT09ICdtaXRlcicgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0aWYgKHBvaW50LmdldERpc3RhbmNlKHNlZ21lbnQuX3BvaW50KSA8PSBtaXRlckxpbWl0XG5cdFx0XHRcdFx0XHRcdCYmIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSkge1xuXHRcdFx0XHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAhbG9jICYmIGhpdEZpbGwgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdHx8IGxvYyAmJiAhaGl0U3Ryb2tlICYmICFoaXRDdXJ2ZXNcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKVxuXHRcdFx0XHRcdDogbG9jXG5cdFx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoaGl0U3Ryb2tlID8gJ3N0cm9rZScgOiAnY3VydmUnLCB0aGlzLCB7XG5cdFx0XHRcdFx0XHRcdGxvY2F0aW9uOiBsb2MsXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBsb2MuZ2V0UG9pbnQoKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdDogbnVsbDtcblx0fVxuXG59LCBCYXNlLmVhY2goQ3VydmUuZXZhbHVhdGVNZXRob2RzLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCwgaXNQYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIGxvYyAmJiBsb2NbbmFtZV0oKTtcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0aWYgKGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgaW5kZXggPSB+fm9mZnNldCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaW5kZXhdO1xuXHRcdFx0cmV0dXJuIGN1cnZlID8gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBpbmRleCwgdHJ1ZSkgOiBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdGFydCA9IGxlbmd0aCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGN1cnZlcy5sZW5ndGggPiAwICYmIG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKVxuXHRcdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pbkxvYyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jLl9kaXN0YW5jZSA8IG1pbkRpc3QpIHtcblx0XHRcdFx0bWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG5cdFx0XHRcdG1pbkxvYyA9IGxvYztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1pbkxvYztcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGRyYXdIYW5kbGVzKGN0eCwgc2VnbWVudHMsIG1hdHJpeCwgc2l6ZSkge1xuXHRcdHZhciBoYWxmID0gc2l6ZSAvIDI7XG5cblx0XHRmdW5jdGlvbiBkcmF3SGFuZGxlKGluZGV4KSB7XG5cdFx0XHR2YXIgaFggPSBjb29yZHNbaW5kZXhdLFxuXHRcdFx0XHRoWSA9IGNvb3Jkc1tpbmRleCArIDFdO1xuXHRcdFx0aWYgKHBYICE9IGhYIHx8IHBZICE9IGhZKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhwWCwgcFkpO1xuXHRcdFx0XHRjdHgubGluZVRvKGhYLCBoWSk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKGhYLCBoWSwgaGFsZiwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0dmFyIHN0YXRlID0gc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRcdHBYID0gY29vcmRzWzBdLFxuXHRcdFx0XHRwWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChzdGF0ZSAmIDEpXG5cdFx0XHRcdGRyYXdIYW5kbGUoMik7XG5cdFx0XHRpZiAoc3RhdGUgJiAyKVxuXHRcdFx0XHRkcmF3SGFuZGxlKDQpO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiwgcFkgLSBoYWxmLCBzaXplLCBzaXplKTtcblx0XHRcdGlmICghKHN0YXRlICYgNCkpIHtcblx0XHRcdFx0dmFyIGZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XG5cdFx0XHRcdGN0eC5maWxsUmVjdChwWCAtIGhhbGYgKyAxLCBwWSAtIGhhbGYgKyAxLCBzaXplIC0gMiwgc2l6ZSAtIDIpO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdTZWdtZW50cyhjdHgsIHBhdGgsIG1hdHJpeCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0Y29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0Zmlyc3QgPSB0cnVlLFxuXHRcdFx0Y3VyWCwgY3VyWSxcblx0XHRcdHByZXZYLCBwcmV2WSxcblx0XHRcdGluWCwgaW5ZLFxuXHRcdFx0b3V0WCwgb3V0WTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdFx0Y3VyWCA9IGNvb3Jkc1swXTtcblx0XHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50O1xuXHRcdFx0XHRjdXJYID0gcG9pbnQuX3g7XG5cdFx0XHRcdGN1clkgPSBwb2ludC5feTtcblx0XHRcdH1cblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRjdHgubW92ZVRvKGN1clgsIGN1clkpO1xuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdGluWCA9IGNvb3Jkc1syXTtcblx0XHRcdFx0XHRpblkgPSBjb29yZHNbM107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0XHRcdGluWCA9IGN1clggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdFx0aW5ZID0gY3VyWSArIGhhbmRsZS5feTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5YID09PSBjdXJYICYmIGluWSA9PT0gY3VyWVxuXHRcdFx0XHRcdFx0JiYgb3V0WCA9PT0gcHJldlggJiYgb3V0WSA9PT0gcHJldlkpIHtcblx0XHRcdFx0XHRjdHgubGluZVRvKGN1clgsIGN1clkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKG91dFgsIG91dFksIGluWCwgaW5ZLCBjdXJYLCBjdXJZKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRvdXRYID0gY29vcmRzWzRdO1xuXHRcdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdFx0b3V0WCA9IHByZXZYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRvdXRZID0gcHJldlkgKyBoYW5kbGUuX3k7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGRyYXdTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAocGF0aC5fY2xvc2VkICYmIGxlbmd0aCA+IDApXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1swXSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpIHtcblx0XHRcdHZhciBkb250U3RhcnQgPSBwYXJhbS5kb250U3RhcnQsXG5cdFx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcblx0XHRcdFx0c3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRcdGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0XHRkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0ZGFzaExlbmd0aCA9ICFwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2ggJiYgaGFzU3Ryb2tlXG5cdFx0XHRcdFx0XHQmJiBkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aDtcblxuXHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0aWYgKCFkb250U3RhcnQgJiYgdGhpcy5fY3VycmVudFBhdGgpIHtcblx0XHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlICYmICFkYXNoTGVuZ3RoIHx8IGRvbnRQYWludCkge1xuXHRcdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE9mZnNldChpKSB7XG5cdFx0XHRcdHJldHVybiBkYXNoQXJyYXlbKChpICUgZGFzaExlbmd0aCkgKyBkYXNoTGVuZ3RoKSAlIGRhc2hMZW5ndGhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuXHRcdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGFzU3Ryb2tlKSB7XG5cdFx0XHRcdFx0aWYgKGRhc2hMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHR2YXIgaXRlcmF0b3IgPSBuZXcgUGF0aEl0ZXJhdG9yKHRoaXMsIDMyLCAwLjI1LFxuXHRcdFx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeCksXG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IGl0ZXJhdG9yLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IC1zdHlsZS5nZXREYXNoT2Zmc2V0KCksIHRvLFxuXHRcdFx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHRcdGZyb20gPSBmcm9tICUgbGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGZyb20gLT0gZ2V0T2Zmc2V0KGktLSkgKyBnZXRPZmZzZXQoaS0tKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRvID0gZnJvbSArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+IDAgfHwgdG8gPiAwKVxuXHRcdFx0XHRcdFx0XHRcdGl0ZXJhdG9yLmRyYXdQYXJ0KGN0eCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoZnJvbSwgMCksIE1hdGgubWF4KHRvLCAwKSk7XG5cdFx0XHRcdFx0XHRcdGZyb20gPSB0byArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIG1hdHJpeCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRkcmF3SGFuZGxlcyhjdHgsIHRoaXMuX3NlZ21lbnRzLCBtYXRyaXgsIHBhcGVyLnNldHRpbmdzLmhhbmRsZVNpemUpO1xuXHRcdH1cblx0fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcblx0XHR2YXIgbiA9IHJocy5sZW5ndGgsXG5cdFx0XHR4ID0gW10sXG5cdFx0XHR0bXAgPSBbXSxcblx0XHRcdGIgPSAyO1xuXHRcdHhbMF0gPSByaHNbMF0gLyBiO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR0bXBbaV0gPSAxIC8gYjtcblx0XHRcdGIgPSAoaSA8IG4gLSAxID8gNCA6IDIpIC0gdG1wW2ldO1xuXHRcdFx0eFtpXSA9IChyaHNbaV0gLSB4W2kgLSAxXSkgLyBiO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0eFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0c2l6ZSA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0XHRuID0gc2l6ZSxcblx0XHRcdFx0b3ZlcmxhcCA9IDA7XG5cdFx0XHRpZiAoc2l6ZSA8PSAyKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdG92ZXJsYXAgPSBNYXRoLm1pbihzaXplLCA0KTtcblx0XHRcdFx0biArPSBNYXRoLm1pbihzaXplLCBvdmVybGFwKSAqIDI7XG5cdFx0XHR9XG5cdFx0XHR2YXIga25vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuXHRcdFx0XHRrbm90c1tpICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdFx0a25vdHNbaV0gPSBzZWdtZW50c1tpICsgc2l6ZSAtIG92ZXJsYXBdLl9wb2ludDtcblx0XHRcdFx0XHRrbm90c1tpICsgc2l6ZSArIG92ZXJsYXBdID0gc2VnbWVudHNbaV0uX3BvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmhzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl94ICsgMiAqIGtub3RzW2kgKyAxXS5feDtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3g7XG5cdFx0XHR2YXIgeCA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG4gLSAxOyBpKyspXG5cdFx0XHRcdHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feSArIDIgKiBrbm90c1tpICsgMV0uX3k7XG5cdFx0XHRyaHNbMF0gPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feTtcblx0XHRcdHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl95O1xuXHRcdFx0dmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IHNpemU7IGkgPCBvdmVybGFwOyBpKyssIGorKykge1xuXHRcdFx0XHRcdHZhciBmMSA9IGkgLyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0ZjIgPSAxIC0gZjEsXG5cdFx0XHRcdFx0XHRpZSA9IGkgKyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0amUgPSBqICsgb3ZlcmxhcDtcblx0XHRcdFx0XHR4W2pdID0geFtpXSAqIGYxICsgeFtqXSAqIGYyO1xuXHRcdFx0XHRcdHlbal0gPSB5W2ldICogZjEgKyB5W2pdICogZjI7XG5cdFx0XHRcdFx0eFtqZV0gPSB4W2llXSAqIGYyICsgeFtqZV0gKiBmMTtcblx0XHRcdFx0XHR5W2plXSA9IHlbaWVdICogZjIgKyB5W2plXSAqIGYxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciBoYW5kbGVJbiA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcDsgaSA8PSBuIC0gb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaSAtIG92ZXJsYXBdO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbihoYW5kbGVJbi5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0XHRpZiAoaSA8IG4pIHtcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZU91dChcblx0XHRcdFx0XHRcdFx0bmV3IFBvaW50KHhbaV0sIHlbaV0pLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBpIDwgbiAtIDFcblx0XHRcdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feCAtIHhbaSArIDFdLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiBrbm90c1tpICsgMV0uX3kgLSB5W2kgKyAxXSlcblx0XHRcdFx0XHRcdFx0OiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0KGtub3RzW25dLl94ICsgeFtuIC0gMV0pIC8gMixcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3kgKyB5W24gLSAxXSkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCAmJiBoYW5kbGVJbikge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFNlZ21lbnQodGhhdCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoYXQuX3NlZ21lbnRzO1xuXHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcblx0XHRyZXR1cm4gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1vdmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdHRoaXMucmVtb3ZlU2VnbWVudCgwKTtcblx0XHRcdGlmICghc2VnbWVudHMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRtb3ZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtb3ZlQnkoKSBpcyB1bnN1cHBvcnRlZCBvbiBQYXRoIGl0ZW1zLicpO1xuXHRcdH0sXG5cblx0XHRsaW5lVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpO1xuXHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQoaGFuZGxlMS5zdWJ0cmFjdChjdXJyZW50Ll9wb2ludCkpO1xuXHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQodG8sIGhhbmRsZTIuc3VidHJhY3QodG8pKSBdKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRoYW5kbGUuYWRkKGN1cnJlbnQuc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHRoYW5kbGUuYWRkKHRvLnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcblx0XHRcdFx0dG9cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGN1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0ID0gQmFzZS5waWNrKEJhc2UucmVhZChhcmd1bWVudHMpLCAwLjUpLFxuXHRcdFx0XHR0MSA9IDEgLSB0LFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuXHRcdFx0XHRoYW5kbGUgPSB0aHJvdWdoLnN1YnRyYWN0KGN1cnJlbnQubXVsdGlwbHkodDEgKiB0MSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHRvLm11bHRpcGx5KHQgKiB0KSkuZGl2aWRlKDIgKiB0ICogdDEpO1xuXHRcdFx0aWYgKGhhbmRsZS5pc05hTigpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0Nhbm5vdCBwdXQgYSBjdXJ2ZSB0aHJvdWdoIHBvaW50cyB3aXRoIHBhcmFtZXRlciA9ICcgKyB0KTtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhoYW5kbGUsIHRvKTtcblx0XHR9LFxuXG5cdFx0YXJjVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKSxcblx0XHRcdFx0ZnJvbSA9IGN1cnJlbnQuX3BvaW50LFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dGhyb3VnaCxcblx0XHRcdFx0cGVlayA9IEJhc2UucGVlayhhcmd1bWVudHMpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2socGVlaywgdHJ1ZSksXG5cdFx0XHRcdGNlbnRlciwgZXh0ZW50LCB2ZWN0b3IsIG1hdHJpeDtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dmFyIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdHRocm91Z2ggPSBtaWRkbGUuYWRkKG1pZGRsZS5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoXG5cdFx0XHRcdFx0XHRjbG9ja3dpc2UgPyAtOTAgOiA5MCkpO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLnJlbWFpbihhcmd1bWVudHMpIDw9IDIpIHtcblx0XHRcdFx0dGhyb3VnaCA9IHRvO1xuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0aWYgKHJhZGl1cy5pc1plcm8oKSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHR2YXIgcm90YXRpb24gPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRjbG9ja3dpc2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGxhcmdlID0gISFCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdHB0ID0gZnJvbS5zdWJ0cmFjdChtaWRkbGUpLnJvdGF0ZSgtcm90YXRpb24pLFxuXHRcdFx0XHRcdHggPSBwdC54LFxuXHRcdFx0XHRcdHkgPSBwdC55LFxuXHRcdFx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRcdHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG5cdFx0XHRcdFx0cnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcngsXG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnksXG5cdFx0XHRcdFx0eFNxID0gIHggKiB4LFxuXHRcdFx0XHRcdHlTcSA9ICB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IE1hdGguc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cdFx0XHRcdGlmIChmYWN0b3IgPiAxKSB7XG5cdFx0XHRcdFx0cnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ5ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeDtcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgL1xuXHRcdFx0XHRcdFx0KHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcblx0XHRcdFx0aWYgKGFicyhmYWN0b3IpIDwgMWUtMTIpXG5cdFx0XHRcdFx0ZmFjdG9yID0gMDtcblx0XHRcdFx0aWYgKGZhY3RvciA8IDApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdGNlbnRlciA9IG5ldyBQb2ludChyeCAqIHkgLyByeSwgLXJ5ICogeCAvIHJ4KVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KChsYXJnZSA9PT0gY2xvY2t3aXNlID8gLTEgOiAxKVxuXHRcdFx0XHRcdFx0XHQqIE1hdGguc3FydChmYWN0b3IpKVxuXHRcdFx0XHRcdFx0LnJvdGF0ZShyb3RhdGlvbikuYWRkKG1pZGRsZSk7XG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKS5yb3RhdGUocm90YXRpb24pXG5cdFx0XHRcdFx0XHQuc2NhbGUocngsIHJ5KTtcblx0XHRcdFx0dmVjdG9yID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKGZyb20pO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZShtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odG8pKTtcblx0XHRcdFx0aWYgKCFjbG9ja3dpc2UgJiYgZXh0ZW50ID4gMClcblx0XHRcdFx0XHRleHRlbnQgLT0gMzYwO1xuXHRcdFx0XHRlbHNlIGlmIChjbG9ja3dpc2UgJiYgZXh0ZW50IDwgMClcblx0XHRcdFx0XHRleHRlbnQgKz0gMzYwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRocm91Z2gpIHtcblx0XHRcdFx0dmFyIGwxID0gbmV3IExpbmUoZnJvbS5hZGQodGhyb3VnaCkuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0aHJvdWdoLnN1YnRyYWN0KGZyb20pLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGwyID0gbmV3IExpbmUodGhyb3VnaC5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dG8uc3VidHJhY3QodGhyb3VnaCkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bGluZSA9IG5ldyBMaW5lKGZyb20sIHRvKSxcblx0XHRcdFx0XHR0aHJvdWdoU2lkZSA9IGxpbmUuZ2V0U2lkZSh0aHJvdWdoKTtcblx0XHRcdFx0Y2VudGVyID0gbDEuaW50ZXJzZWN0KGwyLCB0cnVlKTtcblx0XHRcdFx0aWYgKCFjZW50ZXIpIHtcblx0XHRcdFx0XHRpZiAoIXRocm91Z2hTaWRlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSBmcm9tLnN1YnRyYWN0KGNlbnRlcik7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKHRvLnN1YnRyYWN0KGNlbnRlcikpO1xuXHRcdFx0XHR2YXIgY2VudGVyU2lkZSA9IGxpbmUuZ2V0U2lkZShjZW50ZXIpO1xuXHRcdFx0XHRpZiAoY2VudGVyU2lkZSA9PT0gMCkge1xuXHRcdFx0XHRcdGV4dGVudCA9IHRocm91Z2hTaWRlICogTWF0aC5hYnMoZXh0ZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aHJvdWdoU2lkZSA9PT0gY2VudGVyU2lkZSkge1xuXHRcdFx0XHRcdGV4dGVudCArPSBleHRlbnQgPCAwID8gMzYwIDogLTM2MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGV4dCA9IE1hdGguYWJzKGV4dGVudCksXG5cdFx0XHRcdGNvdW50ID0gZXh0ID49IDM2MCA/IDQgOiBNYXRoLmNlaWwoZXh0IC8gOTApLFxuXHRcdFx0XHRpbmMgPSBleHRlbnQgLyBjb3VudCxcblx0XHRcdFx0aGFsZiA9IGluYyAqIE1hdGguUEkgLyAzNjAsXG5cdFx0XHRcdHogPSA0IC8gMyAqIE1hdGguc2luKGhhbGYpIC8gKDEgKyBNYXRoLmNvcyhoYWxmKSksXG5cdFx0XHRcdHNlZ21lbnRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwdCA9IHRvLFxuXHRcdFx0XHRcdG91dCA9IG51bGw7XG5cdFx0XHRcdGlmIChpIDwgY291bnQpIHtcblx0XHRcdFx0XHRvdXQgPSB2ZWN0b3Iucm90YXRlKDkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRwdCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yKTtcblx0XHRcdFx0XHRcdG91dCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChvdXQpKVxuXHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0ID0gY2VudGVyLmFkZCh2ZWN0b3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KG91dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIF9pbiA9IHZlY3Rvci5yb3RhdGUoLTkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRfaW4gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQoX2luKSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHB0LCBfaW4sIG91dCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IHZlY3Rvci5yb3RhdGUoaW5jKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZChzZWdtZW50cyk7XG5cdFx0fSxcblxuXHRcdGxpbmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGFyYW1ldGVyID0gQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1cnZlVG8oY3VycmVudC5hZGQodGhyb3VnaCksIGN1cnJlbnQuYWRkKHRvKSwgcGFyYW1ldGVyKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZTEpLCBjdXJyZW50LmFkZChoYW5kbGUyKSxcblx0XHRcdFx0XHRjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZSksIGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGFyY0J5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuXHRcdFx0XHRwb2ludCA9IGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhCYXNlLnBlZWsoYXJndW1lbnRzKSwgdHJ1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGNsb2Nrd2lzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihqb2luKSB7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdGlmIChqb2luKVxuXHRcdFx0XHR0aGlzLmpvaW4oKTtcblx0XHR9XG5cdH07XG59LCB7XG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHRyZXR1cm4gUGF0aFtnZXR0ZXJdKHRoaXMuX3NlZ21lbnRzLCB0aGlzLl9jbG9zZWQsIHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0bWF0cml4KTtcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRpZiAoIWZpcnN0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgZmFsc2UpLFxuXHRcdFx0bWluID0gcHJldkNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBuZXcgQXJyYXkoMik7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0Q3VydmUuX2FkZEJvdW5kcyhcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2ldLFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaSArIDRdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpICsgMl0sXG5cdFx0XHRcdFx0Y29vcmRzW2ldLFxuXHRcdFx0XHRcdGksIHN0cm9rZVBhZGRpbmcgPyBzdHJva2VQYWRkaW5nW2ldIDogMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRcdH1cblx0XHRcdHZhciB0bXAgPSBwcmV2Q29vcmRzO1xuXHRcdFx0cHJldkNvb3JkcyA9IGNvb3Jkcztcblx0XHRcdGNvb3JkcyA9IHRtcDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoZmlyc3QpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0Z2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0aWYgKCFzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdHJldHVybiBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KTtcblx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKSxcblx0XHRcdHJhZGl1cyA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyLFxuXHRcdFx0cGFkZGluZyA9IFBhdGguX2dldFBlblBhZGRpbmcocmFkaXVzLCBtYXRyaXgpLFxuXHRcdFx0Ym91bmRzID0gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgcGFkZGluZyksXG5cdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdHZhciBqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShwYWRkaW5nKS5tdWx0aXBseSgyKSk7XG5cblx0XHRmdW5jdGlvbiBhZGQocG9pbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy5pbmNsdWRlKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50KSA6IHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSb3VuZChzZWdtZW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMudW5pdGUoam9pbkJvdW5kcy5zZXRDZW50ZXIobWF0cml4XG5cdFx0XHRcdD8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChzZWdtZW50Ll9wb2ludCkgOiBzZWdtZW50Ll9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW4sXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdGlmIChqb2luID09PSAncm91bmQnIHx8ICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0JiYgaGFuZGxlSW4uaXNDb2xsaW5lYXIoaGFuZGxlT3V0KSkge1xuXHRcdFx0XHRhZGRSb3VuZChzZWdtZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsIGFkZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkQ2FwKHNlZ21lbnQsIGNhcCkge1xuXHRcdFx0aWYgKGNhcCA9PT0gJ3JvdW5kJykge1xuXHRcdFx0XHRhZGRSb3VuZChzZWdtZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0YWRkSm9pbihzZWdtZW50c1tpXSwgam9pbik7XG5cdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0YWRkSm9pbihzZWdtZW50c1swXSwgam9pbik7XG5cdFx0fSBlbHNlIGlmIChsZW5ndGggPiAwKSB7XG5cdFx0XHRhZGRDYXAoc2VnbWVudHNbMF0sIGNhcCk7XG5cdFx0XHRhZGRDYXAoc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIGNhcCk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0X2dldFBlblBhZGRpbmc6IGZ1bmN0aW9uKHJhZGl1cywgbWF0cml4KSB7XG5cdFx0aWYgKCFtYXRyaXgpXG5cdFx0XHRyZXR1cm4gW3JhZGl1cywgcmFkaXVzXTtcblx0XHR2YXIgbXggPSBtYXRyaXguc2hpZnRsZXNzKCksXG5cdFx0XHRob3IgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KHJhZGl1cywgMCkpLFxuXHRcdFx0dmVyID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludCgwLCByYWRpdXMpKSxcblx0XHRcdHBoaSA9IGhvci5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0YSA9IGhvci5nZXRMZW5ndGgoKSxcblx0XHRcdGIgPSB2ZXIuZ2V0TGVuZ3RoKCk7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luKHBoaSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhwaGkpLFxuXHRcdFx0dGFuID0gTWF0aC50YW4ocGhpKSxcblx0XHRcdHR4ID0gLU1hdGguYXRhbihiICogdGFuIC8gYSksXG5cdFx0XHR0eSA9IE1hdGguYXRhbihiIC8gKHRhbiAqIGEpKTtcblx0XHRyZXR1cm4gW01hdGguYWJzKGEgKiBNYXRoLmNvcyh0eCkgKiBjb3MgLSBiICogTWF0aC5zaW4odHgpICogc2luKSxcblx0XHRcdFx0TWF0aC5hYnMoYiAqIE1hdGguc2luKHR5KSAqIGNvcyArIGEgKiBNYXRoLmNvcyh0eSkgKiBzaW4pXTtcblx0fSxcblxuXHRfYWRkQmV2ZWxKb2luOiBmdW5jdGlvbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsIGFkZFBvaW50LCBhcmVhKSB7XG5cdFx0dmFyIGN1cnZlMiA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcblx0XHRcdGN1cnZlMSA9IGN1cnZlMi5nZXRQcmV2aW91cygpLFxuXHRcdFx0cG9pbnQgPSBjdXJ2ZTIuZ2V0UG9pbnRBdCgwLCB0cnVlKSxcblx0XHRcdG5vcm1hbDEgPSBjdXJ2ZTEuZ2V0Tm9ybWFsQXQoMSwgdHJ1ZSksXG5cdFx0XHRub3JtYWwyID0gY3VydmUyLmdldE5vcm1hbEF0KDAsIHRydWUpLFxuXHRcdFx0c3RlcCA9IG5vcm1hbDEuZ2V0RGlyZWN0ZWRBbmdsZShub3JtYWwyKSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzO1xuXHRcdG5vcm1hbDEuc2V0TGVuZ3RoKHN0ZXApO1xuXHRcdG5vcm1hbDIuc2V0TGVuZ3RoKHN0ZXApO1xuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRhZGRQb2ludChwb2ludCk7XG5cdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMSkpO1xuXHRcdH1cblx0XHRpZiAoam9pbiA9PT0gJ21pdGVyJykge1xuXHRcdFx0dmFyIGNvcm5lciA9IG5ldyBMaW5lKFxuXHRcdFx0XHRcdHBvaW50LmFkZChub3JtYWwxKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDEueSwgbm9ybWFsMS54KSwgdHJ1ZVxuXHRcdFx0XHQpLmludGVyc2VjdChuZXcgTGluZShcblx0XHRcdFx0XHRwb2ludC5hZGQobm9ybWFsMiksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwyLnksIG5vcm1hbDIueCksIHRydWVcblx0XHRcdFx0KSwgdHJ1ZSk7XG5cdFx0XHRpZiAoY29ybmVyICYmIHBvaW50LmdldERpc3RhbmNlKGNvcm5lcikgPD0gbWl0ZXJMaW1pdCkge1xuXHRcdFx0XHRhZGRQb2ludChjb3JuZXIpO1xuXHRcdFx0XHRpZiAoIWFyZWEpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWFyZWEpXG5cdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMSkpO1xuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwyKSk7XG5cdH0sXG5cblx0X2FkZFNxdWFyZUNhcDogZnVuY3Rpb24oc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZFBvaW50LCBhcmVhKSB7XG5cdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQsXG5cdFx0XHRsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCksXG5cdFx0XHRub3JtYWwgPSBsb2MuZ2V0Tm9ybWFsKCkubXVsdGlwbHkocmFkaXVzKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0fVxuXHRcdGlmIChjYXAgPT09ICdzcXVhcmUnKVxuXHRcdFx0cG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZShsb2MuZ2V0UGFyYW1ldGVyKCkgPT09IDAgPyAtOTAgOiA5MCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRqb2luUGFkZGluZykge1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHR4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuXHRcdFx0XHR2YXIgcGFkZGluZyA9IGogPT09IDAgPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRcdFx0cGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG5cdFx0XHRcdFx0cGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG5cdFx0XHRcdFx0eCA9IGNvb3Jkc1tqXSxcblx0XHRcdFx0XHR5ID0gY29vcmRzW2ogKyAxXSxcblx0XHRcdFx0XHR4biA9IHggLSBwYWRkaW5nWCxcblx0XHRcdFx0XHR4eCA9IHggKyBwYWRkaW5nWCxcblx0XHRcdFx0XHR5biA9IHkgLSBwYWRkaW5nWSxcblx0XHRcdFx0XHR5eCA9IHkgKyBwYWRkaW5nWTtcblx0XHRcdFx0aWYgKHhuIDwgeDEpIHgxID0geG47XG5cdFx0XHRcdGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuXHRcdFx0XHRpZiAoeW4gPCB5MSkgeTEgPSB5bjtcblx0XHRcdFx0aWYgKHl4ID4geTIpIHkyID0geXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0Z2V0Um91Z2hCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpIHtcblx0XHR2YXIgc3Ryb2tlUmFkaXVzID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG5cdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuXHRcdGlmIChzdHJva2VSYWRpdXMgPiAwKSB7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcblx0XHRcdFx0am9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguc3FydCgyKSk7XG5cdFx0fVxuXHRcdHJldHVybiBQYXRoLmdldEhhbmRsZUJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LFxuXHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKHN0cm9rZVJhZGl1cywgbWF0cml4KSxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhqb2luUmFkaXVzLCBtYXRyaXgpKTtcblx0fVxufX0pO1xuXG5QYXRoLmluamVjdCh7IHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0ZWxsaXBzZVNlZ21lbnRzID0gW1xuXHRcdFx0bmV3IFNlZ21lbnQoWy0xLCAwXSwgWzAsIGthcHBhIF0sIFswLCAta2FwcGFdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAtMV0sIFsta2FwcGEsIDBdLCBba2FwcGEsIDAgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMSwgMF0sIFswLCAta2FwcGFdLCBbMCwga2FwcGEgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgMV0sIFtrYXBwYSwgMCBdLCBbLWthcHBhLCAwXSlcblx0XHRdO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoc2VnbWVudHMsIGNsb3NlZCwgYXJncykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG5cdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cGF0aC5fYWRkKHNlZ21lbnRzKTtcblx0XHRwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChcblx0XHRcdFx0c2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cylcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChbXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJykpLFxuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSlcblx0XHRcdF0sIGZhbHNlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycsIDAsXG5cdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0XHRibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcblx0XHRcdFx0dGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG5cdFx0XHRcdHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcblx0XHRcdFx0YnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuXHRcdFx0XHRzZWdtZW50cztcblx0XHRcdGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChicilcblx0XHRcdFx0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0aHggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdGh5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRPdmFsOiAnI0VsbGlwc2UnLFxuXG5cdFx0QXJjOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0dGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0aHJvdWdoJyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyksXG5cdFx0XHRcdHByb3BzID0gQmFzZS5nZXROYW1lZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oZnJvbSk7XG5cdFx0XHRwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcblx0XHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdFx0fSxcblxuXHRcdFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHNpZGVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAnc2lkZXMnKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBzaWRlcyxcblx0XHRcdFx0dGhyZWUgPSAhKHNpZGVzICUgMyksXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuXHRcdFx0XHRvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcblx0XHRcdFx0XHR2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0U3RhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdwb2ludHMnKSAqIDIsXG5cdFx0XHRcdHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMxJyksXG5cdFx0XHRcdHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMyJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBwb2ludHMsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSlcblx0XHRcdFx0XHRcdC5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbXBvdW5kUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcblx0XHRcdFx0aXRlbXMuc3BsaWNlLmFwcGx5KGl0ZW1zLCBbaSwgMV0uY29uY2F0KGl0ZW0ucmVtb3ZlQ2hpbGRyZW4oKSkpO1xuXHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpdGVtcyA9IGluc2VydENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSwgUGF0aCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSAhX3ByZXNlcnZlICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdGlmIChpdGVtLl9jbG9ja3dpc2UgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0aXRlbS5zZXRDbG9ja3dpc2UoaXRlbS5faW5kZXggPT09IDApO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5yZXZlcnNlKCk7XG5cdH0sXG5cblx0c21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLnNtb290aCgpO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIHBhdGggPSBjaGlsZHJlbltpXS5yZWR1Y2UoKTtcblx0XHRcdGlmIChwYXRoLmlzRW1wdHkoKSlcblx0XHRcdFx0Y2hpbGRyZW4uc3BsaWNlKGksIDEpO1xuXHRcdH1cblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRwYXRoLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIHJlZHVjZS5iYXNlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBjaGlsZCAmJiBjaGlsZC5pc0Nsb2Nrd2lzZSgpO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPT0gISFjbG9ja3dpc2UpXG5cdFx0XHR0aGlzLnJldmVyc2UoKTtcblx0fSxcblxuXHRnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0Y3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjdXJ2ZXMucHVzaC5hcHBseShjdXJ2ZXMsIGNoaWxkcmVuW2ldLmdldEN1cnZlcygpKTtcblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRGaXJzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRhcmVhID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGFyZWEgKz0gY2hpbGRyZW5baV0uZ2V0QXJlYSgpO1xuXHRcdHJldHVybiBhcmVhO1xuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRwYXRocyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0cGF0aHMucHVzaChjaGlsZC5nZXRQYXRoRGF0YShfbWF0cml4ICYmICFteC5pc0lkZW50aXR5KClcblx0XHRcdFx0XHQ/IF9tYXRyaXguY2hhaW4obXgpIDogX21hdHJpeCwgX3ByZWNpc2lvbikpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHMuam9pbignICcpO1xuXHR9XG59LCB7XG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCdcblx0XHRcdFx0PyBvcHRpb25zXG5cdFx0XHRcdDogbmV3IEJhc2Uob3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgZG9udFN0YXJ0OiB0cnVlLCBkb250RmluaXNoOiB0cnVlIH0pO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblxuXHRcdGlmICghcGFyYW0uY2xpcCkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2VsZWN0ZWRJdGVtcykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0aWYgKCFzZWxlY3RlZEl0ZW1zW2NoaWxkLl9pZF0pXG5cdFx0XHRcdGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXhcblx0XHRcdFx0XHRcdDogbWF0cml4LmNoYWluKG14KSk7XG5cdFx0fVxuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50UGF0aCh0aGF0LCBjaGVjaykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoYXQuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGVjayAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcblx0XHRyZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG5cdH1cblxuXHR2YXIgZmllbGRzID0ge1xuXHRcdG1vdmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMpLFxuXHRcdFx0XHRwYXRoID0gY3VycmVudCAmJiBjdXJyZW50LmlzRW1wdHkoKSA/IGN1cnJlbnRcblx0XHRcdFx0XHRcdDogbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0aWYgKHBhdGggIT09IGN1cnJlbnQpXG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGQocGF0aCk7XG5cdFx0XHRwYXRoLm1vdmVUby5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRtb3ZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKSxcblx0XHRcdFx0bGFzdCA9IGN1cnJlbnQgJiYgY3VycmVudC5nZXRMYXN0U2VnbWVudCgpLFxuXHRcdFx0XHRwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMubW92ZVRvKGxhc3QgPyBwb2ludC5hZGQobGFzdC5fcG9pbnQpIDogcG9pbnQpO1xuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGpvaW4pIHtcblx0XHRcdGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLmNsb3NlUGF0aChqb2luKTtcblx0XHR9XG5cdH07XG5cblx0QmFzZS5lYWNoKFsnbGluZVRvJywgJ2N1YmljQ3VydmVUbycsICdxdWFkcmF0aWNDdXJ2ZVRvJywgJ2N1cnZlVG8nLCAnYXJjVG8nLFxuXHRcdFx0J2xpbmVCeScsICdjdWJpY0N1cnZlQnknLCAncXVhZHJhdGljQ3VydmVCeScsICdjdXJ2ZUJ5JywgJ2FyY0J5J10sXG5cdFx0XHRmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0ZmllbGRzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgcGF0aCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpO1xuXHRcdFx0XHRcdHBhdGhba2V5XS5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHQpO1xuXG5cdHJldHVybiBmaWVsZHM7XG59KTtcblxuUGF0aEl0ZW0uaW5qZWN0KG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHR1bml0ZTogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDEgfHwgdyA9PT0gMDtcblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMjtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAxO1xuXHRcdH0sXG5cblx0XHRleGNsdWRlOiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gcHJlcGFyZVBhdGgocGF0aCwgcmVzb2x2ZSkge1xuXHRcdHZhciByZXMgPSBwYXRoLmNsb25lKGZhbHNlKS5yZWR1Y2UoKS50cmFuc2Zvcm0obnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHJlc29sdmUgPyByZXMucmVzb2x2ZUNyb3NzaW5ncygpLnJlb3JpZW50KCkgOiByZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5pc2hCb29sZWFuKGN0b3IsIHBhdGhzLCBwYXRoMSwgcGF0aDIsIHJlZHVjZSkge1xuXHRcdHZhciByZXN1bHQgPSBuZXcgY3RvcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmVzdWx0LmFkZENoaWxkcmVuKHBhdGhzLCB0cnVlKTtcblx0XHRpZiAocmVkdWNlKVxuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LnJlZHVjZSgpO1xuXHRcdHJlc3VsdC5pbnNlcnRBYm92ZShwYXRoMiAmJiBwYXRoMS5pc1NpYmxpbmcocGF0aDIpXG5cdFx0XHRcdCYmIHBhdGgxLmdldEluZGV4KCkgPCBwYXRoMi5nZXRJbmRleCgpXG5cdFx0XHRcdFx0PyBwYXRoMiA6IHBhdGgxKTtcblx0XHRyZXN1bHQuc2V0U3R5bGUocGF0aDEuX3N0eWxlKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHV0ZUJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pIHtcblx0XHRpZiAoIXBhdGgxLl9jaGlsZHJlbiAmJiAhcGF0aDEuX2Nsb3NlZClcblx0XHRcdHJldHVybiBjb21wdXRlT3BlbkJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pO1xuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSwgdHJ1ZSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIsIHRydWUpO1xuXHRcdGlmIChfcGF0aDIgJiYgL14oc3VidHJhY3R8ZXhjbHVkZSkkLy50ZXN0KG9wZXJhdGlvbilcblx0XHRcdFx0XiAoX3BhdGgyLmlzQ2xvY2t3aXNlKCkgIT09IF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0dmFyIGludGVyc2VjdGlvbnMgPSBDdXJ2ZUxvY2F0aW9uLmV4cGFuZChcblx0XHRcdF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdFx0cmV0dXJuIF9wYXRoMiAmJiBpbnRlci5pc092ZXJsYXAoKSB8fCBpbnRlci5pc0Nyb3NzaW5nKCk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cdFx0ZGl2aWRlTG9jYXRpb25zKGludGVyc2VjdGlvbnMpO1xuXG5cdFx0dmFyIHNlZ21lbnRzID0gW10sXG5cdFx0XHRtb25vQ3VydmVzID0gW107XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0KHBhdGhzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXHRcdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBwYXRoLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbGxlY3QoX3BhdGgxLl9jaGlsZHJlbiB8fCBbX3BhdGgxXSk7XG5cdFx0aWYgKF9wYXRoMilcblx0XHRcdGNvbGxlY3QoX3BhdGgyLl9jaGlsZHJlbiB8fCBbX3BhdGgyXSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cHJvcGFnYXRlV2luZGluZyhpbnRlcnNlY3Rpb25zW2ldLl9zZWdtZW50LCBfcGF0aDEsIF9wYXRoMixcblx0XHRcdFx0XHRtb25vQ3VydmVzLCBvcGVyYXRpb24pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll93aW5kaW5nID09IG51bGwpIHtcblx0XHRcdFx0cHJvcGFnYXRlV2luZGluZyhzZWdtZW50LCBfcGF0aDEsIF9wYXRoMiwgbW9ub0N1cnZlcyxcblx0XHRcdFx0XHRcdG9wZXJhdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmaW5pc2hCb29sZWFuKENvbXBvdW5kUGF0aCwgdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0aW9uKSxcblx0XHRcdFx0cGF0aDEsIHBhdGgyLCB0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVPcGVuQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbikge1xuXHRcdGlmICghcGF0aDIgfHwgIXBhdGgyLl9jaGlsZHJlbiAmJiAhcGF0aDIuX2Nsb3NlZFxuXHRcdFx0XHR8fCAhL14oc3VidHJhY3R8aW50ZXJzZWN0KSQvLnRlc3Qob3BlcmF0aW9uKSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSwgZmFsc2UpLFxuXHRcdFx0X3BhdGgyID0gcHJlcGFyZVBhdGgocGF0aDIsIGZhbHNlKSxcblx0XHRcdGludGVyc2VjdGlvbnMgPSBfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdHJldHVybiBpbnRlci5pc092ZXJsYXAoKSB8fCBpbnRlci5pc0Nyb3NzaW5nKCk7XG5cdFx0XHR9KSxcblx0XHRcdHN1YiA9IG9wZXJhdGlvbiA9PT0gJ3N1YnRyYWN0Jyxcblx0XHRcdHBhdGhzID0gW107XG5cblx0XHRmdW5jdGlvbiBhZGRQYXRoKHBhdGgpIHtcblx0XHRcdGlmIChfcGF0aDIuY29udGFpbnMocGF0aC5nZXRQb2ludEF0KHBhdGguZ2V0TGVuZ3RoKCkgLyAyKSkgXiBzdWIpIHtcblx0XHRcdFx0cGF0aHMudW5zaGlmdChwYXRoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IGludGVyc2VjdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBwYXRoID0gaW50ZXJzZWN0aW9uc1tpXS5zcGxpdCgpO1xuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0aWYgKGFkZFBhdGgocGF0aCkpXG5cdFx0XHRcdFx0cGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbigwLCAwKTtcblx0XHRcdFx0X3BhdGgxLmdldExhc3RTZWdtZW50KCkuc2V0SGFuZGxlT3V0KDAsIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhZGRQYXRoKF9wYXRoMSk7XG5cdFx0cmV0dXJuIGZpbmlzaEJvb2xlYW4oR3JvdXAsIHBhdGhzLCBwYXRoMSwgcGF0aDIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbGlua0ludGVyc2VjdGlvbnMoZnJvbSwgdG8pIHtcblx0XHR2YXIgcHJldiA9IGZyb207XG5cdFx0d2hpbGUgKHByZXYpIHtcblx0XHRcdGlmIChwcmV2ID09PSB0bylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0cHJldiA9IHByZXYuX3ByZXY7XG5cdFx0fVxuXHRcdHdoaWxlIChmcm9tLl9uZXh0ICYmIGZyb20uX25leHQgIT09IHRvKVxuXHRcdFx0ZnJvbSA9IGZyb20uX25leHQ7XG5cdFx0aWYgKCFmcm9tLl9uZXh0KSB7XG5cdFx0XHR3aGlsZSAodG8uX3ByZXYpXG5cdFx0XHRcdHRvID0gdG8uX3ByZXY7XG5cdFx0XHRmcm9tLl9uZXh0ID0gdG87XG5cdFx0XHR0by5fcHJldiA9IGZyb207XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGl2aWRlTG9jYXRpb25zKGxvY2F0aW9ucykge1xuXHRcdHZhciB0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdG5vSGFuZGxlcyA9IGZhbHNlLFxuXHRcdFx0Y2xlYXJTZWdtZW50cyA9IFtdLFxuXHRcdFx0cHJldkN1cnZlLFxuXHRcdFx0cHJldlQ7XG5cblx0XHRmb3IgKHZhciBpID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbG9jID0gbG9jYXRpb25zW2ldLFxuXHRcdFx0XHRjdXJ2ZSA9IGxvYy5fY3VydmUsXG5cdFx0XHRcdHQgPSBsb2MuX3BhcmFtZXRlcixcblx0XHRcdFx0b3JpZ1QgPSB0O1xuXHRcdFx0aWYgKGN1cnZlICE9PSBwcmV2Q3VydmUpIHtcblx0XHRcdFx0bm9IYW5kbGVzID0gIWN1cnZlLmhhc0hhbmRsZXMoKTtcblx0XHRcdH0gZWxzZSBpZiAocHJldlQgPiAwKSB7XG5cdFx0XHRcdHQgLz0gcHJldlQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VnbWVudDtcblx0XHRcdGlmICh0IDwgdE1pbikge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmICh0ID4gdE1heCkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLmRpdmlkZSh0LCB0cnVlLCB0cnVlKS5fc2VnbWVudDE7XG5cdFx0XHRcdGlmIChub0hhbmRsZXMpXG5cdFx0XHRcdFx0Y2xlYXJTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0fVxuXHRcdFx0bG9jLl9zZXRTZWdtZW50KHNlZ21lbnQpO1xuXHRcdFx0dmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRkZXN0ID0gbG9jLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRpZiAoaW50ZXIpIHtcblx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMoaW50ZXIsIGRlc3QpO1xuXHRcdFx0XHR2YXIgb3RoZXIgPSBpbnRlcjtcblx0XHRcdFx0d2hpbGUgKG90aGVyKSB7XG5cdFx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMob3RoZXIuX2ludGVyc2VjdGlvbiwgaW50ZXIpO1xuXHRcdFx0XHRcdG90aGVyID0gb3RoZXIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGRlc3Q7XG5cdFx0XHR9XG5cdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHRcdHByZXZUID0gb3JpZ1Q7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2xlYXJTZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNsZWFyU2VnbWVudHNbaV0uY2xlYXJIYW5kbGVzKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0V2luZGluZyhwb2ludCwgY3VydmVzLCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDJlLTcsXG5cdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdHB4ID0gcG9pbnQueCxcblx0XHRcdHB5ID0gcG9pbnQueSxcblx0XHRcdHdpbmRMZWZ0ID0gMCxcblx0XHRcdHdpbmRSaWdodCA9IDAsXG5cdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0YWJzID0gTWF0aC5hYnM7XG5cdFx0aWYgKGhvcml6b250YWwpIHtcblx0XHRcdHZhciB5VG9wID0gLUluZmluaXR5LFxuXHRcdFx0XHR5Qm90dG9tID0gSW5maW5pdHksXG5cdFx0XHRcdHlCZWZvcmUgPSBweSAtIGVwc2lsb24sXG5cdFx0XHRcdHlBZnRlciA9IHB5ICsgZXBzaWxvbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAwLCBweCwgcm9vdHMsIDAsIDEpID4gMCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSByb290cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHJvb3RzW2pdKS55O1xuXHRcdFx0XHRcdFx0aWYgKHkgPCB5QmVmb3JlICYmIHkgPiB5VG9wKSB7XG5cdFx0XHRcdFx0XHRcdHlUb3AgPSB5O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh5ID4geUFmdGVyICYmIHkgPCB5Qm90dG9tKSB7XG5cdFx0XHRcdFx0XHRcdHlCb3R0b20gPSB5O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0eVRvcCA9ICh5VG9wICsgcHkpIC8gMjtcblx0XHRcdHlCb3R0b20gPSAoeUJvdHRvbSArIHB5KSAvIDI7XG5cdFx0XHRpZiAoeVRvcCA+IC1JbmZpbml0eSlcblx0XHRcdFx0d2luZExlZnQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludChweCwgeVRvcCksIGN1cnZlcywgZmFsc2UsXG5cdFx0XHRcdFx0XHR0ZXN0Q29udGFpbnMpO1xuXHRcdFx0aWYgKHlCb3R0b20gPCBJbmZpbml0eSlcblx0XHRcdFx0d2luZFJpZ2h0ID0gZ2V0V2luZGluZyhuZXcgUG9pbnQocHgsIHlCb3R0b20pLCBjdXJ2ZXMsIGZhbHNlLFxuXHRcdFx0XHRcdFx0dGVzdENvbnRhaW5zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHhCZWZvcmUgPSBweCAtIGVwc2lsb24sXG5cdFx0XHRcdHhBZnRlciA9IHB4ICsgZXBzaWxvbjtcblx0XHRcdHZhciBzdGFydENvdW50ZWQgPSBmYWxzZSxcblx0XHRcdFx0cHJldkN1cnZlLFxuXHRcdFx0XHRwcmV2VDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0dmFsdWVzID0gY3VydmUudmFsdWVzLFxuXHRcdFx0XHRcdHdpbmRpbmcgPSBjdXJ2ZS53aW5kaW5nO1xuXHRcdFx0XHRpZiAod2luZGluZyAmJiAod2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgcHkgPj0gdmFsdWVzWzFdICYmIHB5IDw9IHZhbHVlc1s3XVxuXHRcdFx0XHRcdFx0fHwgcHkgPj0gdmFsdWVzWzddICYmIHB5IDw9IHZhbHVlc1sxXSlcblx0XHRcdFx0XHQmJiBDdXJ2ZS5zb2x2ZUN1YmljKHZhbHVlcywgMSwgcHksIHJvb3RzLCAwLCAxKSA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF07XG5cdFx0XHRcdFx0aWYgKCEoXG5cdFx0XHRcdFx0XHR0ID4gdE1heCAmJiBzdGFydENvdW50ZWQgJiYgY3VydmUubmV4dCAhPT0gY3VydmVzW2kgKyAxXVxuXHRcdFx0XHRcdFx0fHwgdCA8IHRNaW4gJiYgcHJldlQgPiB0TWF4XG5cdFx0XHRcdFx0XHRcdCYmIGN1cnZlLnByZXZpb3VzID09PSBwcmV2Q3VydmUpKSB7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCkueCxcblx0XHRcdFx0XHRcdFx0c2xvcGUgPSBDdXJ2ZS5nZXRUYW5nZW50KHZhbHVlcywgdCkueSxcblx0XHRcdFx0XHRcdFx0Y291bnRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2xvcGUpICYmICFDdXJ2ZS5pc1N0cmFpZ2h0KHZhbHVlcylcblx0XHRcdFx0XHRcdFx0XHR8fCB0IDwgdE1pbiAmJiBzbG9wZSAqIEN1cnZlLmdldFRhbmdlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJ2ZS5wcmV2aW91cy52YWx1ZXMsIDEpLnkgPCAwXG5cdFx0XHRcdFx0XHRcdFx0fHwgdCA+IHRNYXggJiYgc2xvcGUgKiBDdXJ2ZS5nZXRUYW5nZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VydmUubmV4dC52YWx1ZXMsIDApLnkgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0ZXN0Q29udGFpbnMgJiYgeCA+PSB4QmVmb3JlICYmIHggPD0geEFmdGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Kyt3aW5kTGVmdDtcblx0XHRcdFx0XHRcdFx0XHQrK3dpbmRSaWdodDtcblx0XHRcdFx0XHRcdFx0XHRjb3VudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh4IDw9IHhCZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0d2luZExlZnQgKz0gd2luZGluZztcblx0XHRcdFx0XHRcdFx0Y291bnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPj0geEFmdGVyKSB7XG5cdFx0XHRcdFx0XHRcdHdpbmRSaWdodCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0XHRjb3VudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjdXJ2ZS5wcmV2aW91cyAhPT0gY3VydmVzW2kgLSAxXSlcblx0XHRcdFx0XHRcdFx0c3RhcnRDb3VudGVkID0gdCA8IHRNaW4gJiYgY291bnRlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0XHRcdFx0cHJldlQgPSB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBNYXRoLm1heChhYnMod2luZExlZnQpLCBhYnMod2luZFJpZ2h0KSk7XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIHBhdGgxLCBwYXRoMiwgbW9ub0N1cnZlcywgb3BlcmF0aW9uKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAyZS03LFxuXHRcdFx0Y2hhaW4gPSBbXSxcblx0XHRcdHN0YXJ0ID0gc2VnbWVudCxcblx0XHRcdHRvdGFsTGVuZ3RoID0gMCxcblx0XHRcdHdpbmRpbmdTdW0gPSAwO1xuXHRcdGRvIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcblx0XHRcdFx0bGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjaGFpbi5wdXNoKHsgc2VnbWVudDogc2VnbWVudCwgY3VydmU6IGN1cnZlLCBsZW5ndGg6IGxlbmd0aCB9KTtcblx0XHRcdHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblx0XHRcdHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcblx0XHR9IHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50Ll9pbnRlcnNlY3Rpb24gJiYgc2VnbWVudCAhPT0gc3RhcnQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdG90YWxMZW5ndGggKiAoaSArIDEpIC8gNDtcblx0XHRcdGZvciAodmFyIGsgPSAwLCBtID0gY2hhaW4ubGVuZ3RoOyBrIDwgbTsgaysrKSB7XG5cdFx0XHRcdHZhciBub2RlID0gY2hhaW5ba10sXG5cdFx0XHRcdFx0Y3VydmVMZW5ndGggPSBub2RlLmxlbmd0aDtcblx0XHRcdFx0aWYgKGxlbmd0aCA8PSBjdXJ2ZUxlbmd0aCkge1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPCBlcHNpbG9uIHx8IGN1cnZlTGVuZ3RoIC0gbGVuZ3RoIDwgZXBzaWxvbilcblx0XHRcdFx0XHRcdGxlbmd0aCA9IGN1cnZlTGVuZ3RoIC8gMjtcblx0XHRcdFx0XHR2YXIgY3VydmUgPSBub2RlLmN1cnZlLFxuXHRcdFx0XHRcdFx0cGF0aCA9IGN1cnZlLl9wYXRoLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gcGF0aC5fcGFyZW50LFxuXHRcdFx0XHRcdFx0cHQgPSBjdXJ2ZS5nZXRQb2ludEF0KGxlbmd0aCksXG5cdFx0XHRcdFx0XHRob3IgPSBjdXJ2ZS5pc0hvcml6b250YWwoKTtcblx0XHRcdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0XHRcdFx0cGF0aCA9IHBhcmVudDtcblx0XHRcdFx0XHR3aW5kaW5nU3VtICs9IG9wZXJhdGlvbiA9PT0gJ3N1YnRyYWN0JyAmJiBwYXRoMlxuXHRcdFx0XHRcdFx0JiYgKHBhdGggPT09IHBhdGgxICYmIHBhdGgyLl9nZXRXaW5kaW5nKHB0LCBob3IpXG5cdFx0XHRcdFx0XHR8fCBwYXRoID09PSBwYXRoMiAmJiAhcGF0aDEuX2dldFdpbmRpbmcocHQsIGhvcikpXG5cdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdDogZ2V0V2luZGluZyhwdCwgbW9ub0N1cnZlcywgaG9yKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsZW5ndGggLT0gY3VydmVMZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciB3aW5kaW5nID0gTWF0aC5yb3VuZCh3aW5kaW5nU3VtIC8gMyk7XG5cdFx0Zm9yICh2YXIgaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0Y2hhaW5bal0uc2VnbWVudC5fd2luZGluZyA9IHdpbmRpbmc7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRpb24pIHtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdHN0YXJ0LFxuXHRcdFx0b3RoZXJTdGFydCxcblx0XHRcdG9wZXJhdG9yID0gb3BlcmF0b3JzW29wZXJhdGlvbl0sXG5cdFx0XHRvdmVybGFwV2luZGluZyA9IHtcblx0XHRcdFx0dW5pdGU6IHsgMTogMiB9LFxuXHRcdFx0XHRpbnRlcnNlY3Q6IHsgMjogMSB9XG5cdFx0XHR9W29wZXJhdGlvbl07XG5cblx0XHRmdW5jdGlvbiBpc1ZhbGlkKHNlZywgYWRqdXN0ZWQpIHtcblx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGlmICghb3BlcmF0b3IpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0dmFyIHdpbmRpbmcgPSBzZWcuX3dpbmRpbmcsXG5cdFx0XHRcdGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRpZiAoaW50ZXIgJiYgYWRqdXN0ZWQgJiYgb3ZlcmxhcFdpbmRpbmcgJiYgaW50ZXIuaXNPdmVybGFwKCkpXG5cdFx0XHRcdHdpbmRpbmcgPSBvdmVybGFwV2luZGluZ1t3aW5kaW5nXSB8fCB3aW5kaW5nO1xuXHRcdFx0cmV0dXJuIG9wZXJhdG9yKHdpbmRpbmcpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU3RhcnQoc2VnKSB7XG5cdFx0XHRyZXR1cm4gc2VnID09PSBzdGFydCB8fCBzZWcgPT09IG90aGVyU3RhcnQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluZEJlc3RJbnRlcnNlY3Rpb24oaW50ZXIsIHN0cmljdCkge1xuXHRcdFx0aWYgKCFpbnRlci5fbmV4dClcblx0XHRcdFx0cmV0dXJuIGludGVyO1xuXHRcdFx0d2hpbGUgKGludGVyKSB7XG5cdFx0XHRcdHZhciBzZWcgPSBpbnRlci5fc2VnbWVudCxcblx0XHRcdFx0XHRuZXh0U2VnID0gc2VnLmdldE5leHQoKSxcblx0XHRcdFx0XHRuZXh0SW50ZXIgPSBuZXh0U2VnLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRcdGlmIChpc1N0YXJ0KG5leHRTZWcpXG5cdFx0XHRcdFx0fHwgIXNlZy5fdmlzaXRlZCAmJiAhbmV4dFNlZy5fdmlzaXRlZFxuXHRcdFx0XHRcdCYmICghb3BlcmF0b3Jcblx0XHRcdFx0XHRcdHx8ICghc3RyaWN0IHx8IGlzVmFsaWQoc2VnKSlcblx0XHRcdFx0XHRcdCYmICghKHN0cmljdCAmJiBuZXh0SW50ZXIgJiYgbmV4dEludGVyLmlzT3ZlcmxhcCgpKVxuXHRcdFx0XHRcdFx0XHQmJiBpc1ZhbGlkKG5leHRTZWcpXG5cdFx0XHRcdFx0XHRcdHx8ICFzdHJpY3QgJiYgbmV4dEludGVyXG5cdFx0XHRcdFx0XHRcdCYmIGlzVmFsaWQobmV4dEludGVyLl9zZWdtZW50KSlcblx0XHRcdFx0XHQpKVxuXHRcdFx0XHRcdHJldHVybiBpbnRlcjtcblx0XHRcdFx0aW50ZXIgPSBpbnRlci5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbmRTdGFydFNlZ21lbnQoaW50ZXIsIG5leHQpIHtcblx0XHRcdHdoaWxlIChpbnRlcikge1xuXHRcdFx0XHR2YXIgc2VnID0gaW50ZXIuX3NlZ21lbnQ7XG5cdFx0XHRcdGlmIChpc1N0YXJ0KHNlZykpXG5cdFx0XHRcdFx0cmV0dXJuIHNlZztcblx0XHRcdFx0aW50ZXIgPSBpbnRlcltuZXh0ID8gJ19uZXh0JyA6ICdfcHJldiddO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHBhdGggPSBudWxsLFxuXHRcdFx0XHRmaW5pc2hlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKCFpc1ZhbGlkKHNlZywgdHJ1ZSkpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0c3RhcnQgPSBvdGhlclN0YXJ0ID0gbnVsbDtcblx0XHRcdHdoaWxlICghZmluaXNoZWQpIHtcblx0XHRcdFx0dmFyIGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBwYXRoICYmIHNlZy5faGFuZGxlSW47XG5cdFx0XHRcdGludGVyID0gaW50ZXIgJiYgKGZpbmRCZXN0SW50ZXJzZWN0aW9uKGludGVyLCB0cnVlKVxuXHRcdFx0XHRcdFx0fHwgZmluZEJlc3RJbnRlcnNlY3Rpb24oaW50ZXIsIGZhbHNlKSkgfHwgaW50ZXI7XG5cdFx0XHRcdHZhciBvdGhlciA9IGludGVyICYmIGludGVyLl9zZWdtZW50O1xuXHRcdFx0XHRpZiAob3RoZXIgJiYgaXNWYWxpZChvdGhlcikpXG5cdFx0XHRcdFx0c2VnID0gb3RoZXI7XG5cdFx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQpIHtcblx0XHRcdFx0XHRmaW5pc2hlZCA9IGlzU3RhcnQoc2VnKTtcblx0XHRcdFx0XHRpZiAoIWZpbmlzaGVkICYmIGludGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmaW5kU3RhcnRTZWdtZW50KGludGVyLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHR8fCBmaW5kU3RhcnRTZWdtZW50KGludGVyLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRpZiAoZm91bmQpIHtcblx0XHRcdFx0XHRcdFx0c2VnID0gZm91bmQ7XG5cdFx0XHRcdFx0XHRcdGZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0XHRzdGFydCA9IHNlZztcblx0XHRcdFx0XHRvdGhlclN0YXJ0ID0gb3RoZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGF0aC5hZGQobmV3IFNlZ21lbnQoc2VnLl9wb2ludCwgaGFuZGxlSW4sIHNlZy5faGFuZGxlT3V0KSk7XG5cdFx0XHRcdHNlZy5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHRcdHNlZyA9IHNlZy5nZXROZXh0KCk7XG5cdFx0XHRcdGZpbmlzaGVkID0gaXNTdGFydChzZWcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpbmlzaGVkKSB7XG5cdFx0XHRcdHBhdGguZmlyc3RTZWdtZW50LnNldEhhbmRsZUluKHNlZy5faGFuZGxlSW4pO1xuXHRcdFx0XHRwYXRoLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdH0gZWxzZSBpZiAocGF0aCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdCb29sZWFuIG9wZXJhdGlvbiByZXN1bHRlZCBpbiBvcGVuIHBhdGgnLFxuXHRcdFx0XHRcdFx0J3NlZ21lbnRzID0nLCBwYXRoLl9zZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0XHQnbGVuZ3RoID0nLCBwYXRoLmdldExlbmd0aCgpKTtcblx0XHRcdFx0cGF0aCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF0aCAmJiAocGF0aC5fc2VnbWVudHMubGVuZ3RoID4gOFxuXHRcdFx0XHRcdHx8ICFOdW1lcmljYWwuaXNaZXJvKHBhdGguZ2V0QXJlYSgpKSkpIHtcblx0XHRcdFx0cGF0aHMucHVzaChwYXRoKTtcblx0XHRcdFx0cGF0aCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2dldFdpbmRpbmc6IGZ1bmN0aW9uKHBvaW50LCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcblx0XHRcdHJldHVybiBnZXRXaW5kaW5nKHBvaW50LCB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG5cdFx0XHRcdFx0aG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKTtcblx0XHR9LFxuXG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAndW5pdGUnKTtcblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ2ludGVyc2VjdCcpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdzdWJ0cmFjdCcpO1xuXHRcdH0sXG5cblx0XHRleGNsdWRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ2V4Y2x1ZGUnKTtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gZmluaXNoQm9vbGVhbihHcm91cCxcblx0XHRcdFx0XHRbdGhpcy5zdWJ0cmFjdChwYXRoKSwgdGhpcy5pbnRlcnNlY3QocGF0aCldLFxuXHRcdFx0XHRcdHRoaXMsIHBhdGgsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRyZXNvbHZlQ3Jvc3NpbmdzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjcm9zc2luZ3MgPSB0aGlzLmdldENyb3NzaW5ncygpO1xuXHRcdFx0aWYgKCFjcm9zc2luZ3MubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdGRpdmlkZUxvY2F0aW9ucyhDdXJ2ZUxvY2F0aW9uLmV4cGFuZChjcm9zc2luZ3MpKTtcblx0XHRcdHZhciBwYXRocyA9IHRoaXMuX2NoaWxkcmVuIHx8IFt0aGlzXSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHBhdGhzW2ldLl9zZWdtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmluaXNoQm9vbGVhbihDb21wb3VuZFBhdGgsIHRyYWNlUGF0aHMoc2VnbWVudHMpLFxuXHRcdFx0XHRcdHRoaXMsIG51bGwsIGZhbHNlKTtcblx0XHR9XG5cdH07XG59KTtcblxuUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzLFxuXHRcdFx0cHJldkN1cnZlO1xuXG5cdFx0ZnVuY3Rpb24gaW5zZXJ0Q3VydmUodikge1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzddLFxuXHRcdFx0XHRjdXJ2ZSA9IHtcblx0XHRcdFx0XHR2YWx1ZXM6IHYsXG5cdFx0XHRcdFx0d2luZGluZzogeTAgPT09IHkxXG5cdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdDogeTAgPiB5MVxuXHRcdFx0XHRcdFx0XHQ/IC0xXG5cdFx0XHRcdFx0XHRcdDogMSxcblx0XHRcdFx0XHRwcmV2aW91czogcHJldkN1cnZlLFxuXHRcdFx0XHRcdG5leHQ6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdGlmIChwcmV2Q3VydmUpXG5cdFx0XHRcdHByZXZDdXJ2ZS5uZXh0ID0gY3VydmU7XG5cdFx0XHRtb25vQ3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQ3VydmUodikge1xuXHRcdFx0aWYgKEN1cnZlLmdldExlbmd0aCh2KSA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzNdLFxuXHRcdFx0XHR5MiA9IHZbNV0sXG5cdFx0XHRcdHkzID0gdls3XTtcblx0XHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHRcdGluc2VydEN1cnZlKHYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGEgPSAzICogKHkxIC0geTIpIC0geTAgKyB5Myxcblx0XHRcdFx0XHRiID0gMiAqICh5MCArIHkyKSAtIDQgKiB5MSxcblx0XHRcdFx0XHRjID0geTEgLSB5MCxcblx0XHRcdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdFx0XHRuID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCB0TWluLCB0TWF4KTtcblx0XHRcdFx0aWYgKG4gPT09IDApIHtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZSh2KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyb290cy5zb3J0KCk7XG5cdFx0XHRcdFx0dmFyIHQgPSByb290c1swXSxcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYsIHQpO1xuXHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHRpZiAobiA+IDEpIHtcblx0XHRcdFx0XHRcdHQgPSAocm9vdHNbMV0gLSB0KSAvICgxIC0gdCk7XG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZShwYXJ0c1sxXSwgdCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbW9ub0N1cnZlcykge1xuXHRcdFx0bW9ub0N1cnZlcyA9IHRoaXMuX21vbm9DdXJ2ZXMgPSBbXTtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRoYW5kbGVDdXJ2ZShjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCkpO1xuXHRcdFx0aWYgKCF0aGlzLl9jbG9zZWQgJiYgc2VnbWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR2YXIgcDEgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQsXG5cdFx0XHRcdFx0cDIgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0cDF4ID0gcDEuX3gsIHAxeSA9IHAxLl95LFxuXHRcdFx0XHRcdHAyeCA9IHAyLl94LCBwMnkgPSBwMi5feTtcblx0XHRcdFx0aGFuZGxlQ3VydmUoW3AxeCwgcDF5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAyeCwgcDJ5XSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9ub0N1cnZlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBmaXJzdCA9IG1vbm9DdXJ2ZXNbMF0sXG5cdFx0XHRcdFx0bGFzdCA9IG1vbm9DdXJ2ZXNbbW9ub0N1cnZlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0Zmlyc3QucHJldmlvdXMgPSBsYXN0O1xuXHRcdFx0XHRsYXN0Lm5leHQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1vbm9DdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0SW50ZXJpb3JQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0aWYgKCF0aGlzLmNvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuX2dldE1vbm9DdXJ2ZXMoKSxcblx0XHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdFx0eSA9IHBvaW50LnksXG5cdFx0XHRcdHhJbnRlcmNlcHRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGN1cnZlc1tpXS52YWx1ZXM7XG5cdFx0XHRcdGlmICgoY3VydmVzW2ldLndpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHkgPj0gdmFsdWVzWzFdICYmIHkgPD0gdmFsdWVzWzddXG5cdFx0XHRcdFx0XHR8fCB5ID49IHZhbHVlc1s3XSAmJiB5IDw9IHZhbHVlc1sxXSlcblx0XHRcdFx0XHRcdCYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCB5LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRcdFx0eEludGVyY2VwdHMucHVzaChDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHJvb3RzW2pdKS54KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeEludGVyY2VwdHMubGVuZ3RoID4gMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHBvaW50LnggPSAoeEludGVyY2VwdHNbMF0gKyB4SW50ZXJjZXB0c1sxXSkgLyAyO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cmVvcmllbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0Q2xvY2t3aXNlKHRydWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuQ29tcG91bmRQYXRoLmluamVjdCh7XG5cdF9nZXRNb25vQ3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdG1vbm9DdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBjaGlsZHJlbltpXS5fZ2V0TW9ub0N1cnZlcygpKTtcblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGIuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpIC0gYS5nZXRCb3VuZHMoKS5nZXRBcmVhKCk7XG5cdFx0fSk7XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdFx0dmFyIGNsb2Nrd2lzZSA9IGNoaWxkcmVuWzBdLmlzQ2xvY2t3aXNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBjaGlsZHJlbltpXS5nZXRJbnRlcmlvclBvaW50KCksXG5cdFx0XHRcdFx0Y291bnRlcnMgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0aWYgKGNoaWxkcmVuW2pdLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRcdGNvdW50ZXJzKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0Q2xvY2t3aXNlKGNvdW50ZXJzICUgMiA9PT0gMCAmJiBjbG9ja3dpc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbnZhciBQYXRoSXRlcmF0b3IgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVyYXRvcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgbWF4UmVjdXJzaW9uLCB0b2xlcmFuY2UsIG1hdHJpeCkge1xuXHRcdHZhciBjdXJ2ZXMgPSBbXSxcblx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRsZW5ndGggPSAwLFxuXHRcdFx0bWluRGlmZmVyZW5jZSA9IDEgLyAobWF4UmVjdXJzaW9uIHx8IDMyKSxcblx0XHRcdHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnRzWzBdLFxuXHRcdFx0c2VnbWVudDI7XG5cblx0XHRmdW5jdGlvbiBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFZhbHVlcyhzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCk7XG5cdFx0XHRjdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHRjb21wdXRlUGFydHMoY3VydmUsIHNlZ21lbnQxLl9pbmRleCwgMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZVBhcnRzKGN1cnZlLCBpbmRleCwgbWluVCwgbWF4VCkge1xuXHRcdFx0aWYgKChtYXhUIC0gbWluVCkgPiBtaW5EaWZmZXJlbmNlXG5cdFx0XHRcdFx0JiYgIUN1cnZlLmlzRmxhdEVub3VnaChjdXJ2ZSwgdG9sZXJhbmNlIHx8IDAuMjUpKSB7XG5cdFx0XHRcdHZhciBzcGxpdCA9IEN1cnZlLnN1YmRpdmlkZShjdXJ2ZSwgMC41KSxcblx0XHRcdFx0XHRoYWxmVCA9IChtaW5UICsgbWF4VCkgLyAyO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoc3BsaXRbMF0sIGluZGV4LCBtaW5ULCBoYWxmVCk7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhzcGxpdFsxXSwgaW5kZXgsIGhhbGZULCBtYXhUKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcblx0XHRcdFx0XHR5ID0gY3VydmVbN10gLSBjdXJ2ZVsxXSxcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRpZiAoZGlzdCA+IDFlLTYpIHtcblx0XHRcdFx0XHRsZW5ndGggKz0gZGlzdDtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHtcblx0XHRcdFx0XHRcdG9mZnNldDogbGVuZ3RoLFxuXHRcdFx0XHRcdFx0dmFsdWU6IG1heFQsXG5cdFx0XHRcdFx0XHRpbmRleDogaW5kZXhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzZWdtZW50MiA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKTtcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudDI7XG5cdFx0fVxuXHRcdGlmIChwYXRoLl9jbG9zZWQpXG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50Miwgc2VnbWVudHNbMF0pO1xuXG5cdFx0dGhpcy5jdXJ2ZXMgPSBjdXJ2ZXM7XG5cdFx0dGhpcy5wYXJ0cyA9IHBhcnRzO1xuXHRcdHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR2YXIgaSwgaiA9IHRoaXMuaW5kZXg7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0aSA9IGo7XG5cdFx0XHRpZiAoaiA9PSAwIHx8IHRoaXMucGFydHNbLS1qXS5vZmZzZXQgPCBvZmZzZXQpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRmb3IgKHZhciBsID0gdGhpcy5wYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcblx0XHRcdGlmIChwYXJ0Lm9mZnNldCA+PSBvZmZzZXQpIHtcblx0XHRcdFx0dGhpcy5pbmRleCA9IGk7XG5cdFx0XHRcdHZhciBwcmV2ID0gdGhpcy5wYXJ0c1tpIC0gMV07XG5cdFx0XHRcdHZhciBwcmV2VmFsID0gcHJldiAmJiBwcmV2LmluZGV4ID09IHBhcnQuaW5kZXggPyBwcmV2LnZhbHVlIDogMCxcblx0XHRcdFx0XHRwcmV2TGVuID0gcHJldiA/IHByZXYub2Zmc2V0IDogMDtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2YWx1ZTogcHJldlZhbCArIChwYXJ0LnZhbHVlIC0gcHJldlZhbClcblx0XHRcdFx0XHRcdCogKG9mZnNldCAtIHByZXZMZW4pIC8gKHBhcnQub2Zmc2V0IC0gcHJldkxlbiksXG5cdFx0XHRcdFx0aW5kZXg6IHBhcnQuaW5kZXhcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHBhcnQgPSB0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoIC0gMV07XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbHVlOiAxLFxuXHRcdFx0aW5kZXg6IHBhcnQuaW5kZXhcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXdQYXJ0OiBmdW5jdGlvbihjdHgsIGZyb20sIHRvKSB7XG5cdFx0ZnJvbSA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQoZnJvbSk7XG5cdFx0dG8gPSB0aGlzLmdldFBhcmFtZXRlckF0KHRvKTtcblx0XHRmb3IgKHZhciBpID0gZnJvbS5pbmRleDsgaSA8PSB0by5pbmRleDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBDdXJ2ZS5nZXRQYXJ0KHRoaXMuY3VydmVzW2ldLFxuXHRcdFx0XHRcdGkgPT0gZnJvbS5pbmRleCA/IGZyb20udmFsdWUgOiAwLFxuXHRcdFx0XHRcdGkgPT0gdG8uaW5kZXggPyB0by52YWx1ZSA6IDEpO1xuXHRcdFx0aWYgKGkgPT0gZnJvbS5pbmRleClcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJ2ZVswXSwgY3VydmVbMV0pO1xuXHRcdFx0Y3R4LmJlemllckN1cnZlVG8uYXBwbHkoY3R4LCBjdXJ2ZS5zbGljZSgyKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goQ3VydmUuZXZhbHVhdGVNZXRob2RzLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIHdlaWdodGVkKSB7XG5cdFx0XHR2YXIgcGFyYW0gPSB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS52YWx1ZSwgd2VpZ2h0ZWQpO1xuXHRcdH07XG5cdH0sIHt9KVxuKTtcblxudmFyIFBhdGhGaXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIGVycm9yKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzID0gW10sXG5cdFx0XHRzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0cHJldjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudHNbaV0ucG9pbnQuY2xvbmUoKTtcblx0XHRcdGlmICghcHJldiB8fCAhcHJldi5lcXVhbHMocG9pbnQpKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50KTtcblx0XHRcdFx0cHJldiA9IHBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChwYXRoLl9jbG9zZWQpIHtcblx0XHRcdHRoaXMuY2xvc2VkID0gdHJ1ZTtcblx0XHRcdHBvaW50cy51bnNoaWZ0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzFdKTtcblx0XHR9XG5cblx0XHR0aGlzLmVycm9yID0gZXJyb3I7XG5cdH0sXG5cblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzID0gbGVuZ3RoID4gMFxuXHRcdFx0XHRcdD8gW25ldyBTZWdtZW50KHBvaW50c1swXSldIDogW107XG5cdFx0aWYgKGxlbmd0aCA+IDEpXG5cdFx0XHR0aGlzLmZpdEN1YmljKDAsIGxlbmd0aCAtIDEsXG5cdFx0XHRcdHBvaW50c1sxXS5zdWJ0cmFjdChwb2ludHNbMF0pLm5vcm1hbGl6ZSgpLFxuXHRcdFx0XHRwb2ludHNbbGVuZ3RoIC0gMl0uc3VidHJhY3QocG9pbnRzW2xlbmd0aCAtIDFdKS5ub3JtYWxpemUoKSk7XG5cblx0XHRpZiAodGhpcy5jbG9zZWQpIHtcblx0XHRcdHNlZ21lbnRzLnNoaWZ0KCk7XG5cdFx0XHRzZWdtZW50cy5wb3AoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2VnbWVudHM7XG5cdH0sXG5cblx0Zml0Q3ViaWM6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB0YW4xLCB0YW4yKSB7XG5cdFx0aWYgKGxhc3QgLSBmaXJzdCA9PSAxKSB7XG5cdFx0XHR2YXIgcHQxID0gdGhpcy5wb2ludHNbZmlyc3RdLFxuXHRcdFx0XHRwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcblx0XHRcdFx0ZGlzdCA9IHB0MS5nZXREaXN0YW5jZShwdDIpIC8gMztcblx0XHRcdHRoaXMuYWRkQ3VydmUoW3B0MSwgcHQxLmFkZCh0YW4xLm5vcm1hbGl6ZShkaXN0KSksXG5cdFx0XHRcdFx0cHQyLmFkZCh0YW4yLm5vcm1hbGl6ZShkaXN0KSksIHB0Ml0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdVByaW1lID0gdGhpcy5jaG9yZExlbmd0aFBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCksXG5cdFx0XHRtYXhFcnJvciA9IE1hdGgubWF4KHRoaXMuZXJyb3IsIHRoaXMuZXJyb3IgKiB0aGlzLmVycm9yKSxcblx0XHRcdHNwbGl0LFxuXHRcdFx0cGFyYW1ldGVyc0luT3JkZXIgPSB0cnVlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDQ7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZW5lcmF0ZUJlemllcihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKTtcblx0XHRcdHZhciBtYXggPSB0aGlzLmZpbmRNYXhFcnJvcihmaXJzdCwgbGFzdCwgY3VydmUsIHVQcmltZSk7XG5cdFx0XHRpZiAobWF4LmVycm9yIDwgdGhpcy5lcnJvciAmJiBwYXJhbWV0ZXJzSW5PcmRlcikge1xuXHRcdFx0XHR0aGlzLmFkZEN1cnZlKGN1cnZlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3BsaXQgPSBtYXguaW5kZXg7XG5cdFx0XHRpZiAobWF4LmVycm9yID49IG1heEVycm9yKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHBhcmFtZXRlcnNJbk9yZGVyID0gdGhpcy5yZXBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCwgdVByaW1lLCBjdXJ2ZSk7XG5cdFx0XHRtYXhFcnJvciA9IG1heC5lcnJvcjtcblx0XHR9XG5cdFx0dmFyIFYxID0gdGhpcy5wb2ludHNbc3BsaXQgLSAxXS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdF0pLFxuXHRcdFx0VjIgPSB0aGlzLnBvaW50c1tzcGxpdF0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXQgKyAxXSksXG5cdFx0XHR0YW5DZW50ZXIgPSBWMS5hZGQoVjIpLmRpdmlkZSgyKS5ub3JtYWxpemUoKTtcblx0XHR0aGlzLmZpdEN1YmljKGZpcnN0LCBzcGxpdCwgdGFuMSwgdGFuQ2VudGVyKTtcblx0XHR0aGlzLmZpdEN1YmljKHNwbGl0LCBsYXN0LCB0YW5DZW50ZXIubmVnYXRlKCksIHRhbjIpO1xuXHR9LFxuXG5cdGFkZEN1cnZlOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHZhciBwcmV2ID0gdGhpcy5zZWdtZW50c1t0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHRcdHByZXYuc2V0SGFuZGxlT3V0KGN1cnZlWzFdLnN1YnRyYWN0KGN1cnZlWzBdKSk7XG5cdFx0dGhpcy5zZWdtZW50cy5wdXNoKFxuXHRcdFx0XHRuZXcgU2VnbWVudChjdXJ2ZVszXSwgY3VydmVbMl0uc3VidHJhY3QoY3VydmVbM10pKSk7XG5cdH0sXG5cblx0Z2VuZXJhdGVCZXppZXI6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0cHQxID0gdGhpcy5wb2ludHNbZmlyc3RdLFxuXHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRDID0gW1swLCAwXSwgWzAsIDBdXSxcblx0XHRcdFggPSBbMCwgMF07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxhc3QgLSBmaXJzdCArIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB1ID0gdVByaW1lW2ldLFxuXHRcdFx0XHR0ID0gMSAtIHUsXG5cdFx0XHRcdGIgPSAzICogdSAqIHQsXG5cdFx0XHRcdGIwID0gdCAqIHQgKiB0LFxuXHRcdFx0XHRiMSA9IGIgKiB0LFxuXHRcdFx0XHRiMiA9IGIgKiB1LFxuXHRcdFx0XHRiMyA9IHUgKiB1ICogdSxcblx0XHRcdFx0YTEgPSB0YW4xLm5vcm1hbGl6ZShiMSksXG5cdFx0XHRcdGEyID0gdGFuMi5ub3JtYWxpemUoYjIpLFxuXHRcdFx0XHR0bXAgPSB0aGlzLnBvaW50c1tmaXJzdCArIGldXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0MS5tdWx0aXBseShiMCArIGIxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QocHQyLm11bHRpcGx5KGIyICsgYjMpKTtcblx0XHRcdENbMF1bMF0gKz0gYTEuZG90KGExKTtcblx0XHRcdENbMF1bMV0gKz0gYTEuZG90KGEyKTtcblx0XHRcdENbMV1bMF0gPSBDWzBdWzFdO1xuXHRcdFx0Q1sxXVsxXSArPSBhMi5kb3QoYTIpO1xuXHRcdFx0WFswXSArPSBhMS5kb3QodG1wKTtcblx0XHRcdFhbMV0gKz0gYTIuZG90KHRtcCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRldEMwQzEgPSBDWzBdWzBdICogQ1sxXVsxXSAtIENbMV1bMF0gKiBDWzBdWzFdLFxuXHRcdFx0YWxwaGExLCBhbHBoYTI7XG5cdFx0aWYgKE1hdGguYWJzKGRldEMwQzEpID4gZXBzaWxvbikge1xuXHRcdFx0dmFyIGRldEMwWFx0PSBDWzBdWzBdICogWFsxXVx0LSBDWzFdWzBdICogWFswXSxcblx0XHRcdFx0ZGV0WEMxXHQ9IFhbMF1cdCAgKiBDWzFdWzFdIC0gWFsxXVx0ICAqIENbMF1bMV07XG5cdFx0XHRhbHBoYTEgPSBkZXRYQzEgLyBkZXRDMEMxO1xuXHRcdFx0YWxwaGEyID0gZGV0QzBYIC8gZGV0QzBDMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGMwID0gQ1swXVswXSArIENbMF1bMV0sXG5cdFx0XHRcdGMxID0gQ1sxXVswXSArIENbMV1bMV07XG5cdFx0XHRpZiAoTWF0aC5hYnMoYzApID4gZXBzaWxvbikge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBYWzBdIC8gYzA7XG5cdFx0XHR9IGVsc2UgaWYgKE1hdGguYWJzKGMxKSA+IGVwc2lsb24pIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gWFsxXSAvIGMxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2VnTGVuZ3RoID0gcHQyLmdldERpc3RhbmNlKHB0MSksXG5cdFx0XHRlcHMgPSBlcHNpbG9uICogc2VnTGVuZ3RoLFxuXHRcdFx0aGFuZGxlMSxcblx0XHRcdGhhbmRsZTI7XG5cdFx0aWYgKGFscGhhMSA8IGVwcyB8fCBhbHBoYTIgPCBlcHMpIHtcblx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaW5lID0gcHQyLnN1YnRyYWN0KHB0MSk7XG5cdFx0XHRoYW5kbGUxID0gdGFuMS5ub3JtYWxpemUoYWxwaGExKTtcblx0XHRcdGhhbmRsZTIgPSB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpO1xuXHRcdFx0aWYgKGhhbmRsZTEuZG90KGxpbmUpIC0gaGFuZGxlMi5kb3QobGluZSkgPiBzZWdMZW5ndGggKiBzZWdMZW5ndGgpIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcblx0XHRcdFx0aGFuZGxlMSA9IGhhbmRsZTIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBbcHQxLCBwdDEuYWRkKGhhbmRsZTEgfHwgdGFuMS5ub3JtYWxpemUoYWxwaGExKSksXG5cdFx0XHRcdHB0Mi5hZGQoaGFuZGxlMiB8fCB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpKSwgcHQyXTtcblx0fSxcblxuXHRyZXBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHUsIGN1cnZlKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdGhpcy5maW5kUm9vdChjdXJ2ZSwgdGhpcy5wb2ludHNbaV0sIHVbaSAtIGZpcnN0XSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gdS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICh1W2ldIDw9IHVbaSAtIDFdKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGZpbmRSb290OiBmdW5jdGlvbihjdXJ2ZSwgcG9pbnQsIHUpIHtcblx0XHR2YXIgY3VydmUxID0gW10sXG5cdFx0XHRjdXJ2ZTIgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAyOyBpKyspIHtcblx0XHRcdGN1cnZlMVtpXSA9IGN1cnZlW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZVtpXSkubXVsdGlwbHkoMyk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuXHRcdFx0Y3VydmUyW2ldID0gY3VydmUxW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZTFbaV0pLm11bHRpcGx5KDIpO1xuXHRcdH1cblx0XHR2YXIgcHQgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1KSxcblx0XHRcdHB0MSA9IHRoaXMuZXZhbHVhdGUoMiwgY3VydmUxLCB1KSxcblx0XHRcdHB0MiA9IHRoaXMuZXZhbHVhdGUoMSwgY3VydmUyLCB1KSxcblx0XHRcdGRpZmYgPSBwdC5zdWJ0cmFjdChwb2ludCksXG5cdFx0XHRkZiA9IHB0MS5kb3QocHQxKSArIGRpZmYuZG90KHB0Mik7XG5cdFx0aWYgKE1hdGguYWJzKGRmKSA8IDFlLTYpXG5cdFx0XHRyZXR1cm4gdTtcblx0XHRyZXR1cm4gdSAtIGRpZmYuZG90KHB0MSkgLyBkZjtcblx0fSxcblxuXHRldmFsdWF0ZTogZnVuY3Rpb24oZGVncmVlLCBjdXJ2ZSwgdCkge1xuXHRcdHZhciB0bXAgPSBjdXJ2ZS5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDw9IGRlZ3JlZTsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8PSBkZWdyZWUgLSBpOyBqKyspIHtcblx0XHRcdFx0dG1wW2pdID0gdG1wW2pdLm11bHRpcGx5KDEgLSB0KS5hZGQodG1wW2ogKyAxXS5tdWx0aXBseSh0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0bXBbMF07XG5cdH0sXG5cblx0Y2hvcmRMZW5ndGhQYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0KSB7XG5cdFx0dmFyIHUgPSBbMF07XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHVbaSAtIGZpcnN0IC0gMV1cblx0XHRcdFx0XHQrIHRoaXMucG9pbnRzW2ldLmdldERpc3RhbmNlKHRoaXMucG9pbnRzW2kgLSAxXSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxLCBtID0gbGFzdCAtIGZpcnN0OyBpIDw9IG07IGkrKykge1xuXHRcdFx0dVtpXSAvPSB1W21dO1xuXHRcdH1cblx0XHRyZXR1cm4gdTtcblx0fSxcblxuXHRmaW5kTWF4RXJyb3I6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdSkge1xuXHRcdHZhciBpbmRleCA9IE1hdGguZmxvb3IoKGxhc3QgLSBmaXJzdCArIDEpIC8gMiksXG5cdFx0XHRtYXhEaXN0ID0gMDtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG5cdFx0XHR2YXIgUCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHVbaSAtIGZpcnN0XSk7XG5cdFx0XHR2YXIgdiA9IFAuc3VidHJhY3QodGhpcy5wb2ludHNbaV0pO1xuXHRcdFx0dmFyIGRpc3QgPSB2LnggKiB2LnggKyB2LnkgKiB2Lnk7XG5cdFx0XHRpZiAoZGlzdCA+PSBtYXhEaXN0KSB7XG5cdFx0XHRcdG1heERpc3QgPSBkaXN0O1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRlcnJvcjogbWF4RGlzdCxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgVGV4dEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1RleHRJdGVtJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y29udGVudDogbnVsbFxuXHR9LFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUZXh0SXRlbShhcmcpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJyc7XG5cdFx0dGhpcy5fbGluZXMgPSBbXTtcblx0XHR2YXIgaGFzUHJvcHMgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0JiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2luaXRpYWxpemUoaGFzUHJvcHMgJiYgYXJnLCAhaGFzUHJvcHMgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbiBfY2xvbmUoY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KSB7XG5cdFx0Y29weS5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuXHRcdHJldHVybiBfY2xvbmUuYmFzZS5jYWxsKHRoaXMsIGNvcHksIGluc2VydCwgaW5jbHVkZU1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0c2V0Q29udGVudDogZnVuY3Rpb24oY29udGVudCkge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJyArIGNvbnRlbnQ7XG5cdFx0dGhpcy5fbGluZXMgPSB0aGlzLl9jb250ZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9tZyk7XG5cdFx0dGhpcy5fY2hhbmdlZCgyNjUpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRnZXRDaGFyYWN0ZXJTdHlsZTogJyNnZXRTdHlsZScsXG5cdHNldENoYXJhY3RlclN0eWxlOiAnI3NldFN0eWxlJyxcblxuXHRnZXRQYXJhZ3JhcGhTdHlsZTogJyNnZXRTdHlsZScsXG5cdHNldFBhcmFncmFwaFN0eWxlOiAnI3NldFN0eWxlJ1xufSk7XG5cbnZhciBQb2ludFRleHQgPSBUZXh0SXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludFRleHQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50VGV4dCgpIHtcblx0XHRUZXh0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IFBvaW50VGV4dChJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHNoYWRvd0NvbG9yID0gY3R4LnNoYWRvd0NvbG9yO1xuXHRcdGN0eC5mb250ID0gc3R5bGUuZ2V0Rm9udFN0eWxlKCk7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7XG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZVRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKDAsIGxlYWRpbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdG51bUxpbmVzID0gbGluZXMubGVuZ3RoLFxuXHRcdFx0anVzdGlmaWNhdGlvbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKSxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHR3aWR0aCA9IHRoaXMuZ2V0VmlldygpLmdldFRleHRXaWR0aChzdHlsZS5nZXRGb250U3R5bGUoKSwgbGluZXMpLFxuXHRcdFx0eCA9IDA7XG5cdFx0aWYgKGp1c3RpZmljYXRpb24gIT09ICdsZWZ0Jylcblx0XHRcdHggLT0gd2lkdGggLyAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicgPyAyOiAxKTtcblx0XHR2YXIgYm91bmRzID0gbmV3IFJlY3RhbmdsZSh4LFxuXHRcdFx0XHRcdG51bUxpbmVzID8gLSAwLjc1ICogbGVhZGluZyA6IDAsXG5cdFx0XHRcdFx0d2lkdGgsIG51bUxpbmVzICogbGVhZGluZyk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgYm91bmRzKSA6IGJvdW5kcztcblx0fVxufSk7XG5cbnZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHR5cGVzID0ge1xuXHRcdGdyYXk6IFsnZ3JheSddLFxuXHRcdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRcdGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG5cdFx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRcdGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuXHR9O1xuXG5cdHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG5cdFx0Y29sb3JDYWNoZSA9IHt9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhcXHd7MSwyfSkoXFx3ezEsMn0pKFxcd3sxLDJ9KSQvKSxcblx0XHRcdGNvbXBvbmVudHM7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRjb21wb25lbnRzID0gWzAsIDAsIDBdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDFcblx0XHRcdFx0XHRcdD8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXnJnYmE/XFwoKC4qKVxcKSQvKSkge1xuXHRcdFx0Y29tcG9uZW50cyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICtjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gaSA8IDMgPyB2YWx1ZSAvIDI1NSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddO1xuXHRcdFx0aWYgKCFjYWNoZWQpIHtcblx0XHRcdFx0aWYgKCFjb2xvckN0eCkge1xuXHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ10gPSBbXG5cdFx0XHRcdFx0ZGF0YVswXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMl0gLyAyNTVcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjYWNoZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHR2YXIgaHNiSW5kaWNlcyA9IFtcblx0XHRbMCwgMywgMV0sXG5cdFx0WzIsIDAsIDFdLFxuXHRcdFsxLCAwLCAzXSxcblx0XHRbMSwgMiwgMF0sXG5cdFx0WzMsIDEsIDBdLFxuXHRcdFswLCAxLCAyXVxuXHRdO1xuXG5cdHZhciBjb252ZXJ0ZXJzID0ge1xuXHRcdCdyZ2ItaHNiJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGggPSBkZWx0YSA9PT0gMCA/IDBcblx0XHRcdFx0XHQ6XHQoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0Olx0XHRcdCAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwO1xuXHRcdFx0cmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG5cdFx0fSxcblxuXHRcdCdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuXHRcdFx0aCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihoKSxcblx0XHRcdFx0ZiA9IGggLSBpLFxuXHRcdFx0XHRpID0gaHNiSW5kaWNlc1tpXSxcblx0XHRcdFx0diA9IFtcblx0XHRcdFx0XHRiLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiBmKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogKDEgLSBmKSlcblx0XHRcdFx0XTtcblx0XHRcdHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG5cdFx0fSxcblxuXHRcdCdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcblx0XHRcdFx0aCA9IGFjaHJvbWF0aWMgPyAwXG5cdFx0XHRcdFx0Olx0KCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDpcdFx0XHQgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCxcblx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMixcblx0XHRcdFx0cyA9IGFjaHJvbWF0aWMgPyAwIDogbCA8IDAuNVxuXHRcdFx0XHRcdFx0PyBkZWx0YSAvIChtYXggKyBtaW4pXG5cdFx0XHRcdFx0XHQ6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHRcdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0XHR9LFxuXG5cdFx0J2hzbC1yZ2InOiBmdW5jdGlvbihoLCBzLCBsKSB7XG5cdFx0XHRoID0gKCgoaCAvIDM2MCkgJSAxKSArIDEpICUgMTtcblx0XHRcdGlmIChzID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdFx0dmFyIHQzcyA9IFsgaCArIDEgLyAzLCBoLCBoIC0gMSAvIDMgXSxcblx0XHRcdFx0dDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxuXHRcdFx0XHR0MSA9IDIgKiBsIC0gdDIsXG5cdFx0XHRcdGMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB0MyA9IHQzc1tpXTtcblx0XHRcdFx0aWYgKHQzIDwgMCkgdDMgKz0gMTtcblx0XHRcdFx0aWYgKHQzID4gMSkgdDMgLT0gMTtcblx0XHRcdFx0Y1tpXSA9IDYgKiB0MyA8IDFcblx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzXG5cdFx0XHRcdFx0OiAyICogdDMgPCAxXG5cdFx0XHRcdFx0XHQ/IHQyXG5cdFx0XHRcdFx0XHQ6IDMgKiB0MyA8IDJcblx0XHRcdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDMpICogNlxuXHRcdFx0XHRcdFx0XHQ6IHQxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JheSc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHJldHVybiBbciAqIDAuMjk4OSArIGcgKiAwLjU4NyArIGIgKiAwLjExNF07XG5cdFx0fSxcblxuXHRcdCdncmF5LXJnYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbZywgZywgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzbCc6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmFkaWVudC1yZ2InOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmFkaWVudCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2godHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0XHRjb21wb25lbnRQYXJzZXJzW3R5cGVdID0gW107XG5cdFx0QmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0aGFzT3ZlcmxhcCA9IC9eKGh1ZXxzYXR1cmF0aW9uKSQvLnRlc3QobmFtZSksXG5cdFx0XHRcdHBhcnNlciA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV1baW5kZXhdID0gbmFtZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdD8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29tcG9uZW50c1swXTtcblx0XHRcdFx0XHRcdHZhbHVlID0gR3JhZGllbnQucmVhZChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0OiBhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5fcmVtb3ZlT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0PyBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gMCA6IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0fHwgaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50c1tpbmRleF1cblx0XHRcdFx0XHRcdDogdGhpcy5fY29udmVydCh0eXBlKVtpbmRleF07XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gdHlwZVxuXHRcdFx0XHRcdFx0JiYgIShoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdH07XG5cdFx0fSwgdGhpcyk7XG5cdH0sIHtcblx0XHRfY2xhc3M6ICdDb2xvcicsXG5cdFx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbG9yKGFyZykge1xuXHRcdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRyZWFkID0gMCxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0Y29tcG9uZW50cyxcblx0XHRcdFx0YWxwaGEsXG5cdFx0XHRcdHZhbHVlcztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0YXJncyA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1swXTtcblx0XHRcdH1cblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcblx0XHRcdFx0dHlwZSA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1sxXTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmc7XG5cdFx0XHRcdFx0YWxwaGEgPSBhcmdzWzJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3MsIDEpO1xuXHRcdFx0XHRcdGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gYXJnc1xuXHRcdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBhcmdcblx0XHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRcdFx0aWYgKCF0eXBlKVxuXHRcdFx0XHRcdFx0dHlwZSA9IHZhbHVlcy5sZW5ndGggPj0gM1xuXHRcdFx0XHRcdFx0XHRcdD8gJ3JnYidcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5Jztcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gdHlwZXNbdHlwZV0ubGVuZ3RoO1xuXHRcdFx0XHRcdGFscGhhID0gdmFsdWVzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHQ/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApXG5cdFx0XHRcdFx0XHRcdDogMTtcblx0XHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IGxlbmd0aClcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHNsaWNlLmNhbGwodmFsdWVzLCAwLCBsZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dHlwZSA9ICdyZ2InO1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBmcm9tQ1NTKGFyZyk7XG5cdFx0XHRcdFx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGlmIChhcmcuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gYXJnLl90eXBlO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuX2FscGhhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gYXJncztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdodWUnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHQ/ICdsaWdodG5lc3MnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2hzbCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdoc2InXG5cdFx0XHRcdFx0XHRcdDogJ2dyYWRpZW50JyBpbiBhcmcgfHwgJ3N0b3BzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdHx8ICdyYWRpYWwnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyAnZ3JheSdcblx0XHRcdFx0XHRcdFx0XHRcdDogJ3JnYic7XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdFx0XHRwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGFyZ1twcm9wZXJ0aWVzW2ldXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwgJiYgaSA9PT0gMCAmJiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiAnc3RvcHMnIGluIGFyZykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RvcHM6IGFyZy5zdG9wcyxcblx0XHRcdFx0XHRcdFx0XHRcdHJhZGlhbDogYXJnLnJhZGlhbFxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5hbHBoYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkICYmIHR5cGUpXG5cdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcblx0XHRcdHRoaXMuX2lkID0gVUlELmdldChDb2xvcik7XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0dmFyIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3RoaXMuX3R5cGVdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlcyAmJiB2YWx1ZXNbaV0pO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cztcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0aGlzLl90eXBlXTtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0XHR9LFxuXG5cdFx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLmdldENvbXBvbmVudHMoKTtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShcblx0XHRcdFx0XHQvXihncmF5fHJnYikkLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IGNvbXBvbmVudHNcblx0XHRcdFx0XHRcdDogW3RoaXMuX3R5cGVdLmNvbmNhdChjb21wb25lbnRzKSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9LFxuXG5cdFx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCg2NSk7XG5cdFx0fSxcblxuXHRcdF9jb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgY29udmVydGVyO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKVxuXHRcdFx0XHRcdDogKGNvbnZlcnRlciA9IGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctJyArIHR5cGVdKVxuXHRcdFx0XHRcdFx0PyBjb252ZXJ0ZXIuYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cylcblx0XHRcdFx0XHRcdDogY29udmVydGVyc1sncmdiLScgKyB0eXBlXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLXJnYiddLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cykpO1xuXHRcdH0sXG5cblx0XHRjb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIHRoaXMuX2NvbnZlcnQodHlwZSksIHRoaXMuX2FscGhhKTtcblx0XHR9LFxuXG5cdFx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0XHR9LFxuXG5cdFx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR9LFxuXG5cdFx0Z2V0Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2godGhpcy5fYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdFx0fSxcblxuXHRcdGdldEFscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsID8gdGhpcy5fYWxwaGEgOiAxO1xuXHRcdH0sXG5cblx0XHRzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGEgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1pbihNYXRoLm1heChhbHBoYSwgMCksIDEpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH0sXG5cblx0XHRoYXNBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbDtcblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0dmFyIGNvbCA9IEJhc2UuaXNQbGFpblZhbHVlKGNvbG9yLCB0cnVlKVxuXHRcdFx0XHRcdD8gQ29sb3IucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdFx0OiBjb2xvcjtcblx0XHRcdHJldHVybiBjb2wgPT09IHRoaXMgfHwgY29sICYmIHRoaXMuX2NsYXNzID09PSBjb2wuX2NsYXNzXG5cdFx0XHRcdFx0JiYgdGhpcy5fdHlwZSA9PT0gY29sLl90eXBlXG5cdFx0XHRcdFx0JiYgdGhpcy5fYWxwaGEgPT09IGNvbC5fYWxwaGFcblx0XHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9jb21wb25lbnRzLCBjb2wuX2NvbXBvbmVudHMpXG5cdFx0XHRcdFx0fHwgZmFsc2U7XG5cdFx0fSxcblxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcHJvcGVydGllcyxcblx0XHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdFx0aXNHcmFkaWVudCA9IHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcsXG5cdFx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX2NvbXBvbmVudHNbaV07XG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2gocHJvcGVydGllc1tpXSArICc6ICdcblx0XHRcdFx0XHRcdFx0KyAoaXNHcmFkaWVudCA/IHZhbHVlIDogZi5udW1iZXIodmFsdWUpKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcblx0XHRcdFx0cGFydHMucHVzaCgnYWxwaGE6ICcgKyBmLm51bWJlcih0aGlzLl9hbHBoYSkpO1xuXHRcdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0XHR9LFxuXG5cdFx0dG9DU1M6IGZ1bmN0aW9uKGhleCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdFx0YWxwaGEgPSBoZXggfHwgdGhpcy5fYWxwaGEgPT0gbnVsbCA/IDEgOiB0aGlzLl9hbHBoYTtcblx0XHRcdGZ1bmN0aW9uIGNvbnZlcnQodmFsKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCh2YWwgPCAwID8gMCA6IHZhbCA+IDEgPyAxIDogdmFsKSAqIDI1NSk7XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRzID0gW1xuXHRcdFx0XHRjb252ZXJ0KGNvbXBvbmVudHNbMF0pLFxuXHRcdFx0XHRjb252ZXJ0KGNvbXBvbmVudHNbMV0pLFxuXHRcdFx0XHRjb252ZXJ0KGNvbXBvbmVudHNbMl0pXG5cdFx0XHRdO1xuXHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0Y29tcG9uZW50cy5wdXNoKGFscGhhIDwgMCA/IDAgOiBhbHBoYSk7XG5cdFx0XHRyZXR1cm4gaGV4XG5cdFx0XHRcdFx0PyAnIycgKyAoKDEgPDwgMjQpICsgKGNvbXBvbmVudHNbMF0gPDwgMTYpXG5cdFx0XHRcdFx0XHQrIChjb21wb25lbnRzWzFdIDw8IDgpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHNbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKVxuXHRcdFx0XHRcdDogKGNvbXBvbmVudHMubGVuZ3RoID09IDQgPyAncmdiYSgnIDogJ3JnYignKVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzLmpvaW4oJywnKSArICcpJztcblx0XHR9LFxuXG5cdFx0dG9DYW52YXNTdHlsZTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRpZiAodGhpcy5fY2FudmFzU3R5bGUpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZTtcblx0XHRcdGlmICh0aGlzLl90eXBlICE9PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSB0aGlzLnRvQ1NTKCk7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGdyYWRpZW50ID0gY29tcG9uZW50c1swXSxcblx0XHRcdFx0c3RvcHMgPSBncmFkaWVudC5fc3RvcHMsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbXBvbmVudHNbMV0sXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29tcG9uZW50c1syXSxcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQ7XG5cdFx0XHRpZiAoZ3JhZGllbnQuX3JhZGlhbCkge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gZGVzdGluYXRpb24uZ2V0RGlzdGFuY2Uob3JpZ2luKSxcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBjb21wb25lbnRzWzNdO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0dmFyIHZlY3RvciA9IGhpZ2hsaWdodC5zdWJ0cmFjdChvcmlnaW4pO1xuXHRcdFx0XHRcdGlmICh2ZWN0b3IuZ2V0TGVuZ3RoKCkgPiByYWRpdXMpXG5cdFx0XHRcdFx0XHRoaWdobGlnaHQgPSBvcmlnaW4uYWRkKHZlY3Rvci5ub3JtYWxpemUocmFkaXVzIC0gMC4xKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0YXJ0ID0gaGlnaGxpZ2h0IHx8IG9yaWdpbjtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSxcblx0XHRcdFx0XHRcdDAsIG9yaWdpbi54LCBvcmlnaW4ueSwgcmFkaXVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG9yaWdpbi54LCBvcmlnaW4ueSxcblx0XHRcdFx0XHRcdGRlc3RpbmF0aW9uLngsIGRlc3RpbmF0aW9uLnkpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXTtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AuX3JhbXBQb2ludCxcblx0XHRcdFx0XHRcdHN0b3AuX2NvbG9yLnRvQ2FudmFzU3R5bGUoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSBjYW52YXNHcmFkaWVudDtcblx0XHR9LFxuXG5cdFx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0X3R5cGVzOiB0eXBlcyxcblxuXHRcdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKHJhbmRvbSgpLCByYW5kb20oKSwgcmFuZG9tKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdGFkZDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKyBiO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKiBiO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC8gYjtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uKG9wZXJhdG9yLCBuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0Y29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRjb21wb25lbnRzMiA9IGNvbG9yLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzMS5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNvbXBvbmVudHMyW2ldID0gb3BlcmF0b3IoY29tcG9uZW50czFbaV0sIGNvbXBvbmVudHMyW2ldKTtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50czIsXG5cdFx0XHRcdFx0dGhpcy5fYWxwaGEgIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IG9wZXJhdG9yKHRoaXMuX2FscGhhLCBjb2xvci5nZXRBbHBoYSgpKVxuXHRcdFx0XHRcdFx0XHQ6IG51bGwpO1xuXHRcdH07XG5cdH0sIHtcblx0fSk7XG59KTtcblxudmFyIEdyYWRpZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnQoc3RvcHMsIHJhZGlhbCkge1xuXHRcdHRoaXMuX2lkID0gVUlELmdldCgpO1xuXHRcdGlmIChzdG9wcyAmJiB0aGlzLl9zZXQoc3RvcHMpKVxuXHRcdFx0c3RvcHMgPSByYWRpYWwgPSBudWxsO1xuXHRcdGlmICghdGhpcy5fc3RvcHMpXG5cdFx0XHR0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG5cdFx0aWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKVxuXHRcdFx0dGhpcy5zZXRSYWRpYWwodHlwZW9mIHJhZGlhbCA9PT0gJ3N0cmluZycgJiYgcmFkaWFsID09PSAncmFkaWFsJ1xuXHRcdFx0XHRcdHx8IHJhZGlhbCB8fCBmYWxzZSk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9vd25lcnNbaV0uX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0aWYgKCF0aGlzLl9vd25lcnMpXG5cdFx0XHR0aGlzLl9vd25lcnMgPSBbXTtcblx0XHR0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG5cdH0sXG5cblx0X3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpZiAodGhpcy5fb3duZXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhpcy5fb3duZXJzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0b3BzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcywgdGhpcy5fcmFkaWFsKTtcblx0fSxcblxuXHRnZXRTdG9wczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0b3BzO1xuXHR9LFxuXG5cdHNldFN0b3BzOiBmdW5jdGlvbihzdG9wcykge1xuXHRcdGlmICh0aGlzLnN0b3BzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fc3RvcHNbaV0uX293bmVyID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoc3RvcHMubGVuZ3RoIDwgMilcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnR3JhZGllbnQgc3RvcCBsaXN0IG5lZWRzIHRvIGNvbnRhaW4gYXQgbGVhc3QgdHdvIHN0b3BzLicpO1xuXHRcdHRoaXMuX3N0b3BzID0gR3JhZGllbnRTdG9wLnJlYWRBbGwoc3RvcHMsIDAsIHsgY2xvbmU6IHRydWUgfSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdG9wID0gdGhpcy5fc3RvcHNbaV07XG5cdFx0XHRzdG9wLl9vd25lciA9IHRoaXM7XG5cdFx0XHRpZiAoc3RvcC5fZGVmYXVsdFJhbXApXG5cdFx0XHRcdHN0b3Auc2V0UmFtcFBvaW50KGkgLyAobCAtIDEpKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldFJhZGlhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGlhbDtcblx0fSxcblxuXHRzZXRSYWRpYWw6IGZ1bmN0aW9uKHJhZGlhbCkge1xuXHRcdHRoaXMuX3JhZGlhbCA9IHJhZGlhbDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihncmFkaWVudCkge1xuXHRcdGlmIChncmFkaWVudCA9PT0gdGhpcylcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGlmIChncmFkaWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gZ3JhZGllbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3N0b3BzLmxlbmd0aCA9PT0gZ3JhZGllbnQuX3N0b3BzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9zdG9wc1tpXS5lcXVhbHMoZ3JhZGllbnQuX3N0b3BzW2ldKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEdyYWRpZW50U3RvcCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnRTdG9wJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudFN0b3AoYXJnMCwgYXJnMSkge1xuXHRcdGlmIChhcmcwKSB7XG5cdFx0XHR2YXIgY29sb3IsIHJhbXBQb2ludDtcblx0XHRcdGlmIChhcmcxID09PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHRjb2xvciA9IGFyZzBbMF07XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzBbMV07XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuY29sb3IpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwLmNvbG9yO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcwLnJhbXBQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMDtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0Q29sb3IoY29sb3IpO1xuXHRcdFx0dGhpcy5zZXRSYW1wUG9pbnQocmFtcFBvaW50KTtcblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgR3JhZGllbnRTdG9wKHRoaXMuX2NvbG9yLmNsb25lKCksIHRoaXMuX3JhbXBQb2ludCk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fY29sb3IsIHRoaXMuX3JhbXBQb2ludF0sIG9wdGlvbnMsIHRydWUsXG5cdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCg2NSk7XG5cdH0sXG5cblx0Z2V0UmFtcFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFtcFBvaW50O1xuXHR9LFxuXG5cdHNldFJhbXBQb2ludDogZnVuY3Rpb24ocmFtcFBvaW50KSB7XG5cdFx0dGhpcy5fZGVmYXVsdFJhbXAgPSByYW1wUG9pbnQgPT0gbnVsbDtcblx0XHR0aGlzLl9yYW1wUG9pbnQgPSByYW1wUG9pbnQgfHwgMDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0Q29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb2xvcjtcblx0fSxcblxuXHRzZXRDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHR0aGlzLl9jb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5fY29sb3IgPT09IGNvbG9yKVxuXHRcdFx0dGhpcy5fY29sb3IgPSBjb2xvci5jbG9uZSgpO1xuXHRcdHRoaXMuX2NvbG9yLl9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3RvcCkge1xuXHRcdHJldHVybiBzdG9wID09PSB0aGlzIHx8IHN0b3AgJiYgdGhpcy5fY2xhc3MgPT09IHN0b3AuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX2NvbG9yLmVxdWFscyhzdG9wLl9jb2xvcilcblx0XHRcdFx0JiYgdGhpcy5fcmFtcFBvaW50ID09IHN0b3AuX3JhbXBQb2ludFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBTdHlsZSA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGRlZmF1bHRzID0ge1xuXHRcdGZpbGxDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHN0cm9rZUNvbG9yOiB1bmRlZmluZWQsXG5cdFx0c3Ryb2tlV2lkdGg6IDEsXG5cdFx0c3Ryb2tlQ2FwOiAnYnV0dCcsXG5cdFx0c3Ryb2tlSm9pbjogJ21pdGVyJyxcblx0XHRzdHJva2VTY2FsaW5nOiB0cnVlLFxuXHRcdG1pdGVyTGltaXQ6IDEwLFxuXHRcdGRhc2hPZmZzZXQ6IDAsXG5cdFx0ZGFzaEFycmF5OiBbXSxcblx0XHR3aW5kaW5nUnVsZTogJ25vbnplcm8nLFxuXHRcdHNoYWRvd0NvbG9yOiB1bmRlZmluZWQsXG5cdFx0c2hhZG93Qmx1cjogMCxcblx0XHRzaGFkb3dPZmZzZXQ6IG5ldyBQb2ludCgpLFxuXHRcdHNlbGVjdGVkQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG5cdFx0Zm9udFdlaWdodDogJ25vcm1hbCcsXG5cdFx0Zm9udFNpemU6IDEyLFxuXHRcdGZvbnQ6ICdzYW5zLXNlcmlmJyxcblx0XHRsZWFkaW5nOiBudWxsLFxuXHRcdGp1c3RpZmljYXRpb246ICdsZWZ0J1xuXHR9O1xuXG5cdHZhciBmbGFncyA9IHtcblx0XHRzdHJva2VXaWR0aDogOTcsXG5cdFx0c3Ryb2tlQ2FwOiA5Nyxcblx0XHRzdHJva2VKb2luOiA5Nyxcblx0XHRzdHJva2VTY2FsaW5nOiAxMDUsXG5cdFx0bWl0ZXJMaW1pdDogOTcsXG5cdFx0Zm9udEZhbWlseTogOSxcblx0XHRmb250V2VpZ2h0OiA5LFxuXHRcdGZvbnRTaXplOiA5LFxuXHRcdGZvbnQ6IDksXG5cdFx0bGVhZGluZzogOSxcblx0XHRqdXN0aWZpY2F0aW9uOiA5XG5cdH07XG5cblx0dmFyIGl0ZW0gPSB7IGJlYW5zOiB0cnVlIH0sXG5cdFx0ZmllbGRzID0ge1xuXHRcdFx0X2RlZmF1bHRzOiBkZWZhdWx0cyxcblx0XHRcdF90ZXh0RGVmYXVsdHM6IG5ldyBCYXNlKGRlZmF1bHRzLCB7XG5cdFx0XHRcdGZpbGxDb2xvcjogbmV3IENvbG9yKClcblx0XHRcdH0pLFxuXHRcdFx0YmVhbnM6IHRydWVcblx0XHR9O1xuXG5cdEJhc2UuZWFjaChkZWZhdWx0cywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdHZhciBpc0NvbG9yID0gL0NvbG9yJC8udGVzdChrZXkpLFxuXHRcdFx0aXNQb2ludCA9IGtleSA9PT0gJ3NoYWRvd09mZnNldCcsXG5cdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRmbGFnID0gZmxhZ3Nba2V5XSxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydCxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydDtcblxuXHRcdGZpZWxkc1tzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbjtcblx0XHRcdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwXG5cdFx0XHRcdFx0JiYgIShvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0Y2hpbGRyZW5baV0uX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG9sZCA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAob2xkICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChpc0NvbG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkKVxuXHRcdFx0XHRcdFx0XHRvbGQuX293bmVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUuX293bmVyKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0dmFsdWUuX293bmVyID0gb3duZXI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKG93bmVyKVxuXHRcdFx0XHRcdFx0b3duZXIuX2NoYW5nZWQoZmxhZyB8fCA2NSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZmllbGRzW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdHZhbHVlO1xuXHRcdFx0aWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgX2RvbnRNZXJnZVxuXHRcdFx0XHRcdHx8IG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY2xvbmUpXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGN0b3IgPSBpc0NvbG9yID8gQ29sb3IgOiBpc1BvaW50ID8gUG9pbnQgOiBudWxsO1xuXHRcdFx0XHRcdGlmIChjdG9yICYmICEodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IGN0b3IpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlID0gY3Rvci5yZWFkKFt2YWx1ZV0sIDAsXG5cdFx0XHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSwgY2xvbmU6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgaXNDb2xvcilcblx0XHRcdFx0XHRcdFx0dmFsdWUuX293bmVyID0gb3duZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZFZhbHVlID0gY2hpbGRyZW5baV0uX3N0eWxlW2dldF0oKTtcblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNoaWxkVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjaGlsZFZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0aXRlbVtnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0eWxlW2dldF0oX2RvbnRNZXJnZSk7XG5cdFx0fTtcblxuXHRcdGl0ZW1bc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9zdHlsZVtzZXRdKHZhbHVlKTtcblx0XHR9O1xuXHR9KTtcblxuXHRJdGVtLmluamVjdChpdGVtKTtcblx0cmV0dXJuIGZpZWxkcztcbn0sIHtcblx0X2NsYXNzOiAnU3R5bGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN0eWxlKHN0eWxlLCBfb3duZXIsIF9wcm9qZWN0KSB7XG5cdFx0dGhpcy5fdmFsdWVzID0ge307XG5cdFx0dGhpcy5fb3duZXIgPSBfb3duZXI7XG5cdFx0dGhpcy5fcHJvamVjdCA9IF9vd25lciAmJiBfb3duZXIuX3Byb2plY3QgfHwgX3Byb2plY3QgfHwgcGFwZXIucHJvamVjdDtcblx0XHRpZiAoX293bmVyIGluc3RhbmNlb2YgVGV4dEl0ZW0pXG5cdFx0XHR0aGlzLl9kZWZhdWx0cyA9IHRoaXMuX3RleHREZWZhdWx0cztcblx0XHRpZiAoc3R5bGUpXG5cdFx0XHR0aGlzLnNldChzdHlsZSk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHZhciBpc1N0eWxlID0gc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSxcblx0XHRcdHZhbHVlcyA9IGlzU3R5bGUgPyBzdHlsZS5fdmFsdWVzIDogc3R5bGU7XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuXHRcdFx0XHRpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG5cdFx0XHRcdFx0dGhpc1trZXldID0gdmFsdWUgJiYgaXNTdHlsZSAmJiB2YWx1ZS5jbG9uZVxuXHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmNsb25lKCkgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0cmV0dXJuIHN0eWxlID09PSB0aGlzIHx8IHN0eWxlICYmIHRoaXMuX2NsYXNzID09PSBzdHlsZS5fY2xhc3Ncblx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fdmFsdWVzLCBzdHlsZS5fdmFsdWVzKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldEZpbGxDb2xvcigpO1xuXHR9LFxuXG5cdGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRTdHJva2VDb2xvcigpICYmIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSA+IDA7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFNoYWRvd0NvbG9yKCkgJiYgdGhpcy5nZXRTaGFkb3dCbHVyKCkgPiAwO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0LmdldFZpZXcoKTtcblx0fSxcblxuXHRnZXRGb250U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRGb250V2VpZ2h0KClcblx0XHRcdFx0KyAnICcgKyBmb250U2l6ZSArICgvW2Etel0vaS50ZXN0KGZvbnRTaXplICsgJycpID8gJyAnIDogJ3B4ICcpXG5cdFx0XHRcdCsgdGhpcy5nZXRGb250RmFtaWx5KCk7XG5cdH0sXG5cblx0Z2V0Rm9udDogJyNnZXRGb250RmFtaWx5Jyxcblx0c2V0Rm9udDogJyNzZXRGb250RmFtaWx5JyxcblxuXHRnZXRMZWFkaW5nOiBmdW5jdGlvbiBnZXRMZWFkaW5nKCkge1xuXHRcdHZhciBsZWFkaW5nID0gZ2V0TGVhZGluZy5iYXNlLmNhbGwodGhpcyksXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcblx0XHRpZiAoL3B0fGVtfCV8cHgvLnRlc3QoZm9udFNpemUpKVxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldFZpZXcoKS5nZXRQaXhlbFNpemUoZm9udFNpemUpO1xuXHRcdHJldHVybiBsZWFkaW5nICE9IG51bGwgPyBsZWFkaW5nIDogZm9udFNpemUgKiAxLjI7XG5cdH1cblxufSk7XG5cbnZhciBEb21FbGVtZW50ID0gbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHNldCwgdmFsdWUpIHtcblx0XHR2YXIgcHJlZml4ZXMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01veicsICdtcycsICdvJ10sXG5cdFx0XHRzdWZmaXggPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0dmFyIHByZWZpeCA9IHByZWZpeGVzW2ldLFxuXHRcdFx0XHRrZXkgPSBwcmVmaXggPyBwcmVmaXggKyBzdWZmaXggOiBuYW1lO1xuXHRcdFx0aWYgKGtleSBpbiBlbCkge1xuXHRcdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdFx0ZWxba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBlbFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0U3R5bGVzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsICYmIGVsLm5vZGVUeXBlICE9PSA5ID8gZWwub3duZXJEb2N1bWVudCA6IGVsLFxuXHRcdFx0XHR2aWV3ID0gZG9jICYmIGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdHJldHVybiB2aWV3ICYmIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuXHRcdH0sXG5cblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdGJvZHkgPSBkb2MuYm9keSxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRcdHJlY3Q7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlY3QgPSB7IGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSByZWN0LmxlZnQgLSAoaHRtbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwKSxcblx0XHRcdFx0eSA9IHJlY3QudG9wIC0gKGh0bWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDApO1xuXHRcdFx0aWYgKCF2aWV3cG9ydCkge1xuXHRcdFx0XHR2YXIgdmlldyA9IGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdFx0eCArPSB2aWV3LnBhZ2VYT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRcdHkgKz0gdmlldy5wYWdlWU9mZnNldCB8fCBodG1sLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHR9LFxuXG5cdFx0Z2V0Vmlld3BvcnRCb3VuZHM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0dmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLFxuXHRcdFx0XHR2aWV3LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCxcblx0XHRcdFx0dmlldy5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdmlld3BvcnQpLmdldFBvaW50KCk7XG5cdFx0fSxcblxuXHRcdGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpLmdldFNpemUoKTtcblx0XHR9LFxuXG5cdFx0aXNJbnZpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRTaXplKGVsKS5lcXVhbHMobmV3IFNpemUoMCwgMCkpO1xuXHRcdH0sXG5cblx0XHRpc0luVmlldzogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiAhRG9tRWxlbWVudC5pc0ludmlzaWJsZShlbClcblx0XHRcdFx0XHQmJiBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsKS5pbnRlcnNlY3RzKFxuXHRcdFx0XHRcdFx0RG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpKTtcblx0XHR9LFxuXG5cdFx0Z2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gaGFuZGxlUHJlZml4KGVsLCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0c2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbmFtZSlcblx0XHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIGtleSwgdHJ1ZSwgbmFtZVtrZXldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZVByZWZpeChlbCwgbmFtZSwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbnZhciBEb21FdmVudCA9IHtcblx0YWRkOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuXHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwb3MgPSBldmVudC50YXJnZXRUb3VjaGVzXG5cdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGhcblx0XHRcdFx0XHQ/IGV2ZW50LnRhcmdldFRvdWNoZXNbMF1cblx0XHRcdFx0XHQ6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG5cdFx0XHRcdDogZXZlbnQ7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdHBvcy5wYWdlWCB8fCBwb3MuY2xpZW50WCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuXHRcdFx0cG9zLnBhZ2VZIHx8IHBvcy5jbGllbnRZICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0VGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudDtcblx0fSxcblxuXHRnZXRSZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRvRWxlbWVudDtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGV2ZW50LCB0YXJnZXQpIHtcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0UG9pbnQoZXZlbnQpLnN1YnRyYWN0KERvbUVsZW1lbnQuZ2V0T2Zmc2V0KFxuXHRcdFx0XHR0YXJnZXQgfHwgRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KSkpO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fVxufTtcblxuRG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbmF0aXZlUmVxdWVzdCA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQod2luZG93LCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXG5cdFx0cmVxdWVzdGVkID0gZmFsc2UsXG5cdFx0Y2FsbGJhY2tzID0gW10sXG5cdFx0Zm9jdXNlZCA9IHRydWUsXG5cdFx0dGltZXI7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdGZvY3VzZWQgPSB0cnVlO1xuXHRcdH0sXG5cdFx0Ymx1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb2N1c2VkID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBoYW5kbGVDYWxsYmFja3MoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGVudHJ5ID0gY2FsbGJhY2tzW2ldLFxuXHRcdFx0XHRmdW5jID0gZW50cnlbMF0sXG5cdFx0XHRcdGVsID0gZW50cnlbMV07XG5cdFx0XHRpZiAoIWVsIHx8IChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShlbCwgJ2tlZXBhbGl2ZScpID09ICd0cnVlJ1xuXHRcdFx0XHRcdHx8IGZvY3VzZWQpICYmIERvbUVsZW1lbnQuaXNJblZpZXcoZWwpKSB7XG5cdFx0XHRcdGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGZ1bmMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmIChjYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuXHRcdGNhbGxiYWNrcy5wdXNoKFtjYWxsYmFjaywgZWxlbWVudF0pO1xuXHRcdGlmIChuYXRpdmVSZXF1ZXN0KSB7XG5cdFx0XHRpZiAoIXJlcXVlc3RlZCkge1xuXHRcdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdFx0XHRcdHJlcXVlc3RlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghdGltZXIpIHtcblx0XHRcdHRpbWVyID0gc2V0SW50ZXJ2YWwoaGFuZGxlQ2FsbGJhY2tzLCAxMDAwIC8gNjApO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRfY2xhc3M6ICdWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHR0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXHRcdHZhciBzaXplO1xuXHRcdGlmICghdGhpcy5fcGl4ZWxSYXRpbylcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXHRcdHRoaXMuX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0aWYgKHRoaXMuX2lkID09IG51bGwpXG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCA9ICd2aWV3LScgKyBWaWV3Ll9pZCsrKTtcblx0XHREb21FdmVudC5hZGQoZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0dmFyIG5vbmUgPSAnbm9uZSc7XG5cdFx0RG9tRWxlbWVudC5zZXRQcmVmaXhlZChlbGVtZW50LnN0eWxlLCB7XG5cdFx0XHR1c2VyU2VsZWN0OiBub25lLFxuXHRcdFx0dG91Y2hBY3Rpb246IG5vbmUsXG5cdFx0XHR0b3VjaENhbGxvdXQ6IG5vbmUsXG5cdFx0XHRjb250ZW50Wm9vbWluZzogbm9uZSxcblx0XHRcdHVzZXJEcmFnOiBub25lLFxuXHRcdFx0dGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0U2l6ZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudFtuYW1lXSB8fCBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKSwgMTApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRDYW52YXNTaXplKCkge1xuXHRcdFx0dmFyIHNpemUgPSBEb21FbGVtZW50LmdldFNpemUoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gc2l6ZS5pc05hTigpIHx8IHNpemUuaXNaZXJvKClcblx0XHRcdFx0XHQ/IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKVxuXHRcdFx0XHRcdDogc2l6ZTtcblx0XHR9O1xuXG5cdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzID0ge1xuXHRcdFx0XHRyZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoYXQuc2V0Vmlld1NpemUoZ2V0Q2FudmFzU2l6ZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHRoaXMuX3NldFZpZXdTaXplKHNpemUgPSBnZXRDYW52YXNTaXplKCkpO1xuXHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAnc3RhdHMnKVxuXHRcdFx0XHQmJiB0eXBlb2YgU3RhdHMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aGlzLl9zdGF0cyA9IG5ldyBTdGF0cygpO1xuXHRcdFx0dmFyIHN0YXRzID0gdGhpcy5fc3RhdHMuZG9tRWxlbWVudCxcblx0XHRcdFx0c3R5bGUgPSBzdGF0cy5zdHlsZSxcblx0XHRcdFx0b2Zmc2V0ID0gRG9tRWxlbWVudC5nZXRPZmZzZXQoZWxlbWVudCk7XG5cdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRzdHlsZS5sZWZ0ID0gb2Zmc2V0LnggKyAncHgnO1xuXHRcdFx0c3R5bGUudG9wID0gb2Zmc2V0LnkgKyAncHgnO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cyk7XG5cdFx0fVxuXHRcdFZpZXcuX3ZpZXdzLnB1c2godGhpcyk7XG5cdFx0Vmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dGhpcy5fdmlld1NpemUgPSBzaXplO1xuXHRcdCh0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCkpLl9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fem9vbSA9IDE7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRoaXM7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHRoaXMuX2ZyYW1lSXRlbUNvdW50ID0gMDtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJvamVjdClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAoVmlldy5fZm9jdXNlZCA9PT0gdGhpcylcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSBudWxsO1xuXHRcdFZpZXcuX3ZpZXdzLnNwbGljZShWaWV3Ll92aWV3cy5pbmRleE9mKHRoaXMpLCAxKTtcblx0XHRkZWxldGUgVmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXTtcblx0XHRpZiAodGhpcy5fcHJvamVjdC5fdmlldyA9PT0gdGhpcylcblx0XHRcdHRoaXMuX3Byb2plY3QuX3ZpZXcgPSBudWxsO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHREb21FdmVudC5yZW1vdmUod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMpO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLm9mZignZnJhbWUnKTtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9ldmVudHM6IEJhc2UuZWFjaChbJ29uUmVzaXplJywgJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlTW92ZSddLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnQodHlwZSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5pbnN0YWxsRXZlbnQodHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0b25GcmFtZToge1xuXHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0KSxcblxuXHRfYW5pbWF0ZTogZmFsc2UsXG5cdF90aW1lOiAwLFxuXHRfY291bnQ6IDAsXG5cblx0X3JlcXVlc3RGcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdERvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX3JlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKCF0aGF0Ll9hbmltYXRlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0RnJhbWUoKTtcblx0XHRcdHRoYXQuX2hhbmRsZUZyYW1lKCk7XG5cdFx0fSwgdGhpcy5fZWxlbWVudCk7XG5cdFx0dGhpcy5fcmVxdWVzdGVkID0gdHJ1ZTtcblx0fSxcblxuXHRfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwLFxuXHRcdFx0ZGVsdGEgPSB0aGlzLl9iZWZvcmUgPyBub3cgLSB0aGlzLl9iZWZvcmUgOiAwO1xuXHRcdHRoaXMuX2JlZm9yZSA9IG5vdztcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gdHJ1ZTtcblx0XHR0aGlzLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2Uoe1xuXHRcdFx0ZGVsdGE6IGRlbHRhLFxuXHRcdFx0dGltZTogdGhpcy5fdGltZSArPSBkZWx0YSxcblx0XHRcdGNvdW50OiB0aGlzLl9jb3VudCsrXG5cdFx0fSkpO1xuXHRcdGlmICh0aGlzLl9zdGF0cylcblx0XHRcdHRoaXMuX3N0YXRzLnVwZGF0ZSgpO1xuXHRcdHRoaXMuX2hhbmRsaW5nRnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oaXRlbSwgYW5pbWF0ZSkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2ZyYW1lSXRlbXM7XG5cdFx0aWYgKGFuaW1hdGUpIHtcblx0XHRcdGl0ZW1zW2l0ZW0uX2lkXSA9IHtcblx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0dGltZTogMCxcblx0XHRcdFx0Y291bnQ6IDBcblx0XHRcdH07XG5cdFx0XHRpZiAoKyt0aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMSlcblx0XHRcdFx0dGhpcy5vbignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGl0ZW1zW2l0ZW0uX2lkXTtcblx0XHRcdGlmICgtLXRoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAwKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlRnJhbWVJdGVtczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2ZyYW1lSXRlbXMpIHtcblx0XHRcdHZhciBlbnRyeSA9IHRoaXMuX2ZyYW1lSXRlbXNbaV07XG5cdFx0XHRlbnRyeS5pdGVtLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2UoZXZlbnQsIHtcblx0XHRcdFx0dGltZTogZW50cnkudGltZSArPSBldmVudC5kZWx0YSxcblx0XHRcdFx0Y291bnQ6IGVudHJ5LmNvdW50Kytcblx0XHRcdH0pKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGlmICh0aGlzLl9oYW5kbGluZ0ZyYW1lKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmICh0aGlzLl9hbmltYXRlKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVGcmFtZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHRpZiAoZmxhZ3MgJiAxKVxuXHRcdFx0dGhpcy5fcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX21hdHJpeC5jb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW8gKiA3Mjtcblx0fSxcblxuXHRnZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRWaWV3U2l6ZScpO1xuXHR9LFxuXG5cdHNldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0ZGVsdGEgPSBzaXplLnN1YnRyYWN0KHRoaXMuX3ZpZXdTaXplKTtcblx0XHRpZiAoZGVsdGEuaXNaZXJvKCkpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fdmlld1NpemUuc2V0KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHR0aGlzLl9zZXRWaWV3U2l6ZShzaXplKTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuZW1pdCgncmVzaXplJywge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGRlbHRhOiBkZWx0YVxuXHRcdH0pO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcblx0XHRlbGVtZW50LndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRlbGVtZW50LmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9tYXRyaXguaW52ZXJ0ZWQoKS5fdHJhbnNmb3JtQm91bmRzKFxuXHRcdFx0XHRcdG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIHRoaXMuX3ZpZXdTaXplKSk7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRTaXplKCk7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zY3JvbGxCeShjZW50ZXIuc3VidHJhY3QodGhpcy5nZXRDZW50ZXIoKSkpO1xuXHR9LFxuXG5cdGdldFpvb206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl96b29tO1xuXHR9LFxuXG5cdHNldFpvb206IGZ1bmN0aW9uKHpvb20pIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnNjYWxlKHpvb20gLyB0aGlzLl96b29tLFxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoKSkpO1xuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xuXHR9LFxuXG5cdGlzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIERvbUVsZW1lbnQuaXNJblZpZXcodGhpcy5fZWxlbWVudCk7XG5cdH0sXG5cblx0c2Nyb2xsQnk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5uZWdhdGUoKSkpO1xuXHR9LFxuXG5cdHBsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSB0cnVlO1xuXHRcdGlmICghdGhpcy5fcmVxdWVzdGVkKVxuXHRcdFx0dGhpcy5fcmVxdWVzdEZyYW1lKCk7XG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdHByb2plY3RUb1ZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0dmlld1RvUHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9XG5cbn0sIHtcblx0c3RhdGljczoge1xuXHRcdF92aWV3czogW10sXG5cdFx0X3ZpZXdzQnlJZDoge30sXG5cdFx0X2lkOiAwLFxuXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbihwcm9qZWN0LCBlbGVtZW50KSB7XG5cdFx0XHRpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gbmV3IENhbnZhc1ZpZXcocHJvamVjdCwgZWxlbWVudCk7XG5cdFx0fVxuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdG9vbCxcblx0XHRwcmV2Rm9jdXMsXG5cdFx0dGVtcEZvY3VzLFxuXHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFt0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpIHtcblx0XHRyZXR1cm4gdmlldy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkIHx8ICFWaWV3Ll9mb2N1c2VkLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmlldyA9IFZpZXcuX3ZpZXdzW2ldO1xuXHRcdFx0XHRpZiAodmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KSB7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0dmFyIHRvb2wgPSB2aWV3Ll9zY29wZS50b29sO1xuXHRcdGlmICh0b29sKSB7XG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudChkcmFnZ2luZyAmJiB0b29sLnJlc3BvbmRzKCdtb3VzZWRyYWcnKVxuXHRcdFx0XHRcdD8gJ21vdXNlZHJhZycgOiAnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdFx0dmlldy51cGRhdGUoKTtcblx0XHRyZXR1cm4gdG9vbDtcblx0fVxuXG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRcdG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwO1xuXHRpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0bW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuXHRcdG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcblx0XHRtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG5cdH0gZWxzZSB7XG5cdFx0bW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuXHRcdG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuXHRcdG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXHRcdGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuXHRcdFx0XHQvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG5cdFx0XHRtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0bW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcblx0XHRcdG1vdXNldXAgKz0gJyBtb3VzZXVwJztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlld0V2ZW50cyA9IHtcblx0XHQnc2VsZWN0c3RhcnQgZHJhZ3N0YXJ0JzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkcmFnZ2luZylcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGRvY0V2ZW50cyA9IHtcblx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdFx0dGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdH0sXG5cblx0XHRzY3JvbGw6IHVwZGF0ZUZvY3VzXG5cdH07XG5cblx0dmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KSxcblx0XHRcdHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdGlmICh0b29sID0gdmlldy5fc2NvcGUudG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZpZXcudXBkYXRlKCk7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIWRyYWdnaW5nKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG5cdFx0XHRcdHByZXZGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0fSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuXHRcdFx0XHR1cGRhdGVGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0XHRpZiAoZHJhZ2dpbmcgfHwgdmlldy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdHRvb2wgPSBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCF2aWV3IHx8ICFkcmFnZ2luZylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0bG9hZDogdXBkYXRlRm9jdXNcblx0fSk7XG5cblx0dmFyIG1vdXNlRmxhZ3MgPSB7XG5cdFx0bW91c2Vkb3duOiB7XG5cdFx0XHRtb3VzZWRvd246IDEsXG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRjbGljazogMSxcblx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0fSxcblx0XHRtb3VzZXVwOiB7XG5cdFx0XHRtb3VzZXVwOiAxLFxuXHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRkb3VibGVjbGljazogMVxuXHRcdH0sXG5cdFx0bW91c2Vtb3ZlOiB7XG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRtb3VzZW1vdmU6IDEsXG5cdFx0XHRtb3VzZWVudGVyOiAxLFxuXHRcdFx0bW91c2VsZWF2ZTogMVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdF92aWV3RXZlbnRzOiB2aWV3RXZlbnRzLFxuXG5cdFx0X2hhbmRsZUV2ZW50OiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0X2luc3RhbGxFdmVudDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNvdW50ZXJzID0gdGhpcy5fZXZlbnRDb3VudGVycztcblx0XHRcdGlmIChjb3VudGVycykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncykge1xuXHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gPSAoY291bnRlcnNba2V5XSB8fCAwKVxuXHRcdFx0XHRcdFx0XHQrIChtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3VuaW5zdGFsbEV2ZW50OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgY291bnRlcnMgPSB0aGlzLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0aWYgKGNvdW50ZXJzKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKVxuXHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gLT0gbW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDA7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcblx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0XHRpZiAoc2l6ZS5pc1plcm8oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgQ2FudmFzVmlldyB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudDogJ1xuXHRcdFx0XHRcdFx0KyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdH1cblx0XHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0dGhpcy5fZXZlbnRDb3VudGVycyA9IHt9O1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGlmICghL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG5cdFx0XHR2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQodGhpcy5fY29udGV4dCxcblx0XHRcdFx0XHRcdCdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXHRcdH1cblx0XHRWaWV3LmNhbGwodGhpcywgcHJvamVjdCwgY2FudmFzKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG5cdFx0XHRwaXhlbFJhdGlvID0gdGhpcy5fcGl4ZWxSYXRpbyxcblx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG5cdFx0XHRpZiAoIVBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBpeGVsU2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcixcblx0XHRcdHBpeGVscztcblx0XHRpZiAoYnJvd3NlciAmJiBicm93c2VyLmZpcmVmb3gpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG5cdFx0XHRcdHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdHRlbXAuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuXHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKHRlbXApO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChEb21FbGVtZW50LmdldFN0eWxlcyh0ZW1wKS5mb250U2l6ZSk7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQodGVtcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdFx0Y3R4LmZvbnQgPSBzaXplICsgJyBzZXJpZic7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbHM7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0cHJldkZvbnQgPSBjdHguZm9udCxcblx0XHRcdHdpZHRoID0gMDtcblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiB3aWR0aDtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGZvcmNlKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmICghcHJvamVjdCB8fCAhZm9yY2UgJiYgIXByb2plY3QuX25lZWRzVXBkYXRlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG5cdFx0cHJvamVjdC5kcmF3KGN0eCwgdGhpcy5fbWF0cml4LCB0aGlzLl9waXhlbFJhdGlvKTtcblx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZG93blBvaW50LFxuXHRcdGxhc3RQb2ludCxcblx0XHRvdmVyUG9pbnQsXG5cdFx0ZG93bkl0ZW0sXG5cdFx0bGFzdEl0ZW0sXG5cdFx0b3Zlckl0ZW0sXG5cdFx0ZHJhZ0l0ZW0sXG5cdFx0ZGJsQ2xpY2ssXG5cdFx0Y2xpY2tUaW1lO1xuXG5cdGZ1bmN0aW9uIGNhbGxFdmVudCh2aWV3LCB0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgbGFzdFBvaW50KSB7XG5cdFx0dmFyIGl0ZW0gPSB0YXJnZXQsXG5cdFx0XHRtb3VzZUV2ZW50O1xuXG5cdFx0ZnVuY3Rpb24gY2FsbChvYmopIHtcblx0XHRcdGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdFx0aWYgKCFtb3VzZUV2ZW50KSB7XG5cdFx0XHRcdFx0bW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQgPyBwb2ludC5zdWJ0cmFjdChsYXN0UG9pbnQpIDogbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9iai5lbWl0KHR5cGUsIG1vdXNlRXZlbnQpICYmIG1vdXNlRXZlbnQuaXNTdG9wcGVkKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoY2FsbChpdGVtKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRpdGVtID0gaXRlbS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0aWYgKGNhbGwodmlldykpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIGV2ZW50KSB7XG5cdFx0XHRpZiAoIXRoaXMuX2V2ZW50Q291bnRlcnNbdHlwZV0pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0aGl0ID0gcHJvamVjdC5oaXRUZXN0KHBvaW50LCB7XG5cdFx0XHRcdFx0dG9sZXJhbmNlOiAwLFxuXHRcdFx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRcdFx0c3Ryb2tlOiB0cnVlXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRpdGVtID0gaGl0ICYmIGhpdC5pdGVtLFxuXHRcdFx0XHRzdG9wcGVkID0gZmFsc2U7XG5cdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtKTtcblx0XHRcdFx0ZGJsQ2xpY2sgPSBsYXN0SXRlbSA9PSBpdGVtICYmIChEYXRlLm5vdygpIC0gY2xpY2tUaW1lIDwgMzAwKTtcblx0XHRcdFx0ZG93bkl0ZW0gPSBsYXN0SXRlbSA9IGl0ZW07XG5cdFx0XHRcdGRvd25Qb2ludCA9IGxhc3RQb2ludCA9IG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRkcmFnSXRlbSA9ICFzdG9wcGVkICYmIGl0ZW07XG5cdFx0XHRcdHdoaWxlIChkcmFnSXRlbSAmJiAhZHJhZ0l0ZW0ucmVzcG9uZHMoJ21vdXNlZHJhZycpKVxuXHRcdFx0XHRcdGRyYWdJdGVtID0gZHJhZ0l0ZW0uX3BhcmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0sIGRvd25Qb2ludCk7XG5cdFx0XHRcdGlmIChkcmFnSXRlbSkge1xuXHRcdFx0XHRcdGlmIChsYXN0UG9pbnQgJiYgIWxhc3RQb2ludC5lcXVhbHMocG9pbnQpKVxuXHRcdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWRyYWcnLCBldmVudCwgcG9pbnQsIGRyYWdJdGVtLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludCk7XG5cdFx0XHRcdFx0aWYgKGl0ZW0gIT09IGRyYWdJdGVtKSB7XG5cdFx0XHRcdFx0XHRvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2Vtb3ZlJywgZXZlbnQsIHBvaW50LCBpdGVtLFxuXHRcdFx0XHRcdFx0XHRcdG92ZXJQb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3RvcHBlZCAmJiBpdGVtICYmIGl0ZW0gPT09IGRvd25JdGVtKSB7XG5cdFx0XHRcdFx0Y2xpY2tUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgZGJsQ2xpY2sgJiYgZG93bkl0ZW0ucmVzcG9uZHMoJ2RvdWJsZWNsaWNrJylcblx0XHRcdFx0XHRcdFx0PyAnZG91YmxlY2xpY2snIDogJ2NsaWNrJywgZXZlbnQsIGRvd25Qb2ludCwgaXRlbSk7XG5cdFx0XHRcdFx0ZGJsQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb3duSXRlbSA9IGRyYWdJdGVtID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHRpZiAoZHJhZ0l0ZW0pXG5cdFx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LFxuXHRcdFx0XHRcdFx0XHRkcmFnSXRlbSwgbGFzdFBvaW50KTtcblx0XHRcdFx0aWYgKCFzdG9wcGVkKSB7XG5cdFx0XHRcdFx0aWYgKGl0ZW0gIT09IG92ZXJJdGVtKVxuXHRcdFx0XHRcdFx0b3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0sXG5cdFx0XHRcdFx0XHRcdG92ZXJQb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdGlmIChpdGVtICE9PSBvdmVySXRlbSkge1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCwgb3Zlckl0ZW0pO1xuXHRcdFx0XHRcdG92ZXJJdGVtID0gaXRlbTtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlZW50ZXInLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0b3BwZWQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbnZhciBFdmVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEV2ZW50KGV2ZW50KSB7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHR9LFxuXG5cdGlzUHJldmVudGVkOiBmYWxzZSxcblx0aXNTdG9wcGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1ByZXZlbnRlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR0aGlzLnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0Z2V0TW9kaWZpZXJzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gS2V5Lm1vZGlmaWVycztcblx0fVxufSk7XG5cbnZhciBLZXlFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ0tleUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpIHtcblx0XHRFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR0aGlzLnR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJztcblx0XHR0aGlzLmtleSA9IGtleTtcblx0XHR0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3Rlcjtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIGtleTogJ1wiICsgdGhpcy5rZXlcblx0XHRcdFx0KyBcIicsIGNoYXJhY3RlcjogJ1wiICsgdGhpcy5jaGFyYWN0ZXJcblx0XHRcdFx0KyBcIicsIG1vZGlmaWVyczogXCIgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgXCIgfVwiO1xuXHR9XG59KTtcblxudmFyIEtleSA9IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIgc3BlY2lhbEtleXMgPSB7XG5cdFx0ODogJ2JhY2tzcGFjZScsXG5cdFx0OTogJ3RhYicsXG5cdFx0MTM6ICdlbnRlcicsXG5cdFx0MTY6ICdzaGlmdCcsXG5cdFx0MTc6ICdjb250cm9sJyxcblx0XHQxODogJ29wdGlvbicsXG5cdFx0MTk6ICdwYXVzZScsXG5cdFx0MjA6ICdjYXBzLWxvY2snLFxuXHRcdDI3OiAnZXNjYXBlJyxcblx0XHQzMjogJ3NwYWNlJyxcblx0XHQzNTogJ2VuZCcsXG5cdFx0MzY6ICdob21lJyxcblx0XHQzNzogJ2xlZnQnLFxuXHRcdDM4OiAndXAnLFxuXHRcdDM5OiAncmlnaHQnLFxuXHRcdDQwOiAnZG93bicsXG5cdFx0NDY6ICdkZWxldGUnLFxuXHRcdDkxOiAnY29tbWFuZCcsXG5cdFx0OTM6ICdjb21tYW5kJyxcblx0XHQyMjQ6ICdjb21tYW5kJ1xuXHR9LFxuXG5cdHNwZWNpYWxDaGFycyA9IHtcblx0XHQ5OiB0cnVlLFxuXHRcdDEzOiB0cnVlLFxuXHRcdDMyOiB0cnVlXG5cdH0sXG5cblx0bW9kaWZpZXJzID0gbmV3IEJhc2Uoe1xuXHRcdHNoaWZ0OiBmYWxzZSxcblx0XHRjb250cm9sOiBmYWxzZSxcblx0XHRvcHRpb246IGZhbHNlLFxuXHRcdGNvbW1hbmQ6IGZhbHNlLFxuXHRcdGNhcHNMb2NrOiBmYWxzZSxcblx0XHRzcGFjZTogZmFsc2Vcblx0fSksXG5cblx0Y2hhckNvZGVNYXAgPSB7fSxcblx0a2V5TWFwID0ge30sXG5cdGNvbW1hbmRGaXhNYXAsXG5cdGRvd25Db2RlO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUtleShkb3duLCBrZXlDb2RlLCBjaGFyQ29kZSwgZXZlbnQpIHtcblx0XHR2YXIgY2hhcmFjdGVyID0gY2hhckNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSA6ICcnLFxuXHRcdFx0c3BlY2lhbEtleSA9IHNwZWNpYWxLZXlzW2tleUNvZGVdLFxuXHRcdFx0a2V5ID0gc3BlY2lhbEtleSB8fCBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSxcblx0XHRcdHR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJyxcblx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuXHRcdFx0c2NvcGUgPSB2aWV3ICYmIHZpZXcuaXNWaXNpYmxlKCkgJiYgdmlldy5fc2NvcGUsXG5cdFx0XHR0b29sID0gc2NvcGUgJiYgc2NvcGUudG9vbCxcblx0XHRcdG5hbWU7XG5cdFx0a2V5TWFwW2tleV0gPSBkb3duO1xuXHRcdGlmIChkb3duKSB7XG5cdFx0XHRjaGFyQ29kZU1hcFtrZXlDb2RlXSA9IGNoYXJDb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgY2hhckNvZGVNYXBba2V5Q29kZV07XG5cdFx0fVxuXHRcdGlmIChzcGVjaWFsS2V5ICYmIChuYW1lID0gQmFzZS5jYW1lbGl6ZShzcGVjaWFsS2V5KSkgaW4gbW9kaWZpZXJzKSB7XG5cdFx0XHRtb2RpZmllcnNbbmFtZV0gPSBkb3duO1xuXHRcdFx0dmFyIGJyb3dzZXIgPSBwYXBlci5icm93c2VyO1xuXHRcdFx0aWYgKG5hbWUgPT09ICdjb21tYW5kJyAmJiBicm93c2VyICYmIGJyb3dzZXIubWFjKSB7XG5cdFx0XHRcdGlmIChkb3duKSB7XG5cdFx0XHRcdFx0Y29tbWFuZEZpeE1hcCA9IHt9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGNvZGUgaW4gY29tbWFuZEZpeE1hcCkge1xuXHRcdFx0XHRcdFx0aWYgKGNvZGUgaW4gY2hhckNvZGVNYXApXG5cdFx0XHRcdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgY29kZSwgY29tbWFuZEZpeE1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21tYW5kRml4TWFwID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZG93biAmJiBjb21tYW5kRml4TWFwKSB7XG5cdFx0XHRjb21tYW5kRml4TWFwW2tleUNvZGVdID0gY2hhckNvZGU7XG5cdFx0fVxuXHRcdGlmICh0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHR0b29sLmVtaXQodHlwZSwgbmV3IEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkpO1xuXHRcdFx0aWYgKHZpZXcpXG5cdFx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0RG9tRXZlbnQuYWRkKGRvY3VtZW50LCB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblx0XHRcdGlmIChjb2RlIGluIHNwZWNpYWxLZXlzIHx8IG1vZGlmaWVycy5jb21tYW5kKSB7XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBjb2RlLFxuXHRcdFx0XHRcdFx0Y29kZSBpbiBzcGVjaWFsQ2hhcnMgfHwgbW9kaWZpZXJzLmNvbW1hbmQgPyBjb2RlIDogMCxcblx0XHRcdFx0XHRcdGV2ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvd25Db2RlID0gY29kZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5cHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZG93bkNvZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgZG93bkNvZGUsIGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGUsIGV2ZW50KTtcblx0XHRcdFx0ZG93bkNvZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXl1cDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblx0XHRcdGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Ymx1cjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGZvciAodmFyIGNvZGUgaW4gY2hhckNvZGVNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgY29kZSwgY2hhckNvZGVNYXBbY29kZV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0bW9kaWZpZXJzOiBtb2RpZmllcnMsXG5cblx0XHRpc0Rvd246IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0cmV0dXJuICEha2V5TWFwW2tleV07XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIE1vdXNlRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdNb3VzZUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuXHRcdEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5wb2ludCA9IHBvaW50O1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMuZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIHBvaW50OiBcIiArIHRoaXMucG9pbnRcblx0XHRcdFx0KyAnLCB0YXJnZXQ6ICcgKyB0aGlzLnRhcmdldFxuXHRcdFx0XHQrICh0aGlzLmRlbHRhID8gJywgZGVsdGE6ICcgKyB0aGlzLmRlbHRhIDogJycpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbEV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbEV2ZW50Jyxcblx0X2l0ZW06IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSB7XG5cdFx0dGhpcy50b29sID0gdG9vbDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRfY2hvb3NlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCB0b29sUG9pbnQpIHtcblx0XHRyZXR1cm4gcG9pbnQgPyBwb2ludCA6IHRvb2xQb2ludCA/IHRvb2xQb2ludC5jbG9uZSgpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX3BvaW50LCB0aGlzLnRvb2wuX3BvaW50KTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHR9LFxuXG5cdGdldExhc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2xhc3RQb2ludCwgdGhpcy50b29sLl9sYXN0UG9pbnQpO1xuXHR9LFxuXG5cdHNldExhc3RQb2ludDogZnVuY3Rpb24obGFzdFBvaW50KSB7XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuXHR9LFxuXG5cdGdldERvd25Qb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2Rvd25Qb2ludCwgdGhpcy50b29sLl9kb3duUG9pbnQpO1xuXHR9LFxuXG5cdHNldERvd25Qb2ludDogZnVuY3Rpb24oZG93blBvaW50KSB7XG5cdFx0dGhpcy5fZG93blBvaW50ID0gZG93blBvaW50O1xuXHR9LFxuXG5cdGdldE1pZGRsZVBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX21pZGRsZVBvaW50ICYmIHRoaXMudG9vbC5fbGFzdFBvaW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b29sLl9wb2ludC5hZGQodGhpcy50b29sLl9sYXN0UG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21pZGRsZVBvaW50O1xuXHR9LFxuXG5cdHNldE1pZGRsZVBvaW50OiBmdW5jdGlvbihtaWRkbGVQb2ludCkge1xuXHRcdHRoaXMuX21pZGRsZVBvaW50ID0gbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0Z2V0RGVsdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZGVsdGEgJiYgdGhpcy50b29sLl9sYXN0UG9pbnRcblx0XHRcdFx0PyB0aGlzLnRvb2wuX3BvaW50LnN1YnRyYWN0KHRoaXMudG9vbC5fbGFzdFBvaW50KVxuXHRcdFx0XHQ6IHRoaXMuX2RlbHRhO1xuXHR9LFxuXG5cdHNldERlbHRhOiBmdW5jdGlvbihkZWx0YSkge1xuXHRcdHRoaXMuX2RlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0Z2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpXG5cdFx0XHRcdD8gdGhpcy50b29sLl9kb3duQ291bnRcblx0XHRcdFx0OiB0aGlzLnRvb2wuX2NvdW50O1xuXHR9LFxuXG5cdHNldENvdW50OiBmdW5jdGlvbihjb3VudCkge1xuXHRcdHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpID8gJ2Rvd25Db3VudCcgOiAnY291bnQnXVxuXHRcdFx0PSBjb3VudDtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2l0ZW0pIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnRvb2wuX3Njb3BlLnByb2plY3QuaGl0VGVzdCh0aGlzLmdldFBvaW50KCkpO1xuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHJlc3VsdC5pdGVtLFxuXHRcdFx0XHRcdHBhcmVudCA9IGl0ZW0uX3BhcmVudDtcblx0XHRcdFx0d2hpbGUgKC9eKEdyb3VwfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHBhcmVudDtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW07XG5cdH0sXG5cblx0c2V0SXRlbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3sgdHlwZTogJyArIHRoaXMudHlwZVxuXHRcdFx0XHQrICcsIHBvaW50OiAnICsgdGhpcy5nZXRQb2ludCgpXG5cdFx0XHRcdCsgJywgY291bnQ6ICcgKyB0aGlzLmdldENvdW50KClcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbCcsXG5cdF9saXN0OiAndG9vbHMnLFxuXHRfcmVmZXJlbmNlOiAndG9vbCcsXG5cdF9ldmVudHM6IFsgJ29uQWN0aXZhdGUnLCAnb25EZWFjdGl2YXRlJywgJ29uRWRpdE9wdGlvbnMnLFxuXHRcdFx0J29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbk1vdXNlTW92ZScsXG5cdFx0XHQnb25LZXlEb3duJywgJ29uS2V5VXAnIF0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbChwcm9wcykge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fZmlyc3RNb3ZlID0gdHJ1ZTtcblx0XHR0aGlzLl9jb3VudCA9IDA7XG5cdFx0dGhpcy5fZG93bkNvdW50ID0gMDtcblx0XHR0aGlzLl9zZXQocHJvcHMpO1xuXHR9LFxuXG5cdGdldE1pbkRpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U7XG5cdH0sXG5cblx0c2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKG1pbkRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcblx0XHRpZiAobWluRGlzdGFuY2UgIT0gbnVsbCAmJiB0aGlzLl9tYXhEaXN0YW5jZSAhPSBudWxsXG5cdFx0XHRcdCYmIG1pbkRpc3RhbmNlID4gdGhpcy5fbWF4RGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuX21heERpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1heERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4RGlzdGFuY2U7XG5cdH0sXG5cblx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHRpZiAodGhpcy5fbWluRGlzdGFuY2UgIT0gbnVsbCAmJiBtYXhEaXN0YW5jZSAhPSBudWxsXG5cdFx0XHRcdCYmIG1heERpc3RhbmNlIDwgdGhpcy5fbWluRGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZSA9PSB0aGlzLl9tYXhEaXN0YW5jZVxuXHRcdFx0PyB0aGlzLl9taW5EaXN0YW5jZSA6IG51bGw7XG5cdH0sXG5cblx0c2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oZGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IHRoaXMuX21heERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdH0sXG5cblx0X3VwZGF0ZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlLCBzdGFydCxcblx0XHRcdG5lZWRzQ2hhbmdlLCBtYXRjaE1heERpc3RhbmNlKSB7XG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgfHwgbWF4RGlzdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgbWluRGlzdCA9IG1pbkRpc3RhbmNlICE9IG51bGwgPyBtaW5EaXN0YW5jZSA6IDAsXG5cdFx0XHRcdFx0dmVjdG9yID0gcG9pbnQuc3VidHJhY3QodGhpcy5fcG9pbnQpLFxuXHRcdFx0XHRcdGRpc3RhbmNlID0gdmVjdG9yLmdldExlbmd0aCgpO1xuXHRcdFx0XHRpZiAoZGlzdGFuY2UgPCBtaW5EaXN0KVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWYgKG1heERpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gMCkge1xuXHRcdFx0XHRcdGlmIChkaXN0YW5jZSA+IG1heERpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRwb2ludCA9IHRoaXMuX3BvaW50LmFkZCh2ZWN0b3Iubm9ybWFsaXplKG1heERpc3RhbmNlKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtYXRjaE1heERpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobmVlZHNDaGFuZ2UgJiYgcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLl9sYXN0UG9pbnQgPSBzdGFydCAmJiB0eXBlID09ICdtb3VzZW1vdmUnID8gcG9pbnQgOiB0aGlzLl9wb2ludDtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHR0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9kb3duUG9pbnQ7XG5cdFx0XHR0aGlzLl9kb3duUG9pbnQgPSB0aGlzLl9wb2ludDtcblx0XHRcdHRoaXMuX2Rvd25Db3VudCsrO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHR0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9kb3duUG9pbnQ7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dGhpcy5fY291bnQgPSBzdGFydCA/IDAgOiB0aGlzLl9jb3VudCArIDE7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcblx0XHR2YXIgc2V0cyA9IHBhcGVyLnByb2plY3QuX3JlbW92ZVNldHM7XG5cdFx0aWYgKHNldHMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V1cCcpXG5cdFx0XHRcdHNldHMubW91c2VkcmFnID0gbnVsbDtcblx0XHRcdHZhciBzZXQgPSBzZXRzW3R5cGVdO1xuXHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRmb3IgKHZhciBpZCBpbiBzZXQpIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHNldFtpZF07XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHNldHMpIHtcblx0XHRcdFx0XHRcdHZhciBvdGhlciA9IHNldHNba2V5XTtcblx0XHRcdFx0XHRcdGlmIChvdGhlciAmJiBvdGhlciAhPSBzZXQpXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBvdGhlcltpdGVtLl9pZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0c1t0eXBlXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnJlc3BvbmRzKHR5cGUpXG5cdFx0XHRcdCYmIHRoaXMuZW1pdCh0eXBlLCBuZXcgVG9vbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50KSk7XG5cdH0sXG5cblx0X2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBjYWxsZWQgPSBmYWxzZTtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2VkcmFnJzpcblx0XHRcdHZhciBuZWVkc0NoYW5nZSA9IGZhbHNlLFxuXHRcdFx0XHRtYXRjaE1heERpc3RhbmNlID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAodGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsIG5lZWRzQ2hhbmdlLCBtYXRjaE1heERpc3RhbmNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdFx0bmVlZHNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRtYXRjaE1heERpc3RhbmNlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0aWYgKCFwb2ludC5lcXVhbHModGhpcy5fcG9pbnQpXG5cdFx0XHRcdFx0JiYgdGhpcy5fdXBkYXRlRXZlbnQoJ21vdXNlZHJhZycsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQoJ21vdXNlZHJhZycsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCB0aGlzLm1heERpc3RhbmNlLCBmYWxzZSxcblx0XHRcdFx0XHRmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0d2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIHRoaXMuX2ZpcnN0TW92ZSwgdHJ1ZSwgZmFsc2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0XHR0aGlzLl9maXJzdE1vdmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoY2FsbGVkKVxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRyZXR1cm4gY2FsbGVkO1xuXHR9XG5cbn0pO1xuXG52YXIgSHR0cCA9IHtcblx0cmVxdWVzdDogZnVuY3Rpb24obWV0aG9kLCB1cmwsIGNhbGxiYWNrLCBhc3luYykge1xuXHRcdGFzeW5jID0gKGFzeW5jID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGFzeW5jO1xuXHRcdHZhciB4aHIgPSBuZXcgKHdpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IFhNTEh0dHBSZXF1ZXN0KShcblx0XHRcdFx0XHQnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0XHR4aHIub3BlbihtZXRob2QudG9VcHBlckNhc2UoKSwgdXJsLCBhc3luYyk7XG5cdFx0aWYgKCdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcblx0XHRcdFx0aWYgKHN0YXR1cyA9PT0gMCB8fCBzdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkICcgKyB1cmwgKyAnIChFcnJvciAnXG5cdFx0XHRcdFx0XHRcdCsgc3RhdHVzICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHhoci5zZW5kKG51bGwpO1xuXHR9XG59O1xuXG52YXIgQ2FudmFzUHJvdmlkZXIgPSB7XG5cdGNhbnZhc2VzOiBbXSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgY2FudmFzLFxuXHRcdFx0Y2xlYXIgPSB0cnVlO1xuXHRcdGlmICh0eXBlb2Ygd2lkdGggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRoZWlnaHQgPSB3aWR0aC5oZWlnaHQ7XG5cdFx0XHR3aWR0aCA9IHdpZHRoLndpZHRoO1xuXHRcdH1cblx0XHRpZiAodGhpcy5jYW52YXNlcy5sZW5ndGgpIHtcblx0XHRcdGNhbnZhcyA9IHRoaXMuY2FudmFzZXMucG9wKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdH1cblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKGNhbnZhcy53aWR0aCA9PT0gd2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG5cdFx0XHRpZiAoY2xlYXIpXG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKyAxLCBoZWlnaHQgKyAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHJldHVybiBjYW52YXM7XG5cdH0sXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHJldHVybiB0aGlzLmdldENhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdHJlbGVhc2U6IGZ1bmN0aW9uKG9iaikge1xuXHRcdHZhciBjYW52YXMgPSBvYmouY2FudmFzID8gb2JqLmNhbnZhcyA6IG9iajtcblx0XHRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5yZXN0b3JlKCk7XG5cdFx0dGhpcy5jYW52YXNlcy5wdXNoKGNhbnZhcyk7XG5cdH1cbn07XG5cbnZhciBCbGVuZE1vZGUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtaW4gPSBNYXRoLm1pbixcblx0XHRtYXggPSBNYXRoLm1heCxcblx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRzciwgc2csIHNiLCBzYSxcblx0XHRiciwgYmcsIGJiLCBiYSxcblx0XHRkciwgZGcsIGRiO1xuXG5cdGZ1bmN0aW9uIGdldEx1bShyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIDAuMjk4OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMdW0ociwgZywgYiwgbCkge1xuXHRcdHZhciBkID0gbCAtIGdldEx1bShyLCBnLCBiKTtcblx0XHRkciA9IHIgKyBkO1xuXHRcdGRnID0gZyArIGQ7XG5cdFx0ZGIgPSBiICsgZDtcblx0XHR2YXIgbCA9IGdldEx1bShkciwgZGcsIGRiKSxcblx0XHRcdG1uID0gbWluKGRyLCBkZywgZGIpLFxuXHRcdFx0bXggPSBtYXgoZHIsIGRnLCBkYik7XG5cdFx0aWYgKG1uIDwgMCkge1xuXHRcdFx0dmFyIGxtbiA9IGwgLSBtbjtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbCAvIGxtbjtcblx0XHR9XG5cdFx0aWYgKG14ID4gMjU1KSB7XG5cdFx0XHR2YXIgbG4gPSAyNTUgLSBsLFxuXHRcdFx0XHRteGwgPSBteCAtIGw7XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbG4gLyBteGw7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2F0KHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gbWF4KHIsIGcsIGIpIC0gbWluKHIsIGcsIGIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2F0KHIsIGcsIGIsIHMpIHtcblx0XHR2YXIgY29sID0gW3IsIGcsIGJdLFxuXHRcdFx0bXggPSBtYXgociwgZywgYiksXG5cdFx0XHRtbiA9IG1pbihyLCBnLCBiKSxcblx0XHRcdG1kO1xuXHRcdG1uID0gbW4gPT09IHIgPyAwIDogbW4gPT09IGcgPyAxIDogMjtcblx0XHRteCA9IG14ID09PSByID8gMCA6IG14ID09PSBnID8gMSA6IDI7XG5cdFx0bWQgPSBtaW4obW4sIG14KSA9PT0gMCA/IG1heChtbiwgbXgpID09PSAxID8gMiA6IDEgOiAwO1xuXHRcdGlmIChjb2xbbXhdID4gY29sW21uXSkge1xuXHRcdFx0Y29sW21kXSA9IChjb2xbbWRdIC0gY29sW21uXSkgKiBzIC8gKGNvbFtteF0gLSBjb2xbbW5dKTtcblx0XHRcdGNvbFtteF0gPSBzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb2xbbWRdID0gY29sW214XSA9IDA7XG5cdFx0fVxuXHRcdGNvbFttbl0gPSAwO1xuXHRcdGRyID0gY29sWzBdO1xuXHRcdGRnID0gY29sWzFdO1xuXHRcdGRiID0gY29sWzJdO1xuXHR9XG5cblx0dmFyIG1vZGVzID0ge1xuXHRcdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKiBzciAvIDI1NTtcblx0XHRcdGRnID0gYmcgKiBzZyAvIDI1NTtcblx0XHRcdGRiID0gYmIgKiBzYiAvIDI1NTtcblx0XHR9LFxuXG5cdFx0c2NyZWVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAtIChiciAqIHNyIC8gMjU1KTtcblx0XHRcdGRnID0gYmcgKyBzZyAtIChiZyAqIHNnIC8gMjU1KTtcblx0XHRcdGRiID0gYmIgKyBzYiAtIChiYiAqIHNiIC8gMjU1KTtcblx0XHR9LFxuXG5cdFx0b3ZlcmxheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgMTI4ID8gMiAqIGJyICogc3IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnIDwgMTI4ID8gMiAqIGJnICogc2cgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiIDwgMTI4ID8gMiAqIGJiICogc2IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdzb2Z0LWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdCA9IHNyICogYnIgLyAyNTU7XG5cdFx0XHRkciA9IHQgKyBiciAqICgyNTUgLSAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNnICogYmcgLyAyNTU7XG5cdFx0XHRkZyA9IHQgKyBiZyAqICgyNTUgLSAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNiICogYmIgLyAyNTU7XG5cdFx0XHRkYiA9IHQgKyBiYiAqICgyNTUgLSAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnaGFyZC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBzciA8IDEyOCA/IDIgKiBzciAqIGJyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzcikgKiAoMjU1IC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBzZyA8IDEyOCA/IDIgKiBzZyAqIGJnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzZykgKiAoMjU1IC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBzYiA8IDEyOCA/IDIgKiBzYiAqIGJiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzYikgKiAoMjU1IC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnY29sb3ItZG9kZ2UnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDAgPyAwIDogc3IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJyIC8gKDI1NSAtIHNyKSk7XG5cdFx0XHRkZyA9IGJnID09PSAwID8gMCA6IHNnID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiZyAvICgyNTUgLSBzZykpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMCA/IDAgOiBzYiA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmIgLyAoMjU1IC0gc2IpKTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWJ1cm4nOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDI1NSA/IDI1NSA6IHNyID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYnIpICogMjU1IC8gc3IpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMjU1ID8gMjU1IDogc2cgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiZykgKiAyNTUgLyBzZyk7XG5cdFx0XHRkYiA9IGJiID09PSAyNTUgPyAyNTUgOiBzYiA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJiKSAqIDI1NSAvIHNiKTtcblx0XHR9LFxuXG5cdFx0ZGFya2VuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnIDwgc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA8IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0bGlnaHRlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID4gc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA+IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPiBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGRpZmZlcmVuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAtIHNyO1xuXHRcdFx0aWYgKGRyIDwgMClcblx0XHRcdFx0ZHIgPSAtZHI7XG5cdFx0XHRkZyA9IGJnIC0gc2c7XG5cdFx0XHRpZiAoZGcgPCAwKVxuXHRcdFx0XHRkZyA9IC1kZztcblx0XHRcdGRiID0gYmIgLSBzYjtcblx0XHRcdGlmIChkYiA8IDApXG5cdFx0XHRcdGRiID0gLWRiO1xuXHRcdH0sXG5cblx0XHRleGNsdXNpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyICogKDI1NSAtIGJyIC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyArIHNnICogKDI1NSAtIGJnIC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiArIHNiICogKDI1NSAtIGJiIC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRodWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KHNyLCBzZywgc2IsIGdldFNhdChiciwgYmcsIGJiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0c2F0dXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoYnIsIGJnLCBiYiwgZ2V0U2F0KHNyLCBzZywgc2IpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShiciwgYmcsIGJiLCBnZXRMdW0oc3IsIHNnLCBzYikpO1xuXHRcdH0sXG5cblx0XHRjb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oc3IsIHNnLCBzYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWluKGJyICsgc3IsIDI1NSk7XG5cdFx0XHRkZyA9IG1pbihiZyArIHNnLCAyNTUpO1xuXHRcdFx0ZGIgPSBtaW4oYmIgKyBzYiwgMjU1KTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtYXgoYnIgLSBzciwgMCk7XG5cdFx0XHRkZyA9IG1heChiZyAtIHNnLCAwKTtcblx0XHRcdGRiID0gbWF4KGJiIC0gc2IsIDApO1xuXHRcdH0sXG5cblx0XHRhdmVyYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gKGJyICsgc3IpIC8gMjtcblx0XHRcdGRnID0gKGJnICsgc2cpIC8gMjtcblx0XHRcdGRiID0gKGJiICsgc2IpIC8gMjtcblx0XHR9LFxuXG5cdFx0bmVnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAyNTUgLSBhYnMoMjU1IC0gc3IgLSBicik7XG5cdFx0XHRkZyA9IDI1NSAtIGFicygyNTUgLSBzZyAtIGJnKTtcblx0XHRcdGRiID0gMjU1IC0gYWJzKDI1NSAtIHNiIC0gYmIpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgbmF0aXZlTW9kZXMgPSB0aGlzLm5hdGl2ZU1vZGVzID0gQmFzZS5lYWNoKFtcblx0XHQnc291cmNlLW92ZXInLCAnc291cmNlLWluJywgJ3NvdXJjZS1vdXQnLCAnc291cmNlLWF0b3AnLFxuXHRcdCdkZXN0aW5hdGlvbi1vdmVyJywgJ2Rlc3RpbmF0aW9uLWluJywgJ2Rlc3RpbmF0aW9uLW91dCcsXG5cdFx0J2Rlc3RpbmF0aW9uLWF0b3AnLCAnbGlnaHRlcicsICdkYXJrZXInLCAnY29weScsICd4b3InXG5cdF0sIGZ1bmN0aW9uKG1vZGUpIHtcblx0XHR0aGlzW21vZGVdID0gdHJ1ZTtcblx0fSwge30pO1xuXG5cdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcblx0XHR2YXIgZGFya2VuID0gbW9kZSA9PT0gJ2RhcmtlbicsXG5cdFx0XHRvayA9IGZhbHNlO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dHJ5IHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnIzMwMCcgOiAnI2EwMCc7XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGlmIChjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID09PSBtb2RlKSB7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG5cdFx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0b2sgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbMF0gIT09IGRhcmtlbiA/IDE3MCA6IDUxO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuXHR9KTtcblx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcblx0XHR2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG5cdFx0XHRub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblx0XHRpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG5cdFx0XHRkc3RDb250ZXh0LnNhdmUoKTtcblx0XHRcdGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKCFub3JtYWwpXG5cdFx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHRcdGRzdENvbnRleHQucmVzdG9yZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKCFwcm9jZXNzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuXHRcdFx0XHRkc3QgPSBkc3REYXRhLmRhdGEsXG5cdFx0XHRcdHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KS5kYXRhO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkc3QubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHRcdHNyID0gc3JjW2ldO1xuXHRcdFx0XHRiciA9IGRzdFtpXTtcblx0XHRcdFx0c2cgPSBzcmNbaSArIDFdO1xuXHRcdFx0XHRiZyA9IGRzdFtpICsgMV07XG5cdFx0XHRcdHNiID0gc3JjW2kgKyAyXTtcblx0XHRcdFx0YmIgPSBkc3RbaSArIDJdO1xuXHRcdFx0XHRzYSA9IHNyY1tpICsgM107XG5cdFx0XHRcdGJhID0gZHN0W2kgKyAzXTtcblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHR2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuXHRcdFx0XHRcdGEyID0gMSAtIGExO1xuXHRcdFx0XHRkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcblx0XHRcdFx0ZHN0W2kgKyAxXSA9IGExICogZGcgKyBhMiAqIGJnO1xuXHRcdFx0XHRkc3RbaSArIDJdID0gYTEgKiBkYiArIGEyICogYmI7XG5cdFx0XHRcdGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcblx0XHRcdH1cblx0XHRcdGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFNWR1N0eWxlcyA9IEJhc2UuZWFjaCh7XG5cdGZpbGxDb2xvcjogWydmaWxsJywgJ2NvbG9yJ10sXG5cdHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuXHRzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG5cdHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcblx0c3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG5cdHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG5cdFx0dHJ1ZTogJ25vbmUnLFxuXHRcdGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuXHR9LCBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0JiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG5cdH1dLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0cmluZyddXG59LCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0bG9va3VwID0gZW50cnlbMl07XG5cdHRoaXNba2V5XSA9IHtcblx0XHR0eXBlOiBlbnRyeVsxXSxcblx0XHRwcm9wZXJ0eToga2V5LFxuXHRcdGF0dHJpYnV0ZTogZW50cnlbMF0sXG5cdFx0dG9TVkc6IGxvb2t1cCxcblx0XHRmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHRoaXNbdmFsdWVdID0gbmFtZTtcblx0XHR9LCB7fSksXG5cdFx0ZXhwb3J0RmlsdGVyOiBlbnRyeVszXSxcblx0XHRnZXQ6ICdnZXQnICsgcGFydCxcblx0XHRzZXQ6ICdzZXQnICsgcGFydFxuXHR9O1xufSwge30pO1xuXG52YXIgU1ZHTmFtZXNwYWNlcyA9IHtcblx0aHJlZjogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHR4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnXG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBmb3JtYXR0ZXI7XG5cblx0ZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycykge1xuXHRcdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0dmFyIHZhbCA9IGF0dHJzW2tleV0sXG5cdFx0XHRcdG5hbWVzcGFjZSA9IFNWR05hbWVzcGFjZXNba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcblx0XHRcdFx0dmFsID0gZm9ybWF0dGVyLm51bWJlcih2YWwpO1xuXHRcdFx0aWYgKG5hbWVzcGFjZSkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwga2V5LCB2YWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykge1xuXHRcdHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuXHRcdFx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZyksIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRyYW5zZm9ybShtYXRyaXgsIGNvb3JkaW5hdGVzLCBjZW50ZXIpIHtcblx0XHR2YXIgYXR0cnMgPSBuZXcgQmFzZSgpLFxuXHRcdFx0dHJhbnMgPSBtYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblx0XHRpZiAoY29vcmRpbmF0ZXMpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zaGlmdGxlc3MoKTtcblx0XHRcdHZhciBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG5cdFx0XHR0cmFucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0XHRpZiAoZGVjb21wb3NlZCAmJiAhZGVjb21wb3NlZC5zaGVhcmluZykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdFx0XHRhbmdsZSA9IGRlY29tcG9zZWQucm90YXRpb24sXG5cdFx0XHRcdFx0c2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cdFx0XHRcdGlmICh0cmFucyAmJiAhdHJhbnMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgndHJhbnNsYXRlKCcgKyBmb3JtYXR0ZXIucG9pbnQodHJhbnMpICsgJyknKTtcblx0XHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKVxuXHRcdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsnKScpO1xuXHRcdFx0XHRpZiAoYW5nbGUpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgncm90YXRlKCcgKyBmb3JtYXR0ZXIubnVtYmVyKGFuZ2xlKSArICcpJyk7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9ICdtYXRyaXgoJyArIG1hdHJpeC5nZXRWYWx1ZXMoKS5qb2luKCcsJykgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyb3VwKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KSxcblx0XHRcdGNoaWxkcmVuID0gaXRlbS5fY2hpbGRyZW47XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCdnJywgYXR0cnMpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBleHBvcnRTVkcoY2hpbGQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKGNoaWxkTm9kZSkge1xuXHRcdFx0XHRpZiAoY2hpbGQuaXNDbGlwTWFzaygpKSB7XG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBjcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcpO1xuXHRcdFx0XHRcdGNsaXAuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0XHRzZXREZWZpbml0aW9uKGNoaWxkLCBjbGlwLCAnY2xpcCcpO1xuXHRcdFx0XHRcdHNldEF0dHJpYnV0ZXMobm9kZSwge1xuXHRcdFx0XHRcdFx0J2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKSxcblx0XHRcdGltYWdlID0gaXRlbS5nZXRJbWFnZSgpO1xuXHRcdGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG5cdFx0YXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG5cdFx0YXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGF0dHJzLmhyZWYgPSBvcHRpb25zLmVtYmVkSW1hZ2VzID09PSBmYWxzZSAmJiBpbWFnZSAmJiBpbWFnZS5zcmNcblx0XHRcdFx0fHwgaXRlbS50b0RhdGFVUkwoKTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgnaW1hZ2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgbWF0Y2hTaGFwZXMgPSBvcHRpb25zLm1hdGNoU2hhcGVzO1xuXHRcdGlmIChtYXRjaFNoYXBlcykge1xuXHRcdFx0dmFyIHNoYXBlID0gaXRlbS50b1NoYXBlKGZhbHNlKTtcblx0XHRcdGlmIChzaGFwZSlcblx0XHRcdFx0cmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0dmFyIHNlZ21lbnRzID0gaXRlbS5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKG1hdGNoU2hhcGVzICYmICFpdGVtLmhhc0hhbmRsZXMoKSkge1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA+PSAzKSB7XG5cdFx0XHRcdHR5cGUgPSBpdGVtLl9jbG9zZWQgPyAncG9seWdvbicgOiAncG9seWxpbmUnO1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKGZvcm1hdHRlci5wb2ludChzZWdtZW50c1tpXS5fcG9pbnQpKTtcblx0XHRcdFx0YXR0cnMucG9pbnRzID0gcGFydHMuam9pbignICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9ICdsaW5lJztcblx0XHRcdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF0uX3BvaW50LFxuXHRcdFx0XHRcdGxhc3QgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQ7XG5cdFx0XHRcdGF0dHJzLnNldCh7XG5cdFx0XHRcdFx0eDE6IGZpcnN0LngsXG5cdFx0XHRcdFx0eTE6IGZpcnN0LnksXG5cdFx0XHRcdFx0eDI6IGxhc3QueCxcblx0XHRcdFx0XHR5MjogbGFzdC55XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXBlID0gJ3BhdGgnO1xuXHRcdFx0YXR0cnMuZCA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTaGFwZShpdGVtKSB7XG5cdFx0dmFyIHR5cGUgPSBpdGVtLl90eXBlLFxuXHRcdFx0cmFkaXVzID0gaXRlbS5fcmFkaXVzLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlLCB0eXBlICE9PSAncmVjdGFuZ2xlJyk7XG5cdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHR0eXBlID0gJ3JlY3QnO1xuXHRcdFx0dmFyIHNpemUgPSBpdGVtLl9zaXplLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0YXR0cnMueCAtPSB3aWR0aCAvIDI7XG5cdFx0XHRhdHRycy55IC09IGhlaWdodCAvIDI7XG5cdFx0XHRhdHRycy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0YXR0cnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0aWYgKHJhZGl1cy5pc1plcm8oKSlcblx0XHRcdFx0cmFkaXVzID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHJhZGl1cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGF0dHJzLnIgPSByYWRpdXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy5yeCA9IHJhZGl1cy53aWR0aDtcblx0XHRcdFx0YXR0cnMucnkgPSByYWRpdXMuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRDb21wb3VuZFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdHZhciBkYXRhID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0aWYgKGRhdGEpXG5cdFx0XHRhdHRycy5kID0gZGF0YTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgncGF0aCcsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBsYWNlZFN5bWJvbChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzeW1ib2wgPSBpdGVtLmdldFN5bWJvbCgpLFxuXHRcdFx0c3ltYm9sTm9kZSA9IGdldERlZmluaXRpb24oc3ltYm9sLCAnc3ltYm9sJyksXG5cdFx0XHRkZWZpbml0aW9uID0gc3ltYm9sLmdldERlZmluaXRpb24oKSxcblx0XHRcdGJvdW5kcyA9IGRlZmluaXRpb24uZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFzeW1ib2xOb2RlKSB7XG5cdFx0XHRzeW1ib2xOb2RlID0gY3JlYXRlRWxlbWVudCgnc3ltYm9sJywge1xuXHRcdFx0XHR2aWV3Qm94OiBmb3JtYXR0ZXIucmVjdGFuZ2xlKGJvdW5kcylcblx0XHRcdH0pO1xuXHRcdFx0c3ltYm9sTm9kZS5hcHBlbmRDaGlsZChleHBvcnRTVkcoZGVmaW5pdGlvbiwgb3B0aW9ucykpO1xuXHRcdFx0c2V0RGVmaW5pdGlvbihzeW1ib2wsIHN5bWJvbE5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIHN5bWJvbE5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMud2lkdGgpO1xuXHRcdGF0dHJzLmhlaWdodCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLmhlaWdodCk7XG5cdFx0YXR0cnMub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3VzZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGhpZ2hsaWdodC50cmFuc2Zvcm0oKTtcblx0XHRcdFx0XHRhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuXHRcdFx0XHRcdGF0dHJzLmZ5ID0gaGlnaGxpZ2h0Lnk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHgxOiBvcmlnaW4ueCxcblx0XHRcdFx0XHR5MTogb3JpZ2luLnksXG5cdFx0XHRcdFx0eDI6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHRcdFx0eTI6IGRlc3RpbmF0aW9uLnlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGF0dHJzLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuXHRcdFx0Z3JhZGllbnROb2RlID0gY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJykgKyAnR3JhZGllbnQnLCBhdHRycyk7XG5cdFx0XHR2YXIgc3RvcHMgPSBncmFkaWVudC5fc3RvcHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldLFxuXHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3AuX2NvbG9yLFxuXHRcdFx0XHRcdGFscGhhID0gc3RvcENvbG9yLmdldEFscGhhKCk7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdG9mZnNldDogc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLnRvQ1NTKHRydWUpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzdG9wJywgYXR0cnMpKTtcblx0XHRcdH1cblx0XHRcdHNldERlZmluaXRpb24oY29sb3IsIGdyYWRpZW50Tm9kZSwgJ2NvbG9yJyk7XG5cdFx0fVxuXHRcdHJldHVybiAndXJsKCMnICsgZ3JhZGllbnROb2RlLmlkICsgJyknO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0VGV4dChpdGVtKSB7XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCd0ZXh0JywgZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSkpO1xuXHRcdG5vZGUudGV4dENvbnRlbnQgPSBpdGVtLl9jb250ZW50O1xuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0dmFyIGV4cG9ydGVycyA9IHtcblx0XHRHcm91cDogZXhwb3J0R3JvdXAsXG5cdFx0TGF5ZXI6IGV4cG9ydEdyb3VwLFxuXHRcdFJhc3RlcjogZXhwb3J0UmFzdGVyLFxuXHRcdFBhdGg6IGV4cG9ydFBhdGgsXG5cdFx0U2hhcGU6IGV4cG9ydFNoYXBlLFxuXHRcdENvbXBvdW5kUGF0aDogZXhwb3J0Q29tcG91bmRQYXRoLFxuXHRcdFBsYWNlZFN5bWJvbDogZXhwb3J0UGxhY2VkU3ltYm9sLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIGF0dHJzID0ge30sXG5cdFx0XHRwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCk7XG5cblx0XHRpZiAoaXRlbS5fbmFtZSAhPSBudWxsKVxuXHRcdFx0YXR0cnMuaWQgPSBpdGVtLl9uYW1lO1xuXG5cdFx0QmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHRcdHZhciBnZXQgPSBlbnRyeS5nZXQsXG5cdFx0XHRcdHR5cGUgPSBlbnRyeS50eXBlLFxuXHRcdFx0XHR2YWx1ZSA9IGl0ZW1bZ2V0XSgpO1xuXHRcdFx0aWYgKGVudHJ5LmV4cG9ydEZpbHRlclxuXHRcdFx0XHRcdD8gZW50cnkuZXhwb3J0RmlsdGVyKGl0ZW0sIHZhbHVlKVxuXHRcdFx0XHRcdDogIXBhcmVudCB8fCAhQmFzZS5lcXVhbHMocGFyZW50W2dldF0oKSwgdmFsdWUpKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnY29sb3InICYmIHZhbHVlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgYWxwaGEgPSB2YWx1ZS5nZXRBbHBoYSgpO1xuXHRcdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGUgKyAnLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZV0gPSB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdFx0PyAnbm9uZSdcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGZvcm1hdHRlci5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmpvaW4oJywnKVxuXHRcdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHRcdD8gZW50cnkudG9TVkdbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpXG5cdFx0XHRkZWxldGUgYXR0cnMub3BhY2l0eTtcblxuXHRcdGlmICghaXRlbS5fdmlzaWJsZSlcblx0XHRcdGF0dHJzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdHJldHVybiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucztcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihpdGVtLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGRlZmluaXRpb25zID0geyBpZHM6IHt9LCBzdmdzOiB7fSB9O1xuXHRcdHJldHVybiBpdGVtICYmIGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIGl0ZW0uX2lkXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldERlZmluaXRpb24oaXRlbSwgbm9kZSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRnZXREZWZpbml0aW9uKCk7XG5cdFx0dmFyIGlkID0gZGVmaW5pdGlvbnMuaWRzW3R5cGVdID0gKGRlZmluaXRpb25zLmlkc1t0eXBlXSB8fCAwKSArIDE7XG5cdFx0bm9kZS5pZCA9IHR5cGUgKyAnLScgKyBpZDtcblx0XHRkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF0gPSBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBzdmcgPSBub2RlLFxuXHRcdFx0ZGVmcyA9IG51bGw7XG5cdFx0aWYgKGRlZmluaXRpb25zKSB7XG5cdFx0XHRzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcblx0XHRcdFx0aWYgKCFkZWZzKSB7XG5cdFx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRcdHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuXHRcdFx0XHRcdFx0c3ZnLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZzID0gc3ZnLmluc2VydEJlZm9yZShjcmVhdGVFbGVtZW50KCdkZWZzJyksXG5cdFx0XHRcdFx0XHRcdHN2Zy5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZzLmFwcGVuZENoaWxkKGRlZmluaXRpb25zLnN2Z3NbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gb3B0aW9ucy5hc1N0cmluZ1xuXHRcdFx0XHQ/IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKVxuXHRcdFx0XHQ6IHN2Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNWRyhpdGVtLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgZXhwb3J0ZXIgPSBleHBvcnRlcnNbaXRlbS5fY2xhc3NdLFxuXHRcdFx0bm9kZSA9IGV4cG9ydGVyICYmIGV4cG9ydGVyKGl0ZW0sIG9wdGlvbnMpO1xuXHRcdGlmIChub2RlKSB7XG5cdFx0XHR2YXIgb25FeHBvcnQgPSBvcHRpb25zLm9uRXhwb3J0O1xuXHRcdFx0aWYgKG9uRXhwb3J0KVxuXHRcdFx0XHRub2RlID0gb25FeHBvcnQoaXRlbSwgbm9kZSwgb3B0aW9ucykgfHwgbm9kZTtcblx0XHRcdHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5fZGF0YSk7XG5cdFx0XHRpZiAoZGF0YSAmJiBkYXRhICE9PSAne30nICYmIGRhdGEgIT09ICdudWxsJylcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScsIGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZSAmJiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0Zm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhleHBvcnRTVkcodGhpcywgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnMsXG5cdFx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdFx0c2l6ZSA9IHZpZXcuZ2V0Vmlld1NpemUoKSxcblx0XHRcdFx0bm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycsIHtcblx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzaXplLmhlaWdodCxcblx0XHRcdFx0XHR2ZXJzaW9uOiAnMS4xJyxcblx0XHRcdFx0XHR4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0XHQneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcblx0XHRcdFx0fSksXG5cdFx0XHRcdHBhcmVudCA9IG5vZGUsXG5cdFx0XHRcdG1hdHJpeCA9IHZpZXcuX21hdHJpeDtcblx0XHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdFx0cGFyZW50ID0gbm9kZS5hcHBlbmRDaGlsZChcblx0XHRcdFx0XHRcdGNyZWF0ZUVsZW1lbnQoJ2cnLCBnZXRUcmFuc2Zvcm0obWF0cml4KSkpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGxheWVyc1tpXSwgb3B0aW9ucywgdHJ1ZSkpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBuYW1lc3BhY2Vcblx0XHRcdFx0PyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSlcblx0XHRcdFx0OiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0XHRpZiAodmFsdWUgPT09ICdudWxsJylcblx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHQ/IGFsbG93TnVsbFxuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHRcdD8gJydcblx0XHRcdFx0XHRcdDogMFxuXHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0PyB2YWx1ZVxuXHRcdFx0XHRcdDogcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb2ludChub2RlLCB4LCB5LCBhbGxvd051bGwpIHtcblx0XHR4ID0gZ2V0VmFsdWUobm9kZSwgeCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0eSA9IGdldFZhbHVlKG5vZGUsIHksIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNpemUobm9kZSwgdywgaCwgYWxsb3dOdWxsKSB7XG5cdFx0dyA9IGdldFZhbHVlKG5vZGUsIHcsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdGggPSBnZXRWYWx1ZShub2RlLCBoLCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh3ID09IG51bGwgfHwgaCA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgU2l6ZSh3LCBoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgdHlwZSwgbG9va3VwKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbm9uZSdcblx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHQ/IHBhcnNlRmxvYXQodmFsdWUpXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHQ/IHZhbHVlID8gdmFsdWUuc3BsaXQoL1tcXHMsXSsvZykubWFwKHBhcnNlRmxvYXQpIDogW11cblx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2NvbG9yJ1xuXHRcdFx0XHRcdFx0XHQ/IGdldERlZmluaXRpb24odmFsdWUpIHx8IHZhbHVlXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHQ/IGxvb2t1cFt2YWx1ZV1cblx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0aXNDbGlwID0gdHlwZSA9PT0gJ2NsaXBwYXRoJyxcblx0XHRcdGl0ZW0gPSBuZXcgR3JvdXAoKSxcblx0XHRcdHByb2plY3QgPSBpdGVtLl9wcm9qZWN0LFxuXHRcdFx0Y3VycmVudFN0eWxlID0gcHJvamVjdC5fY3VycmVudFN0eWxlLFxuXHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRpZiAoIWlzQ2xpcCkge1xuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gaXRlbS5fc3R5bGUuY2xvbmUoKTtcblx0XHR9XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0dmFyIGRlZnMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RlZnMnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZGVmcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW1wb3J0U1ZHKGRlZnNbaV0sIG9wdGlvbnMsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBub2Rlc1tpXSxcblx0XHRcdFx0Y2hpbGQ7XG5cdFx0XHRpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxXG5cdFx0XHRcdFx0JiYgY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdkZWZzJ1xuXHRcdFx0XHRcdCYmIChjaGlsZCA9IGltcG9ydFNWRyhjaGlsZE5vZGUsIG9wdGlvbnMsIGZhbHNlKSlcblx0XHRcdFx0XHQmJiAhKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sKSlcblx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdFx0fVxuXHRcdGl0ZW0uYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdGlmIChpc0NsaXApXG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0ucmVkdWNlKCksIG5vZGUsIGlzUm9vdCk7XG5cdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlO1xuXHRcdGlmIChpc0NsaXAgfHwgdHlwZSA9PT0gJ2RlZnMnKSB7XG5cdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0aXRlbSA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UG9seShub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5tYXRjaChcblx0XHRcdFx0XHQvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaV0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2kgKyAxXSkpKTtcblx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKHBvaW50cyk7XG5cdFx0aWYgKHR5cGUgPT09ICdwb2x5Z29uJylcblx0XHRcdHBhdGguY2xvc2VQYXRoKCk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQYXRoKG5vZGUpIHtcblx0XHR2YXIgZGF0YSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkJyksXG5cdFx0XHRwYXJhbSA9IHsgcGF0aERhdGE6IGRhdGEgfTtcblx0XHRyZXR1cm4gKGRhdGEubWF0Y2goL20vZ2kpIHx8IFtdKS5sZW5ndGggPiAxIHx8IC96XFxTKy9pLnRlc3QoZGF0YSlcblx0XHRcdFx0PyBuZXcgQ29tcG91bmRQYXRoKHBhcmFtKVxuXHRcdFx0XHQ6IG5ldyBQYXRoKHBhcmFtKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyYWRpZW50KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuXHRcdFx0aXNSYWRpYWwgPSB0eXBlID09PSAncmFkaWFsZ3JhZGllbnQnLFxuXHRcdFx0Z3JhZGllbnQ7XG5cdFx0aWYgKGlkKSB7XG5cdFx0XHRncmFkaWVudCA9IGRlZmluaXRpb25zW2lkXS5nZXRHcmFkaWVudCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRcdHN0b3BzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKVxuXHRcdFx0XHRcdHN0b3BzLnB1c2goYXBwbHlBdHRyaWJ1dGVzKG5ldyBHcmFkaWVudFN0b3AoKSwgY2hpbGQpKTtcblx0XHRcdH1cblx0XHRcdGdyYWRpZW50ID0gbmV3IEdyYWRpZW50KHN0b3BzLCBpc1JhZGlhbCk7XG5cdFx0fVxuXHRcdHZhciBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQ7XG5cdFx0aWYgKGlzUmFkaWFsKSB7XG5cdFx0XHRvcmlnaW4gPSBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKTtcblx0XHRcdGRlc3RpbmF0aW9uID0gb3JpZ2luLmFkZChnZXRWYWx1ZShub2RlLCAncicpLCAwKTtcblx0XHRcdGhpZ2hsaWdodCA9IGdldFBvaW50KG5vZGUsICdmeCcsICdmeScsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcmlnaW4gPSBnZXRQb2ludChub2RlLCAneDEnLCAneTEnKTtcblx0XHRcdGRlc3RpbmF0aW9uID0gZ2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJyk7XG5cdFx0fVxuXHRcdGFwcGx5QXR0cmlidXRlcyhcblx0XHRcdG5ldyBDb2xvcihncmFkaWVudCwgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0KSwgbm9kZSk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaW1wb3J0ZXJzID0ge1xuXHRcdCcjZG9jdW1lbnQnOiBmdW5jdGlvbiAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG5cdFx0XHRcdFx0dmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IGltcG9ydFNWRyhjaGlsZCwgb3B0aW9ucywgaXNSb290KTtcblx0XHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdFx0bm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGc6IGltcG9ydEdyb3VwLFxuXHRcdHN2ZzogaW1wb3J0R3JvdXAsXG5cdFx0Y2xpcHBhdGg6IGltcG9ydEdyb3VwLFxuXHRcdHBvbHlnb246IGltcG9ydFBvbHksXG5cdFx0cG9seWxpbmU6IGltcG9ydFBvbHksXG5cdFx0cGF0aDogaW1wb3J0UGF0aCxcblx0XHRsaW5lYXJncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cdFx0cmFkaWFsZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXG5cdFx0aW1hZ2U6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpKTtcblx0XHRcdHJhc3Rlci5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpO1xuXHRcdFx0XHR0aGlzLnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLmFkZChzaXplLmRpdmlkZSgyKSkpO1xuXHRcdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmFzdGVyO1xuXHRcdH0sXG5cblx0XHRzeW1ib2w6IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTeW1ib2woaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdGRlZnM6IGltcG9ydEdyb3VwLFxuXG5cdFx0dXNlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuXHRcdFx0XHRkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbaWRdLFxuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KG5vZGUsICd4JywgJ3knKTtcblx0XHRcdHJldHVybiBkZWZpbml0aW9uXG5cdFx0XHRcdFx0PyBkZWZpbml0aW9uIGluc3RhbmNlb2YgU3ltYm9sXG5cdFx0XHRcdFx0XHQ/IGRlZmluaXRpb24ucGxhY2UocG9pbnQpXG5cdFx0XHRcdFx0XHQ6IGRlZmluaXRpb24uY2xvbmUoKS50cmFuc2xhdGUocG9pbnQpXG5cdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRjaXJjbGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuQ2lyY2xlKGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuXHRcdFx0XHRcdGdldFZhbHVlKG5vZGUsICdyJykpO1xuXHRcdH0sXG5cblx0XHRlbGxpcHNlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkVsbGlwc2Uoe1xuXHRcdFx0XHRjZW50ZXI6IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuXHRcdFx0XHRyYWRpdXM6IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRyZWN0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5JyksXG5cdFx0XHRcdHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnKSxcblx0XHRcdFx0cmFkaXVzID0gZ2V0U2l6ZShub2RlLCAncngnLCAncnknKTtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUocG9pbnQsIHNpemUpLCByYWRpdXMpO1xuXHRcdH0sXG5cblx0XHRsaW5lOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBhdGguTGluZShnZXRQb2ludChub2RlLCAneDEnLCAneTEnKSxcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneDInLCAneTInKSk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciB0ZXh0ID0gbmV3IFBvaW50VGV4dChnZXRQb2ludChub2RlLCAneCcsICd5Jylcblx0XHRcdFx0XHQuYWRkKGdldFBvaW50KG5vZGUsICdkeCcsICdkeScpKSk7XG5cdFx0XHR0ZXh0LnNldENvbnRlbnQobm9kZS50ZXh0Q29udGVudC50cmltKCkgfHwgJycpO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlKSB7XG5cdFx0dmFyIHRyYW5zZm9ybXMgPSAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgJycpLnNwbGl0KC9cXClcXHMqL2cpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW2ldO1xuXHRcdFx0aWYgKCF0cmFuc2Zvcm0pXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0dmFyIHBhcnRzID0gdHJhbnNmb3JtLnNwbGl0KC9cXChcXHMqLyksXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0c1swXSxcblx0XHRcdFx0diA9IHBhcnRzWzFdLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSB2Lmxlbmd0aDsgaiA8IG07IGorKylcblx0XHRcdFx0dltqXSA9IHBhcnNlRmxvYXQodltqXSk7XG5cdFx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdG1hdHJpeC5jb25jYXRlbmF0ZShcblx0XHRcdFx0XHRcdG5ldyBNYXRyaXgodlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdG1hdHJpeC5yb3RhdGUodlswXSwgdlsxXSwgdlsyXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0bWF0cml4LnRyYW5zbGF0ZSh2WzBdLCB2WzFdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdG1hdHJpeC5zY2FsZSh2KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdza2V3WCc6XG5cdFx0XHRcdG1hdHJpeC5za2V3KHZbMF0sIDApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NrZXdZJzpcblx0XHRcdFx0bWF0cml4LnNrZXcoMCwgdlswXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlPcGFjaXR5KGl0ZW0sIHZhbHVlLCBuYW1lKSB7XG5cdFx0dmFyIGNvbG9yID0gaXRlbVtuYW1lID09PSAnZmlsbC1vcGFjaXR5JyA/ICdnZXRGaWxsQ29sb3InXG5cdFx0XHRcdDogJ2dldFN0cm9rZUNvbG9yJ10oKTtcblx0XHRpZiAoY29sb3IpXG5cdFx0XHRjb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdH1cblxuXHR2YXIgYXR0cmlidXRlcyA9IEJhc2Uuc2V0KEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0dGhpc1tlbnRyeS5hdHRyaWJ1dGVdID0gZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW1bZW50cnkuc2V0XShjb252ZXJ0VmFsdWUodmFsdWUsIGVudHJ5LnR5cGUsIGVudHJ5LmZyb21TVkcpKTtcblx0XHRcdGlmIChlbnRyeS50eXBlID09PSAnY29sb3InICYmIGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSkge1xuXHRcdFx0XHR2YXIgY29sb3IgPSBpdGVtW2VudHJ5LmdldF0oKTtcblx0XHRcdFx0aWYgKGNvbG9yKVxuXHRcdFx0XHRcdGNvbG9yLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRpdGVtLmdldFBvc2l0aW9uKHRydWUpLm5lZ2F0ZSgpKSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSwge30pLCB7XG5cdFx0aWQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKGl0ZW0uc2V0TmFtZSlcblx0XHRcdFx0aXRlbS5zZXROYW1lKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J2NsaXAtcGF0aCc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXHRcdFx0aWYgKGNsaXApIHtcblx0XHRcdFx0Y2xpcCA9IGNsaXAuY2xvbmUoKTtcblx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHRcdGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cdFx0dHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblxuXHRcdCdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cdFx0J3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXG5cdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcblx0XHR9LFxuXG5cdFx0ZGlzcGxheTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSAhPT0gbnVsbCk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldENvbG9yKVxuXHRcdFx0XHRpdGVtLnNldENvbG9yKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5fY29sb3IpXG5cdFx0XHRcdGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSB2YWx1ZS5tYXRjaCgvKC4qKSUkLyk7XG5cdFx0XHRpdGVtLnNldFJhbXBQb2ludChwZXJjZW50YWdlXG5cdFx0XHRcdFx0PyBwZXJjZW50YWdlWzFdIC8gMTAwXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcblx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcsIHRydWUpO1xuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSBzaXplID8gcmVjdC5nZXRTaXplKCkuZGl2aWRlKHNpemUpIDogMSxcblx0XHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKSkuc2NhbGUoc2NhbGUpO1xuXHRcdFx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXguaW52ZXJ0ZWQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0XHRcdFx0aWYgKHNpemUpXG5cdFx0XHRcdFx0cmVjdC5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2xpcCA9IGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9ICd2aXNpYmxlJyxcblx0XHRcdFx0XHRncm91cCA9IGl0ZW0uX2RlZmluaXRpb247XG5cdFx0XHRcdGlmIChjbGlwICYmICFyZWN0LmNvbnRhaW5zKGdyb3VwLmdldEJvdW5kcygpKSkge1xuXHRcdFx0XHRcdGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpLnRyYW5zZm9ybShncm91cC5fbWF0cml4KTtcblx0XHRcdFx0XHRjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXHRcdFx0XHRcdGdyb3VwLmFkZENoaWxkKGNsaXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKSB7XG5cdFx0dmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IGF0dHIgJiYgYXR0ci52YWx1ZTtcblx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuXHRcdFx0dmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcblx0XHRcdGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcblx0XHRcdFx0dmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG5cdFx0fVxuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0PyB1bmRlZmluZWRcblx0XHRcdFx0OiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgc3R5bGVzID0ge1xuXHRcdFx0bm9kZTogRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZSkgfHwge30sXG5cdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZS5wYXJlbnROb2RlKSB8fCB7fVxuXHRcdH07XG5cdFx0QmFzZS5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGFwcGx5LCBuYW1lKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtID0gQmFzZS5waWNrKGFwcGx5KGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpLCBpdGVtKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucyA9IHt9O1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1hdGNoID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL1xcKCg/OiN8KShbXiknXSspLyk7XG5cdFx0cmV0dXJuIG1hdGNoICYmIGRlZmluaXRpb25zW21hdGNoWzFdXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdGlmICghc291cmNlKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3B0aW9ucyA9IHsgb25Mb2FkOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIG5vZGUgPSBzb3VyY2UsXG5cdFx0XHRzY29wZSA9IHBhcGVyO1xuXG5cdFx0ZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2soc3ZnKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoc3ZnLCBvcHRpb25zLCBpc1Jvb3QpLFxuXHRcdFx0XHRvbkxvYWQgPSBvcHRpb25zLm9uTG9hZCxcblx0XHRcdFx0dmlldyA9IHNjb3BlLnByb2plY3QgJiYgc2NvcGUuZ2V0VmlldygpO1xuXHRcdFx0aWYgKG9uTG9hZClcblx0XHRcdFx0b25Mb2FkLmNhbGwodGhpcywgaXRlbSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL14uKjwvLnRlc3Qoc291cmNlKSkge1xuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHRzb3VyY2UgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBIdHRwLnJlcXVlc3QoJ2dldCcsIHNvdXJjZSwgb25Mb2FkQ2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG5cdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2socmVhZGVyLnJlc3VsdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJylcblx0XHRcdG5vZGUgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHNvdXJjZSwgJ2ltYWdlL3N2Zyt4bWwnKTtcblx0XHRpZiAoIW5vZGUubm9kZU5hbWUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuXHRcdHZhciB0eXBlID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0aW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG5cdFx0XHRpdGVtLFxuXHRcdFx0ZGF0YSA9IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnKSxcblx0XHRcdHNldHRpbmdzID0gc2NvcGUuc2V0dGluZ3MsXG5cdFx0XHRhcHBseU1hdHJpeCA9IHNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0aXRlbSA9IGltcG9ydGVyICYmIGltcG9ydGVyKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkgfHwgbnVsbDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4O1xuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRpZiAodHlwZSAhPT0gJyNkb2N1bWVudCcgJiYgIShpdGVtIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHR2YXIgb25JbXBvcnQgPSBvcHRpb25zLm9uSW1wb3J0O1xuXHRcdFx0aWYgKG9uSW1wb3J0KVxuXHRcdFx0XHRpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdGRlZmluaXRpb25zID0ge307XG5cdFx0XHRpZiAoaXRlbSAmJiBCYXNlLnBpY2sob3B0aW9ucy5hcHBseU1hdHJpeCwgYXBwbHlNYXRyaXgpKVxuXHRcdFx0XHRpdGVtLm1hdHJpeC5hcHBseSh0cnVlLCB0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRDaGlsZChpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdHJ1ZSkpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdFx0cmV0dXJuIGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0cnVlKTtcblx0XHR9XG5cdH0pO1xufTtcblxuQmFzZS5leHBvcnRzLlBhcGVyU2NyaXB0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgZXhwb3J0cywgZGVmaW5lLFxuXHRcdHNjb3BlID0gdGhpcztcbiFmdW5jdGlvbihlLHIpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP3IoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLHIpOihyKGUuYWNvcm58fChlLmFjb3JuPXt9KSksdm9pZCAwKX0odGhpcyxmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe2ZyPWV8fHt9O2Zvcih2YXIgciBpbiBtcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZnIscil8fChmcltyXT1tcltyXSk7aHI9ZnIuc291cmNlRmlsZXx8bnVsbH1mdW5jdGlvbiB0KGUscil7dmFyIHQ9dnIoZHIsZSk7cis9XCIgKFwiK3QubGluZStcIjpcIit0LmNvbHVtbitcIilcIjt2YXIgbj1uZXcgU3ludGF4RXJyb3Iocik7dGhyb3cgbi5wb3M9ZSxuLmxvYz10LG4ucmFpc2VkQXQ9YnIsbn1mdW5jdGlvbiBuKGUpe2Z1bmN0aW9uIHIoZSl7aWYoMT09ZS5sZW5ndGgpcmV0dXJuIHQrPVwicmV0dXJuIHN0ciA9PT0gXCIrSlNPTi5zdHJpbmdpZnkoZVswXSkrXCI7XCI7dCs9XCJzd2l0Y2goc3RyKXtcIjtmb3IodmFyIHI9MDtyPGUubGVuZ3RoOysrcil0Kz1cImNhc2UgXCIrSlNPTi5zdHJpbmdpZnkoZVtyXSkrXCI6XCI7dCs9XCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCJ9ZT1lLnNwbGl0KFwiIFwiKTt2YXIgdD1cIlwiLG49W107ZTpmb3IodmFyIGE9MDthPGUubGVuZ3RoOysrYSl7Zm9yKHZhciBvPTA7bzxuLmxlbmd0aDsrK28paWYobltvXVswXS5sZW5ndGg9PWVbYV0ubGVuZ3RoKXtuW29dLnB1c2goZVthXSk7Y29udGludWUgZX1uLnB1c2goW2VbYV1dKX1pZihuLmxlbmd0aD4zKXtuLnNvcnQoZnVuY3Rpb24oZSxyKXtyZXR1cm4gci5sZW5ndGgtZS5sZW5ndGh9KSx0Kz1cInN3aXRjaChzdHIubGVuZ3RoKXtcIjtmb3IodmFyIGE9MDthPG4ubGVuZ3RoOysrYSl7dmFyIGk9blthXTt0Kz1cImNhc2UgXCIraVswXS5sZW5ndGgrXCI6XCIscihpKX10Kz1cIn1cIn1lbHNlIHIoZSk7cmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLHQpfWZ1bmN0aW9uIGEoKXt0aGlzLmxpbmU9QXIsdGhpcy5jb2x1bW49YnItU3J9ZnVuY3Rpb24gbygpe0FyPTEsYnI9U3I9MCxFcj0hMCx1KCl9ZnVuY3Rpb24gaShlLHIpe2dyPWJyLGZyLmxvY2F0aW9ucyYmKGtyPW5ldyBhKSx3cj1lLHUoKSxDcj1yLEVyPWUuYmVmb3JlRXhwcn1mdW5jdGlvbiBzKCl7dmFyIGU9ZnIub25Db21tZW50JiZmci5sb2NhdGlvbnMmJm5ldyBhLHI9YnIsbj1kci5pbmRleE9mKFwiKi9cIixicis9Mik7aWYoLTE9PT1uJiZ0KGJyLTIsXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKSxicj1uKzIsZnIubG9jYXRpb25zKXtLdC5sYXN0SW5kZXg9cjtmb3IodmFyIG87KG89S3QuZXhlYyhkcikpJiZvLmluZGV4PGJyOykrK0FyLFNyPW8uaW5kZXgrb1swXS5sZW5ndGh9ZnIub25Db21tZW50JiZmci5vbkNvbW1lbnQoITAsZHIuc2xpY2UocisyLG4pLHIsYnIsZSxmci5sb2NhdGlvbnMmJm5ldyBhKX1mdW5jdGlvbiBjKCl7Zm9yKHZhciBlPWJyLHI9ZnIub25Db21tZW50JiZmci5sb2NhdGlvbnMmJm5ldyBhLHQ9ZHIuY2hhckNvZGVBdChicis9Mik7cHI+YnImJjEwIT09dCYmMTMhPT10JiY4MjMyIT09dCYmODIzMyE9PXQ7KSsrYnIsdD1kci5jaGFyQ29kZUF0KGJyKTtmci5vbkNvbW1lbnQmJmZyLm9uQ29tbWVudCghMSxkci5zbGljZShlKzIsYnIpLGUsYnIscixmci5sb2NhdGlvbnMmJm5ldyBhKX1mdW5jdGlvbiB1KCl7Zm9yKDtwcj5icjspe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIpO2lmKDMyPT09ZSkrK2JyO2Vsc2UgaWYoMTM9PT1lKXsrK2JyO3ZhciByPWRyLmNoYXJDb2RlQXQoYnIpOzEwPT09ciYmKyticixmci5sb2NhdGlvbnMmJigrK0FyLFNyPWJyKX1lbHNlIGlmKDEwPT09ZXx8ODIzMj09PWV8fDgyMzM9PT1lKSsrYnIsZnIubG9jYXRpb25zJiYoKytBcixTcj1icik7ZWxzZSBpZihlPjgmJjE0PmUpKyticjtlbHNlIGlmKDQ3PT09ZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtpZig0Mj09PXIpcygpO2Vsc2V7aWYoNDchPT1yKWJyZWFrO2MoKX19ZWxzZSBpZigxNjA9PT1lKSsrYnI7ZWxzZXtpZighKGU+PTU3NjAmJkp0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSkpKWJyZWFrOysrYnJ9fX1mdW5jdGlvbiBsKCl7dmFyIGU9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gZT49NDgmJjU3Pj1lP0UoITApOigrK2JyLGkoeHQpKX1mdW5jdGlvbiBmKCl7dmFyIGU9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gRXI/KCsrYnIsaygpKTo2MT09PWU/eChFdCwyKTp4KHd0LDEpfWZ1bmN0aW9uIGQoKXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiA2MT09PWU/eChFdCwyKTp4KER0LDEpfWZ1bmN0aW9uIHAoZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gcj09PWU/eCgxMjQ9PT1lP0x0OlV0LDIpOjYxPT09cj94KEV0LDIpOngoMTI0PT09ZT9SdDpUdCwxKX1mdW5jdGlvbiBoKCl7dmFyIGU9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1lP3goRXQsMik6eChWdCwxKX1mdW5jdGlvbiBtKGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIHI9PT1lPzQ1PT1yJiY2Mj09ZHIuY2hhckNvZGVBdChicisyKSYmR3QudGVzdChkci5zbGljZShMcixicikpPyhicis9MyxjKCksdSgpLGcoKSk6eChTdCwyKTo2MT09PXI/eChFdCwyKTp4KEF0LDEpfWZ1bmN0aW9uIHYoZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKSx0PTE7cmV0dXJuIHI9PT1lPyh0PTYyPT09ZSYmNjI9PT1kci5jaGFyQ29kZUF0KGJyKzIpPzM6Miw2MT09PWRyLmNoYXJDb2RlQXQoYnIrdCk/eChFdCx0KzEpOngoanQsdCkpOjMzPT1yJiY2MD09ZSYmNDU9PWRyLmNoYXJDb2RlQXQoYnIrMikmJjQ1PT1kci5jaGFyQ29kZUF0KGJyKzMpPyhicis9NCxjKCksdSgpLGcoKSk6KDYxPT09ciYmKHQ9NjE9PT1kci5jaGFyQ29kZUF0KGJyKzIpPzM6MikseChPdCx0KSl9ZnVuY3Rpb24gYihlKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiA2MT09PXI/eChxdCw2MT09PWRyLmNoYXJDb2RlQXQoYnIrMik/MzoyKTp4KDYxPT09ZT9DdDpJdCwxKX1mdW5jdGlvbiB5KGUpe3N3aXRjaChlKXtjYXNlIDQ2OnJldHVybiBsKCk7Y2FzZSA0MDpyZXR1cm4rK2JyLGkobXQpO2Nhc2UgNDE6cmV0dXJuKyticixpKHZ0KTtjYXNlIDU5OnJldHVybisrYnIsaSh5dCk7Y2FzZSA0NDpyZXR1cm4rK2JyLGkoYnQpO2Nhc2UgOTE6cmV0dXJuKyticixpKGZ0KTtjYXNlIDkzOnJldHVybisrYnIsaShkdCk7Y2FzZSAxMjM6cmV0dXJuKyticixpKHB0KTtjYXNlIDEyNTpyZXR1cm4rK2JyLGkoaHQpO2Nhc2UgNTg6cmV0dXJuKyticixpKGd0KTtjYXNlIDYzOnJldHVybisrYnIsaShrdCk7Y2FzZSA0ODp2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO2lmKDEyMD09PXJ8fDg4PT09cilyZXR1cm4gQygpO2Nhc2UgNDk6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTI6Y2FzZSA1MzpjYXNlIDU0OmNhc2UgNTU6Y2FzZSA1NjpjYXNlIDU3OnJldHVybiBFKCExKTtjYXNlIDM0OmNhc2UgMzk6cmV0dXJuIEEoZSk7Y2FzZSA0NzpyZXR1cm4gZihlKTtjYXNlIDM3OmNhc2UgNDI6cmV0dXJuIGQoKTtjYXNlIDEyNDpjYXNlIDM4OnJldHVybiBwKGUpO2Nhc2UgOTQ6cmV0dXJuIGgoKTtjYXNlIDQzOmNhc2UgNDU6cmV0dXJuIG0oZSk7Y2FzZSA2MDpjYXNlIDYyOnJldHVybiB2KGUpO2Nhc2UgNjE6Y2FzZSAzMzpyZXR1cm4gYihlKTtjYXNlIDEyNjpyZXR1cm4geChJdCwxKX1yZXR1cm4hMX1mdW5jdGlvbiBnKGUpe2lmKGU/YnI9eXIrMTp5cj1icixmci5sb2NhdGlvbnMmJih4cj1uZXcgYSksZSlyZXR1cm4gaygpO2lmKGJyPj1wcilyZXR1cm4gaShCcik7dmFyIHI9ZHIuY2hhckNvZGVBdChicik7aWYoUXQocil8fDkyPT09cilyZXR1cm4gTCgpO3ZhciBuPXkocik7aWYobj09PSExKXt2YXIgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHIpO2lmKFwiXFxcXFwiPT09b3x8JHQudGVzdChvKSlyZXR1cm4gTCgpO3QoYnIsXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbytcIidcIil9cmV0dXJuIG59ZnVuY3Rpb24geChlLHIpe3ZhciB0PWRyLnNsaWNlKGJyLGJyK3IpO2JyKz1yLGkoZSx0KX1mdW5jdGlvbiBrKCl7Zm9yKHZhciBlLHIsbj1cIlwiLGE9YnI7Oyl7YnI+PXByJiZ0KGEsXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO3ZhciBvPWRyLmNoYXJBdChicik7aWYoR3QudGVzdChvKSYmdChhLFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKSxlKWU9ITE7ZWxzZXtpZihcIltcIj09PW8pcj0hMDtlbHNlIGlmKFwiXVwiPT09byYmcilyPSExO2Vsc2UgaWYoXCIvXCI9PT1vJiYhcilicmVhaztlPVwiXFxcXFwiPT09b30rK2JyfXZhciBuPWRyLnNsaWNlKGEsYnIpOysrYnI7dmFyIHM9SSgpO3JldHVybiBzJiYhL15bZ21zaXldKiQvLnRlc3QocykmJnQoYSxcIkludmFsaWQgcmVnZXhwIGZsYWdcIiksaShqcixuZXcgUmVnRXhwKG4scykpfWZ1bmN0aW9uIHcoZSxyKXtmb3IodmFyIHQ9YnIsbj0wLGE9MCxvPW51bGw9PXI/MS8wOnI7bz5hOysrYSl7dmFyIGkscz1kci5jaGFyQ29kZUF0KGJyKTtpZihpPXM+PTk3P3MtOTcrMTA6cz49NjU/cy02NSsxMDpzPj00OCYmNTc+PXM/cy00ODoxLzAsaT49ZSlicmVhazsrK2JyLG49biplK2l9cmV0dXJuIGJyPT09dHx8bnVsbCE9ciYmYnItdCE9PXI/bnVsbDpufWZ1bmN0aW9uIEMoKXticis9Mjt2YXIgZT13KDE2KTtyZXR1cm4gbnVsbD09ZSYmdCh5cisyLFwiRXhwZWN0ZWQgaGV4YWRlY2ltYWwgbnVtYmVyXCIpLFF0KGRyLmNoYXJDb2RlQXQoYnIpKSYmdChicixcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpLGkoT3IsZSl9ZnVuY3Rpb24gRShlKXt2YXIgcj1icixuPSExLGE9NDg9PT1kci5jaGFyQ29kZUF0KGJyKTtlfHxudWxsIT09dygxMCl8fHQocixcIkludmFsaWQgbnVtYmVyXCIpLDQ2PT09ZHIuY2hhckNvZGVBdChicikmJigrK2JyLHcoMTApLG49ITApO3ZhciBvPWRyLmNoYXJDb2RlQXQoYnIpOyg2OT09PW98fDEwMT09PW8pJiYobz1kci5jaGFyQ29kZUF0KCsrYnIpLCg0Mz09PW98fDQ1PT09bykmJisrYnIsbnVsbD09PXcoMTApJiZ0KHIsXCJJbnZhbGlkIG51bWJlclwiKSxuPSEwKSxRdChkci5jaGFyQ29kZUF0KGJyKSkmJnQoYnIsXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTt2YXIgcyxjPWRyLnNsaWNlKHIsYnIpO3JldHVybiBuP3M9cGFyc2VGbG9hdChjKTphJiYxIT09Yy5sZW5ndGg/L1s4OV0vLnRlc3QoYyl8fFRyP3QocixcIkludmFsaWQgbnVtYmVyXCIpOnM9cGFyc2VJbnQoYyw4KTpzPXBhcnNlSW50KGMsMTApLGkoT3Iscyl9ZnVuY3Rpb24gQShlKXticisrO2Zvcih2YXIgcj1cIlwiOzspe2JyPj1wciYmdCh5cixcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7dmFyIG49ZHIuY2hhckNvZGVBdChicik7aWYobj09PWUpcmV0dXJuKyticixpKERyLHIpO2lmKDkyPT09bil7bj1kci5jaGFyQ29kZUF0KCsrYnIpO3ZhciBhPS9eWzAtN10rLy5leGVjKGRyLnNsaWNlKGJyLGJyKzMpKTtmb3IoYSYmKGE9YVswXSk7YSYmcGFyc2VJbnQoYSw4KT4yNTU7KWE9YS5zbGljZSgwLGEubGVuZ3RoLTEpO2lmKFwiMFwiPT09YSYmKGE9bnVsbCksKyticixhKVRyJiZ0KGJyLTIsXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpLHIrPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYSw4KSksYnIrPWEubGVuZ3RoLTE7ZWxzZSBzd2l0Y2gobil7Y2FzZSAxMTA6cis9XCJcXG5cIjticmVhaztjYXNlIDExNDpyKz1cIlxcclwiO2JyZWFrO2Nhc2UgMTIwOnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUygyKSk7YnJlYWs7Y2FzZSAxMTc6cis9U3RyaW5nLmZyb21DaGFyQ29kZShTKDQpKTticmVhaztjYXNlIDg1OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUyg4KSk7YnJlYWs7Y2FzZSAxMTY6cis9XCJcdFwiO2JyZWFrO2Nhc2UgOTg6cis9XCJcXGJcIjticmVhaztjYXNlIDExODpyKz1cIlx1MDAwYlwiO2JyZWFrO2Nhc2UgMTAyOnIrPVwiXFxmXCI7YnJlYWs7Y2FzZSA0ODpyKz1cIlxcMFwiO2JyZWFrO2Nhc2UgMTM6MTA9PT1kci5jaGFyQ29kZUF0KGJyKSYmKyticjtjYXNlIDEwOmZyLmxvY2F0aW9ucyYmKFNyPWJyLCsrQXIpO2JyZWFrO2RlZmF1bHQ6cis9U3RyaW5nLmZyb21DaGFyQ29kZShuKX19ZWxzZSgxMz09PW58fDEwPT09bnx8ODIzMj09PW58fDgyMzM9PT1uKSYmdCh5cixcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIikscis9U3RyaW5nLmZyb21DaGFyQ29kZShuKSwrK2JyfX1mdW5jdGlvbiBTKGUpe3ZhciByPXcoMTYsZSk7cmV0dXJuIG51bGw9PT1yJiZ0KHlyLFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIikscn1mdW5jdGlvbiBJKCl7QnQ9ITE7Zm9yKHZhciBlLHI9ITAsbj1icjs7KXt2YXIgYT1kci5jaGFyQ29kZUF0KGJyKTtpZihZdChhKSlCdCYmKGUrPWRyLmNoYXJBdChicikpLCsrYnI7ZWxzZXtpZig5MiE9PWEpYnJlYWs7QnR8fChlPWRyLnNsaWNlKG4sYnIpKSxCdD0hMCwxMTchPWRyLmNoYXJDb2RlQXQoKyticikmJnQoYnIsXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpLCsrYnI7dmFyIG89Uyg0KSxpPVN0cmluZy5mcm9tQ2hhckNvZGUobyk7aXx8dChici0xLFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKSwocj9RdChvKTpZdChvKSl8fHQoYnItNCxcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIiksZSs9aX1yPSExfXJldHVybiBCdD9lOmRyLnNsaWNlKG4sYnIpfWZ1bmN0aW9uIEwoKXt2YXIgZT1JKCkscj1GcjtyZXR1cm4gQnR8fChXdChlKT9yPWx0W2VdOihmci5mb3JiaWRSZXNlcnZlZCYmKDM9PT1mci5lY21hVmVyc2lvbj9NdDp6dCkoZSl8fFRyJiZYdChlKSkmJnQoeXIsXCJUaGUga2V5d29yZCAnXCIrZStcIicgaXMgcmVzZXJ2ZWRcIikpLGkocixlKX1mdW5jdGlvbiBVKCl7SXI9eXIsTHI9Z3IsVXI9a3IsZygpfWZ1bmN0aW9uIFIoZSl7aWYoVHI9ZSxicj1Mcixmci5sb2NhdGlvbnMpZm9yKDtTcj5icjspU3I9ZHIubGFzdEluZGV4T2YoXCJcXG5cIixTci0yKSsxLC0tQXI7dSgpLGcoKX1mdW5jdGlvbiBWKCl7dGhpcy50eXBlPW51bGwsdGhpcy5zdGFydD15cix0aGlzLmVuZD1udWxsfWZ1bmN0aW9uIFQoKXt0aGlzLnN0YXJ0PXhyLHRoaXMuZW5kPW51bGwsbnVsbCE9PWhyJiYodGhpcy5zb3VyY2U9aHIpfWZ1bmN0aW9uIHEoKXt2YXIgZT1uZXcgVjtyZXR1cm4gZnIubG9jYXRpb25zJiYoZS5sb2M9bmV3IFQpLGZyLnJhbmdlcyYmKGUucmFuZ2U9W3lyLDBdKSxlfWZ1bmN0aW9uIE8oZSl7dmFyIHI9bmV3IFY7cmV0dXJuIHIuc3RhcnQ9ZS5zdGFydCxmci5sb2NhdGlvbnMmJihyLmxvYz1uZXcgVCxyLmxvYy5zdGFydD1lLmxvYy5zdGFydCksZnIucmFuZ2VzJiYoci5yYW5nZT1bZS5yYW5nZVswXSwwXSkscn1mdW5jdGlvbiBqKGUscil7cmV0dXJuIGUudHlwZT1yLGUuZW5kPUxyLGZyLmxvY2F0aW9ucyYmKGUubG9jLmVuZD1VciksZnIucmFuZ2VzJiYoZS5yYW5nZVsxXT1MciksZX1mdW5jdGlvbiBEKGUpe3JldHVybiBmci5lY21hVmVyc2lvbj49NSYmXCJFeHByZXNzaW9uU3RhdGVtZW50XCI9PT1lLnR5cGUmJlwiTGl0ZXJhbFwiPT09ZS5leHByZXNzaW9uLnR5cGUmJlwidXNlIHN0cmljdFwiPT09ZS5leHByZXNzaW9uLnZhbHVlfWZ1bmN0aW9uIEYoZSl7cmV0dXJuIHdyPT09ZT8oVSgpLCEwKTp2b2lkIDB9ZnVuY3Rpb24gQigpe3JldHVybiFmci5zdHJpY3RTZW1pY29sb25zJiYod3I9PT1Ccnx8d3I9PT1odHx8R3QudGVzdChkci5zbGljZShMcix5cikpKX1mdW5jdGlvbiBNKCl7Rih5dCl8fEIoKXx8WCgpfWZ1bmN0aW9uIHooZSl7d3I9PT1lP1UoKTpYKCl9ZnVuY3Rpb24gWCgpe3QoeXIsXCJVbmV4cGVjdGVkIHRva2VuXCIpfWZ1bmN0aW9uIE4oZSl7XCJJZGVudGlmaWVyXCIhPT1lLnR5cGUmJlwiTWVtYmVyRXhwcmVzc2lvblwiIT09ZS50eXBlJiZ0KGUuc3RhcnQsXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpLFRyJiZcIklkZW50aWZpZXJcIj09PWUudHlwZSYmTnQoZS5uYW1lKSYmdChlLnN0YXJ0LFwiQXNzaWduaW5nIHRvIFwiK2UubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiKX1mdW5jdGlvbiBXKGUpe0lyPUxyPWJyLGZyLmxvY2F0aW9ucyYmKFVyPW5ldyBhKSxScj1Ucj1udWxsLFZyPVtdLGcoKTt2YXIgcj1lfHxxKCksdD0hMDtmb3IoZXx8KHIuYm9keT1bXSk7d3IhPT1Ccjspe3ZhciBuPUooKTtyLmJvZHkucHVzaChuKSx0JiZEKG4pJiZSKCEwKSx0PSExfXJldHVybiBqKHIsXCJQcm9ncmFtXCIpfWZ1bmN0aW9uIEooKXsod3I9PT13dHx8d3I9PT1FdCYmXCIvPVwiPT1DcikmJmcoITApO3ZhciBlPXdyLHI9cSgpO3N3aXRjaChlKXtjYXNlIE1yOmNhc2UgTnI6VSgpO3ZhciBuPWU9PT1NcjtGKHl0KXx8QigpP3IubGFiZWw9bnVsbDp3ciE9PUZyP1goKTooci5sYWJlbD1scigpLE0oKSk7Zm9yKHZhciBhPTA7YTxWci5sZW5ndGg7KythKXt2YXIgbz1WclthXTtpZihudWxsPT1yLmxhYmVsfHxvLm5hbWU9PT1yLmxhYmVsLm5hbWUpe2lmKG51bGwhPW8ua2luZCYmKG58fFwibG9vcFwiPT09by5raW5kKSlicmVhaztpZihyLmxhYmVsJiZuKWJyZWFrfX1yZXR1cm4gYT09PVZyLmxlbmd0aCYmdChyLnN0YXJ0LFwiVW5zeW50YWN0aWMgXCIrZS5rZXl3b3JkKSxqKHIsbj9cIkJyZWFrU3RhdGVtZW50XCI6XCJDb250aW51ZVN0YXRlbWVudFwiKTtjYXNlIFdyOnJldHVybiBVKCksTSgpLGoocixcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO2Nhc2UgUHI6cmV0dXJuIFUoKSxWci5wdXNoKFp0KSxyLmJvZHk9SigpLFZyLnBvcCgpLHoodHQpLHIudGVzdD1QKCksTSgpLGoocixcIkRvV2hpbGVTdGF0ZW1lbnRcIik7Y2FzZSBfcjppZihVKCksVnIucHVzaChadCkseihtdCksd3I9PT15dClyZXR1cm4gJChyLG51bGwpO2lmKHdyPT09cnQpe3ZhciBpPXEoKTtyZXR1cm4gVSgpLEcoaSwhMCksaihpLFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSwxPT09aS5kZWNsYXJhdGlvbnMubGVuZ3RoJiZGKHV0KT9fKHIsaSk6JChyLGkpfXZhciBpPUsoITEsITApO3JldHVybiBGKHV0KT8oTihpKSxfKHIsaSkpOiQocixpKTtjYXNlIEdyOnJldHVybiBVKCksY3IociwhMCk7Y2FzZSBLcjpyZXR1cm4gVSgpLHIudGVzdD1QKCksci5jb25zZXF1ZW50PUooKSxyLmFsdGVybmF0ZT1GKEhyKT9KKCk6bnVsbCxqKHIsXCJJZlN0YXRlbWVudFwiKTtjYXNlIFFyOnJldHVybiBScnx8dCh5cixcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIiksVSgpLEYoeXQpfHxCKCk/ci5hcmd1bWVudD1udWxsOihyLmFyZ3VtZW50PUsoKSxNKCkpLGoocixcIlJldHVyblN0YXRlbWVudFwiKTtjYXNlIFlyOlUoKSxyLmRpc2NyaW1pbmFudD1QKCksci5jYXNlcz1bXSx6KHB0KSxWci5wdXNoKGVuKTtmb3IodmFyIHMsYzt3ciE9aHQ7KWlmKHdyPT09enJ8fHdyPT09SnIpe3ZhciB1PXdyPT09enI7cyYmaihzLFwiU3dpdGNoQ2FzZVwiKSxyLmNhc2VzLnB1c2gocz1xKCkpLHMuY29uc2VxdWVudD1bXSxVKCksdT9zLnRlc3Q9SygpOihjJiZ0KElyLFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpLGM9ITAscy50ZXN0PW51bGwpLHooZ3QpfWVsc2Ugc3x8WCgpLHMuY29uc2VxdWVudC5wdXNoKEooKSk7cmV0dXJuIHMmJmoocyxcIlN3aXRjaENhc2VcIiksVSgpLFZyLnBvcCgpLGoocixcIlN3aXRjaFN0YXRlbWVudFwiKTtjYXNlIFpyOnJldHVybiBVKCksR3QudGVzdChkci5zbGljZShMcix5cikpJiZ0KExyLFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpLHIuYXJndW1lbnQ9SygpLE0oKSxqKHIsXCJUaHJvd1N0YXRlbWVudFwiKTtjYXNlIGV0OmlmKFUoKSxyLmJsb2NrPUgoKSxyLmhhbmRsZXI9bnVsbCx3cj09PVhyKXt2YXIgbD1xKCk7VSgpLHoobXQpLGwucGFyYW09bHIoKSxUciYmTnQobC5wYXJhbS5uYW1lKSYmdChsLnBhcmFtLnN0YXJ0LFwiQmluZGluZyBcIitsLnBhcmFtLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIikseih2dCksbC5ndWFyZD1udWxsLGwuYm9keT1IKCksci5oYW5kbGVyPWoobCxcIkNhdGNoQ2xhdXNlXCIpfXJldHVybiByLmd1YXJkZWRIYW5kbGVycz1xcixyLmZpbmFsaXplcj1GKCRyKT9IKCk6bnVsbCxyLmhhbmRsZXJ8fHIuZmluYWxpemVyfHx0KHIuc3RhcnQsXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpLGoocixcIlRyeVN0YXRlbWVudFwiKTtjYXNlIHJ0OnJldHVybiBVKCksRyhyKSxNKCksaihyLFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtjYXNlIHR0OnJldHVybiBVKCksci50ZXN0PVAoKSxWci5wdXNoKFp0KSxyLmJvZHk9SigpLFZyLnBvcCgpLGoocixcIldoaWxlU3RhdGVtZW50XCIpO2Nhc2UgbnQ6cmV0dXJuIFRyJiZ0KHlyLFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpLFUoKSxyLm9iamVjdD1QKCksci5ib2R5PUooKSxqKHIsXCJXaXRoU3RhdGVtZW50XCIpO2Nhc2UgcHQ6cmV0dXJuIEgoKTtjYXNlIHl0OnJldHVybiBVKCksaihyLFwiRW1wdHlTdGF0ZW1lbnRcIik7ZGVmYXVsdDp2YXIgZj1DcixkPUsoKTtpZihlPT09RnImJlwiSWRlbnRpZmllclwiPT09ZC50eXBlJiZGKGd0KSl7Zm9yKHZhciBhPTA7YTxWci5sZW5ndGg7KythKVZyW2FdLm5hbWU9PT1mJiZ0KGQuc3RhcnQsXCJMYWJlbCAnXCIrZitcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTt2YXIgcD13ci5pc0xvb3A/XCJsb29wXCI6d3I9PT1Zcj9cInN3aXRjaFwiOm51bGw7cmV0dXJuIFZyLnB1c2goe25hbWU6ZixraW5kOnB9KSxyLmJvZHk9SigpLFZyLnBvcCgpLHIubGFiZWw9ZCxqKHIsXCJMYWJlbGVkU3RhdGVtZW50XCIpfXJldHVybiByLmV4cHJlc3Npb249ZCxNKCksaihyLFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKX19ZnVuY3Rpb24gUCgpe3oobXQpO3ZhciBlPUsoKTtyZXR1cm4geih2dCksZX1mdW5jdGlvbiBIKGUpe3ZhciByLHQ9cSgpLG49ITAsYT0hMTtmb3IodC5ib2R5PVtdLHoocHQpOyFGKGh0KTspe3ZhciBvPUooKTt0LmJvZHkucHVzaChvKSxuJiZlJiZEKG8pJiYocj1hLFIoYT0hMCkpLG49ITF9cmV0dXJuIGEmJiFyJiZSKCExKSxqKHQsXCJCbG9ja1N0YXRlbWVudFwiKX1mdW5jdGlvbiAkKGUscil7cmV0dXJuIGUuaW5pdD1yLHooeXQpLGUudGVzdD13cj09PXl0P251bGw6SygpLHooeXQpLGUudXBkYXRlPXdyPT09dnQ/bnVsbDpLKCkseih2dCksZS5ib2R5PUooKSxWci5wb3AoKSxqKGUsXCJGb3JTdGF0ZW1lbnRcIil9ZnVuY3Rpb24gXyhlLHIpe3JldHVybiBlLmxlZnQ9cixlLnJpZ2h0PUsoKSx6KHZ0KSxlLmJvZHk9SigpLFZyLnBvcCgpLGooZSxcIkZvckluU3RhdGVtZW50XCIpfWZ1bmN0aW9uIEcoZSxyKXtmb3IoZS5kZWNsYXJhdGlvbnM9W10sZS5raW5kPVwidmFyXCI7Oyl7dmFyIG49cSgpO2lmKG4uaWQ9bHIoKSxUciYmTnQobi5pZC5uYW1lKSYmdChuLmlkLnN0YXJ0LFwiQmluZGluZyBcIituLmlkLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIiksbi5pbml0PUYoQ3QpP0soITAscik6bnVsbCxlLmRlY2xhcmF0aW9ucy5wdXNoKGoobixcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSksIUYoYnQpKWJyZWFrfXJldHVybiBlfWZ1bmN0aW9uIEsoZSxyKXt2YXIgdD1RKHIpO2lmKCFlJiZ3cj09PWJ0KXt2YXIgbj1PKHQpO2ZvcihuLmV4cHJlc3Npb25zPVt0XTtGKGJ0KTspbi5leHByZXNzaW9ucy5wdXNoKFEocikpO3JldHVybiBqKG4sXCJTZXF1ZW5jZUV4cHJlc3Npb25cIil9cmV0dXJuIHR9ZnVuY3Rpb24gUShlKXt2YXIgcj1ZKGUpO2lmKHdyLmlzQXNzaWduKXt2YXIgdD1PKHIpO3JldHVybiB0Lm9wZXJhdG9yPUNyLHQubGVmdD1yLFUoKSx0LnJpZ2h0PVEoZSksTihyKSxqKHQsXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKX1yZXR1cm4gcn1mdW5jdGlvbiBZKGUpe3ZhciByPVooZSk7aWYoRihrdCkpe3ZhciB0PU8ocik7cmV0dXJuIHQudGVzdD1yLHQuY29uc2VxdWVudD1LKCEwKSx6KGd0KSx0LmFsdGVybmF0ZT1LKCEwLGUpLGoodCxcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKX1yZXR1cm4gcn1mdW5jdGlvbiBaKGUpe3JldHVybiBlcihycigpLC0xLGUpfWZ1bmN0aW9uIGVyKGUscix0KXt2YXIgbj13ci5iaW5vcDtpZihudWxsIT1uJiYoIXR8fHdyIT09dXQpJiZuPnIpe3ZhciBhPU8oZSk7YS5sZWZ0PWUsYS5vcGVyYXRvcj1DcixVKCksYS5yaWdodD1lcihycigpLG4sdCk7dmFyIG89aihhLC8mJnxcXHxcXHwvLnRlc3QoYS5vcGVyYXRvcik/XCJMb2dpY2FsRXhwcmVzc2lvblwiOlwiQmluYXJ5RXhwcmVzc2lvblwiKTtyZXR1cm4gZXIobyxyLHQpfXJldHVybiBlfWZ1bmN0aW9uIHJyKCl7aWYod3IucHJlZml4KXt2YXIgZT1xKCkscj13ci5pc1VwZGF0ZTtyZXR1cm4gZS5vcGVyYXRvcj1DcixlLnByZWZpeD0hMCxFcj0hMCxVKCksZS5hcmd1bWVudD1ycigpLHI/TihlLmFyZ3VtZW50KTpUciYmXCJkZWxldGVcIj09PWUub3BlcmF0b3ImJlwiSWRlbnRpZmllclwiPT09ZS5hcmd1bWVudC50eXBlJiZ0KGUuc3RhcnQsXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKSxqKGUscj9cIlVwZGF0ZUV4cHJlc3Npb25cIjpcIlVuYXJ5RXhwcmVzc2lvblwiKX1mb3IodmFyIG49dHIoKTt3ci5wb3N0Zml4JiYhQigpOyl7dmFyIGU9TyhuKTtlLm9wZXJhdG9yPUNyLGUucHJlZml4PSExLGUuYXJndW1lbnQ9bixOKG4pLFUoKSxuPWooZSxcIlVwZGF0ZUV4cHJlc3Npb25cIil9cmV0dXJuIG59ZnVuY3Rpb24gdHIoKXtyZXR1cm4gbnIoYXIoKSl9ZnVuY3Rpb24gbnIoZSxyKXtpZihGKHh0KSl7dmFyIHQ9TyhlKTtyZXR1cm4gdC5vYmplY3Q9ZSx0LnByb3BlcnR5PWxyKCEwKSx0LmNvbXB1dGVkPSExLG5yKGoodCxcIk1lbWJlckV4cHJlc3Npb25cIikscil9aWYoRihmdCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQub2JqZWN0PWUsdC5wcm9wZXJ0eT1LKCksdC5jb21wdXRlZD0hMCx6KGR0KSxucihqKHQsXCJNZW1iZXJFeHByZXNzaW9uXCIpLHIpfWlmKCFyJiZGKG10KSl7dmFyIHQ9TyhlKTtyZXR1cm4gdC5jYWxsZWU9ZSx0LmFyZ3VtZW50cz11cih2dCwhMSksbnIoaih0LFwiQ2FsbEV4cHJlc3Npb25cIikscil9cmV0dXJuIGV9ZnVuY3Rpb24gYXIoKXtzd2l0Y2god3Ipe2Nhc2Ugb3Q6dmFyIGU9cSgpO3JldHVybiBVKCksaihlLFwiVGhpc0V4cHJlc3Npb25cIik7Y2FzZSBGcjpyZXR1cm4gbHIoKTtjYXNlIE9yOmNhc2UgRHI6Y2FzZSBqcjp2YXIgZT1xKCk7cmV0dXJuIGUudmFsdWU9Q3IsZS5yYXc9ZHIuc2xpY2UoeXIsZ3IpLFUoKSxqKGUsXCJMaXRlcmFsXCIpO2Nhc2UgaXQ6Y2FzZSBzdDpjYXNlIGN0OnZhciBlPXEoKTtyZXR1cm4gZS52YWx1ZT13ci5hdG9tVmFsdWUsZS5yYXc9d3Iua2V5d29yZCxVKCksaihlLFwiTGl0ZXJhbFwiKTtjYXNlIG10OnZhciByPXhyLHQ9eXI7VSgpO3ZhciBuPUsoKTtyZXR1cm4gbi5zdGFydD10LG4uZW5kPWdyLGZyLmxvY2F0aW9ucyYmKG4ubG9jLnN0YXJ0PXIsbi5sb2MuZW5kPWtyKSxmci5yYW5nZXMmJihuLnJhbmdlPVt0LGdyXSkseih2dCksbjtjYXNlIGZ0OnZhciBlPXEoKTtyZXR1cm4gVSgpLGUuZWxlbWVudHM9dXIoZHQsITAsITApLGooZSxcIkFycmF5RXhwcmVzc2lvblwiKTtjYXNlIHB0OnJldHVybiBpcigpO2Nhc2UgR3I6dmFyIGU9cSgpO3JldHVybiBVKCksY3IoZSwhMSk7Y2FzZSBhdDpyZXR1cm4gb3IoKTtkZWZhdWx0OlgoKX19ZnVuY3Rpb24gb3IoKXt2YXIgZT1xKCk7cmV0dXJuIFUoKSxlLmNhbGxlZT1ucihhcigpLCEwKSxlLmFyZ3VtZW50cz1GKG10KT91cih2dCwhMSk6cXIsaihlLFwiTmV3RXhwcmVzc2lvblwiKX1mdW5jdGlvbiBpcigpe3ZhciBlPXEoKSxyPSEwLG49ITE7Zm9yKGUucHJvcGVydGllcz1bXSxVKCk7IUYoaHQpOyl7aWYocilyPSExO2Vsc2UgaWYoeihidCksZnIuYWxsb3dUcmFpbGluZ0NvbW1hcyYmRihodCkpYnJlYWs7dmFyIGEsbz17a2V5OnNyKCl9LGk9ITE7aWYoRihndCk/KG8udmFsdWU9SyghMCksYT1vLmtpbmQ9XCJpbml0XCIpOmZyLmVjbWFWZXJzaW9uPj01JiZcIklkZW50aWZpZXJcIj09PW8ua2V5LnR5cGUmJihcImdldFwiPT09by5rZXkubmFtZXx8XCJzZXRcIj09PW8ua2V5Lm5hbWUpPyhpPW49ITAsYT1vLmtpbmQ9by5rZXkubmFtZSxvLmtleT1zcigpLHdyIT09bXQmJlgoKSxvLnZhbHVlPWNyKHEoKSwhMSkpOlgoKSxcIklkZW50aWZpZXJcIj09PW8ua2V5LnR5cGUmJihUcnx8bikpZm9yKHZhciBzPTA7czxlLnByb3BlcnRpZXMubGVuZ3RoOysrcyl7dmFyIGM9ZS5wcm9wZXJ0aWVzW3NdO2lmKGMua2V5Lm5hbWU9PT1vLmtleS5uYW1lKXt2YXIgdT1hPT1jLmtpbmR8fGkmJlwiaW5pdFwiPT09Yy5raW5kfHxcImluaXRcIj09PWEmJihcImdldFwiPT09Yy5raW5kfHxcInNldFwiPT09Yy5raW5kKTt1JiYhVHImJlwiaW5pdFwiPT09YSYmXCJpbml0XCI9PT1jLmtpbmQmJih1PSExKSx1JiZ0KG8ua2V5LnN0YXJ0LFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpfX1lLnByb3BlcnRpZXMucHVzaChvKX1yZXR1cm4gaihlLFwiT2JqZWN0RXhwcmVzc2lvblwiKX1mdW5jdGlvbiBzcigpe3JldHVybiB3cj09PU9yfHx3cj09PURyP2FyKCk6bHIoITApfWZ1bmN0aW9uIGNyKGUscil7d3I9PT1Gcj9lLmlkPWxyKCk6cj9YKCk6ZS5pZD1udWxsLGUucGFyYW1zPVtdO3ZhciBuPSEwO2Zvcih6KG10KTshRih2dCk7KW4/bj0hMTp6KGJ0KSxlLnBhcmFtcy5wdXNoKGxyKCkpO3ZhciBhPVJyLG89VnI7aWYoUnI9ITAsVnI9W10sZS5ib2R5PUgoITApLFJyPWEsVnI9byxUcnx8ZS5ib2R5LmJvZHkubGVuZ3RoJiZEKGUuYm9keS5ib2R5WzBdKSlmb3IodmFyIGk9ZS5pZD8tMTowO2k8ZS5wYXJhbXMubGVuZ3RoOysraSl7dmFyIHM9MD5pP2UuaWQ6ZS5wYXJhbXNbaV07aWYoKFh0KHMubmFtZSl8fE50KHMubmFtZSkpJiZ0KHMuc3RhcnQsXCJEZWZpbmluZyAnXCIrcy5uYW1lK1wiJyBpbiBzdHJpY3QgbW9kZVwiKSxpPj0wKWZvcih2YXIgYz0wO2k+YzsrK2Mpcy5uYW1lPT09ZS5wYXJhbXNbY10ubmFtZSYmdChzLnN0YXJ0LFwiQXJndW1lbnQgbmFtZSBjbGFzaCBpbiBzdHJpY3QgbW9kZVwiKX1yZXR1cm4gaihlLHI/XCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIil9ZnVuY3Rpb24gdXIoZSxyLHQpe2Zvcih2YXIgbj1bXSxhPSEwOyFGKGUpOyl7aWYoYSlhPSExO2Vsc2UgaWYoeihidCksciYmZnIuYWxsb3dUcmFpbGluZ0NvbW1hcyYmRihlKSlicmVhazt0JiZ3cj09PWJ0P24ucHVzaChudWxsKTpuLnB1c2goSyghMCkpfXJldHVybiBufWZ1bmN0aW9uIGxyKGUpe3ZhciByPXEoKTtyZXR1cm4gci5uYW1lPXdyPT09RnI/Q3I6ZSYmIWZyLmZvcmJpZFJlc2VydmVkJiZ3ci5rZXl3b3JkfHxYKCksRXI9ITEsVSgpLGoocixcIklkZW50aWZpZXJcIil9ZS52ZXJzaW9uPVwiMC40LjBcIjt2YXIgZnIsZHIscHIsaHI7ZS5wYXJzZT1mdW5jdGlvbihlLHQpe3JldHVybiBkcj1TdHJpbmcoZSkscHI9ZHIubGVuZ3RoLHIodCksbygpLFcoZnIucHJvZ3JhbSl9O3ZhciBtcj1lLmRlZmF1bHRPcHRpb25zPXtlY21hVmVyc2lvbjo1LHN0cmljdFNlbWljb2xvbnM6ITEsYWxsb3dUcmFpbGluZ0NvbW1hczohMCxmb3JiaWRSZXNlcnZlZDohMSxsb2NhdGlvbnM6ITEsb25Db21tZW50Om51bGwscmFuZ2VzOiExLHByb2dyYW06bnVsbCxzb3VyY2VGaWxlOm51bGx9LHZyPWUuZ2V0TGluZUluZm89ZnVuY3Rpb24oZSxyKXtmb3IodmFyIHQ9MSxuPTA7Oyl7S3QubGFzdEluZGV4PW47dmFyIGE9S3QuZXhlYyhlKTtpZighKGEmJmEuaW5kZXg8cikpYnJlYWs7Kyt0LG49YS5pbmRleCthWzBdLmxlbmd0aH1yZXR1cm57bGluZTp0LGNvbHVtbjpyLW59fTtlLnRva2VuaXplPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZyhlKSxhLnN0YXJ0PXlyLGEuZW5kPWdyLGEuc3RhcnRMb2M9eHIsYS5lbmRMb2M9a3IsYS50eXBlPXdyLGEudmFsdWU9Q3IsYX1kcj1TdHJpbmcoZSkscHI9ZHIubGVuZ3RoLHIodCksbygpO3ZhciBhPXt9O3JldHVybiBuLmp1bXBUbz1mdW5jdGlvbihlLHIpe2lmKGJyPWUsZnIubG9jYXRpb25zKXtBcj0xLFNyPUt0Lmxhc3RJbmRleD0wO2Zvcih2YXIgdDsodD1LdC5leGVjKGRyKSkmJnQuaW5kZXg8ZTspKytBcixTcj10LmluZGV4K3RbMF0ubGVuZ3RofUVyPXIsdSgpfSxufTt2YXIgYnIseXIsZ3IseHIsa3Isd3IsQ3IsRXIsQXIsU3IsSXIsTHIsVXIsUnIsVnIsVHIscXI9W10sT3I9e3R5cGU6XCJudW1cIn0sanI9e3R5cGU6XCJyZWdleHBcIn0sRHI9e3R5cGU6XCJzdHJpbmdcIn0sRnI9e3R5cGU6XCJuYW1lXCJ9LEJyPXt0eXBlOlwiZW9mXCJ9LE1yPXtrZXl3b3JkOlwiYnJlYWtcIn0senI9e2tleXdvcmQ6XCJjYXNlXCIsYmVmb3JlRXhwcjohMH0sWHI9e2tleXdvcmQ6XCJjYXRjaFwifSxOcj17a2V5d29yZDpcImNvbnRpbnVlXCJ9LFdyPXtrZXl3b3JkOlwiZGVidWdnZXJcIn0sSnI9e2tleXdvcmQ6XCJkZWZhdWx0XCJ9LFByPXtrZXl3b3JkOlwiZG9cIixpc0xvb3A6ITB9LEhyPXtrZXl3b3JkOlwiZWxzZVwiLGJlZm9yZUV4cHI6ITB9LCRyPXtrZXl3b3JkOlwiZmluYWxseVwifSxfcj17a2V5d29yZDpcImZvclwiLGlzTG9vcDohMH0sR3I9e2tleXdvcmQ6XCJmdW5jdGlvblwifSxLcj17a2V5d29yZDpcImlmXCJ9LFFyPXtrZXl3b3JkOlwicmV0dXJuXCIsYmVmb3JlRXhwcjohMH0sWXI9e2tleXdvcmQ6XCJzd2l0Y2hcIn0sWnI9e2tleXdvcmQ6XCJ0aHJvd1wiLGJlZm9yZUV4cHI6ITB9LGV0PXtrZXl3b3JkOlwidHJ5XCJ9LHJ0PXtrZXl3b3JkOlwidmFyXCJ9LHR0PXtrZXl3b3JkOlwid2hpbGVcIixpc0xvb3A6ITB9LG50PXtrZXl3b3JkOlwid2l0aFwifSxhdD17a2V5d29yZDpcIm5ld1wiLGJlZm9yZUV4cHI6ITB9LG90PXtrZXl3b3JkOlwidGhpc1wifSxpdD17a2V5d29yZDpcIm51bGxcIixhdG9tVmFsdWU6bnVsbH0sc3Q9e2tleXdvcmQ6XCJ0cnVlXCIsYXRvbVZhbHVlOiEwfSxjdD17a2V5d29yZDpcImZhbHNlXCIsYXRvbVZhbHVlOiExfSx1dD17a2V5d29yZDpcImluXCIsYmlub3A6NyxiZWZvcmVFeHByOiEwfSxsdD17XCJicmVha1wiOk1yLFwiY2FzZVwiOnpyLFwiY2F0Y2hcIjpYcixcImNvbnRpbnVlXCI6TnIsXCJkZWJ1Z2dlclwiOldyLFwiZGVmYXVsdFwiOkpyLFwiZG9cIjpQcixcImVsc2VcIjpIcixcImZpbmFsbHlcIjokcixcImZvclwiOl9yLFwiZnVuY3Rpb25cIjpHcixcImlmXCI6S3IsXCJyZXR1cm5cIjpRcixcInN3aXRjaFwiOllyLFwidGhyb3dcIjpacixcInRyeVwiOmV0LFwidmFyXCI6cnQsXCJ3aGlsZVwiOnR0LFwid2l0aFwiOm50LFwibnVsbFwiOml0LFwidHJ1ZVwiOnN0LFwiZmFsc2VcIjpjdCxcIm5ld1wiOmF0LFwiaW5cIjp1dCxcImluc3RhbmNlb2ZcIjp7a2V5d29yZDpcImluc3RhbmNlb2ZcIixiaW5vcDo3LGJlZm9yZUV4cHI6ITB9LFwidGhpc1wiOm90LFwidHlwZW9mXCI6e2tleXdvcmQ6XCJ0eXBlb2ZcIixwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH0sXCJ2b2lkXCI6e2tleXdvcmQ6XCJ2b2lkXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFwiZGVsZXRlXCI6e2tleXdvcmQ6XCJkZWxldGVcIixwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH19LGZ0PXt0eXBlOlwiW1wiLGJlZm9yZUV4cHI6ITB9LGR0PXt0eXBlOlwiXVwifSxwdD17dHlwZTpcIntcIixiZWZvcmVFeHByOiEwfSxodD17dHlwZTpcIn1cIn0sbXQ9e3R5cGU6XCIoXCIsYmVmb3JlRXhwcjohMH0sdnQ9e3R5cGU6XCIpXCJ9LGJ0PXt0eXBlOlwiLFwiLGJlZm9yZUV4cHI6ITB9LHl0PXt0eXBlOlwiO1wiLGJlZm9yZUV4cHI6ITB9LGd0PXt0eXBlOlwiOlwiLGJlZm9yZUV4cHI6ITB9LHh0PXt0eXBlOlwiLlwifSxrdD17dHlwZTpcIj9cIixiZWZvcmVFeHByOiEwfSx3dD17Ymlub3A6MTAsYmVmb3JlRXhwcjohMH0sQ3Q9e2lzQXNzaWduOiEwLGJlZm9yZUV4cHI6ITB9LEV0PXtpc0Fzc2lnbjohMCxiZWZvcmVFeHByOiEwfSxBdD17Ymlub3A6OSxwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH0sU3Q9e3Bvc3RmaXg6ITAscHJlZml4OiEwLGlzVXBkYXRlOiEwfSxJdD17cHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LEx0PXtiaW5vcDoxLGJlZm9yZUV4cHI6ITB9LFV0PXtiaW5vcDoyLGJlZm9yZUV4cHI6ITB9LFJ0PXtiaW5vcDozLGJlZm9yZUV4cHI6ITB9LFZ0PXtiaW5vcDo0LGJlZm9yZUV4cHI6ITB9LFR0PXtiaW5vcDo1LGJlZm9yZUV4cHI6ITB9LHF0PXtiaW5vcDo2LGJlZm9yZUV4cHI6ITB9LE90PXtiaW5vcDo3LGJlZm9yZUV4cHI6ITB9LGp0PXtiaW5vcDo4LGJlZm9yZUV4cHI6ITB9LER0PXtiaW5vcDoxMCxiZWZvcmVFeHByOiEwfTtlLnRva1R5cGVzPXticmFja2V0TDpmdCxicmFja2V0UjpkdCxicmFjZUw6cHQsYnJhY2VSOmh0LHBhcmVuTDptdCxwYXJlblI6dnQsY29tbWE6YnQsc2VtaTp5dCxjb2xvbjpndCxkb3Q6eHQscXVlc3Rpb246a3Qsc2xhc2g6d3QsZXE6Q3QsbmFtZTpGcixlb2Y6QnIsbnVtOk9yLHJlZ2V4cDpqcixzdHJpbmc6RHJ9O2Zvcih2YXIgRnQgaW4gbHQpZS50b2tUeXBlc1tcIl9cIitGdF09bHRbRnRdO3ZhciBCdCxNdD1uKFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiKSx6dD1uKFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIiksWHQ9bihcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIiksTnQ9bihcImV2YWwgYXJndW1lbnRzXCIpLFd0PW4oXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIiksSnQ9L1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLyxQdD1cIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCIsSHQ9XCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiLCR0PW5ldyBSZWdFeHAoXCJbXCIrUHQrXCJdXCIpLF90PW5ldyBSZWdFeHAoXCJbXCIrUHQrSHQrXCJdXCIpLEd0PS9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLyxLdD0vXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vZyxRdD1lLmlzSWRlbnRpZmllclN0YXJ0PWZ1bmN0aW9uKGUpe3JldHVybiA2NT5lPzM2PT09ZTo5MT5lPyEwOjk3PmU/OTU9PT1lOjEyMz5lPyEwOmU+PTE3MCYmJHQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX0sWXQ9ZS5pc0lkZW50aWZpZXJDaGFyPWZ1bmN0aW9uKGUpe3JldHVybiA0OD5lPzM2PT09ZTo1OD5lPyEwOjY1PmU/ITE6OTE+ZT8hMDo5Nz5lPzk1PT09ZToxMjM+ZT8hMDplPj0xNzAmJl90LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9LFp0PXtraW5kOlwibG9vcFwifSxlbj17a2luZDpcInN3aXRjaFwifX0pO1xuXG5cdHZhciBiaW5hcnlPcGVyYXRvcnMgPSB7XG5cdFx0JysnOiAnX19hZGQnLFxuXHRcdCctJzogJ19fc3VidHJhY3QnLFxuXHRcdCcqJzogJ19fbXVsdGlwbHknLFxuXHRcdCcvJzogJ19fZGl2aWRlJyxcblx0XHQnJSc6ICdfX21vZHVsbycsXG5cdFx0Jz09JzogJ2VxdWFscycsXG5cdFx0JyE9JzogJ2VxdWFscydcblx0fTtcblxuXHR2YXIgdW5hcnlPcGVyYXRvcnMgPSB7XG5cdFx0Jy0nOiAnX19uZWdhdGUnLFxuXHRcdCcrJzogbnVsbFxuXHR9O1xuXG5cdHZhciBmaWVsZHMgPSBCYXNlLmVhY2goXG5cdFx0WydhZGQnLCAnc3VidHJhY3QnLCAnbXVsdGlwbHknLCAnZGl2aWRlJywgJ21vZHVsbycsICduZWdhdGUnXSxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzWydfXycgKyBuYW1lXSA9ICcjJyArIG5hbWU7XG5cdFx0fSxcblx0XHR7fVxuXHQpO1xuXHRQb2ludC5pbmplY3QoZmllbGRzKTtcblx0U2l6ZS5pbmplY3QoZmllbGRzKTtcblx0Q29sb3IuaW5qZWN0KGZpZWxkcyk7XG5cblx0ZnVuY3Rpb24gX18kX18obGVmdCwgb3BlcmF0b3IsIHJpZ2h0KSB7XG5cdFx0dmFyIGhhbmRsZXIgPSBiaW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmIChsZWZ0ICYmIGxlZnRbaGFuZGxlcl0pIHtcblx0XHRcdHZhciByZXMgPSBsZWZ0W2hhbmRsZXJdKHJpZ2h0KTtcblx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gJyE9JyA/ICFyZXMgOiByZXM7XG5cdFx0fVxuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuIGxlZnQgKyByaWdodDtcblx0XHRjYXNlICctJzogcmV0dXJuIGxlZnQgLSByaWdodDtcblx0XHRjYXNlICcqJzogcmV0dXJuIGxlZnQgKiByaWdodDtcblx0XHRjYXNlICcvJzogcmV0dXJuIGxlZnQgLyByaWdodDtcblx0XHRjYXNlICclJzogcmV0dXJuIGxlZnQgJSByaWdodDtcblx0XHRjYXNlICc9PSc6IHJldHVybiBsZWZ0ID09IHJpZ2h0O1xuXHRcdGNhc2UgJyE9JzogcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gJF9fKG9wZXJhdG9yLCB2YWx1ZSkge1xuXHRcdHZhciBoYW5kbGVyID0gdW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmIChoYW5kbGVyICYmIHZhbHVlICYmIHZhbHVlW2hhbmRsZXJdKVxuXHRcdFx0cmV0dXJuIHZhbHVlW2hhbmRsZXJdKCk7XG5cdFx0c3dpdGNoIChvcGVyYXRvcikge1xuXHRcdGNhc2UgJysnOiByZXR1cm4gK3ZhbHVlO1xuXHRcdGNhc2UgJy0nOiByZXR1cm4gLXZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gc2NvcGUuYWNvcm4ucGFyc2UoY29kZSwgb3B0aW9ucyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21waWxlKGNvZGUsIHVybCwgb3B0aW9ucykge1xuXHRcdGlmICghY29kZSlcblx0XHRcdHJldHVybiAnJztcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR1cmwgPSB1cmwgfHwgJyc7XG5cblx0XHR2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KG9mZnNldCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnNlcnRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaW5zZXJ0aW9uID0gaW5zZXJ0aW9uc1tpXTtcblx0XHRcdFx0aWYgKGluc2VydGlvblswXSA+PSBvZmZzZXQpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdG9mZnNldCArPSBpbnNlcnRpb25bMV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvZGUobm9kZSkge1xuXHRcdFx0cmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcblx0XHRcdFx0XHRnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEJldHdlZW4obGVmdCwgcmlnaHQpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobGVmdC5yYW5nZVsxXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KHJpZ2h0LnJhbmdlWzBdKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZUNvZGUobm9kZSwgc3RyKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdGVuZCA9IGdldE9mZnNldChub2RlLnJhbmdlWzFdKSxcblx0XHRcdFx0aW5zZXJ0ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSBpbnNlcnRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChzdGFydCA+IGluc2VydGlvbnNbaV1bMF0pIHtcblx0XHRcdFx0XHRpbnNlcnQgPSBpICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5zZXJ0aW9ucy5zcGxpY2UoaW5zZXJ0LCAwLCBbc3RhcnQsIHN0ci5sZW5ndGggLSBlbmQgKyBzdGFydF0pO1xuXHRcdFx0Y29kZSA9IGNvZGUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHN0ciArIGNvZGUuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2Fsa0FTVChub2RlLCBwYXJlbnQpIHtcblx0XHRcdGlmICghbm9kZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5vZGUpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3JhbmdlJyB8fCBrZXkgPT09ICdsb2MnKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlW2tleV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdFx0d2Fsa0FTVCh2YWx1ZVtpXSwgbm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHdhbGtBU1QodmFsdWUsIG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gdW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUuYXJndW1lbnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCk7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJyRfXyhcIicgKyBub2RlLm9wZXJhdG9yICsgJ1wiLCAnXG5cdFx0XHRcdFx0XHRcdCsgYXJnICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuXHRcdFx0XHRpZiAobm9kZS5vcGVyYXRvciBpbiBiaW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KSxcblx0XHRcdFx0XHRcdGJldHdlZW4gPSBnZXRCZXR3ZWVuKG5vZGUubGVmdCwgbm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9IG5vZGUub3BlcmF0b3I7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJ19fJF9fKCcgKyBsZWZ0ICsgJywnXG5cdFx0XHRcdFx0XHRcdCsgYmV0d2Vlbi5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwnICsgb3BlcmF0b3IpLFxuXHRcdFx0XHRcdFx0XHRcdCdcIicgKyBvcGVyYXRvciArICdcIicpXG5cdFx0XHRcdFx0XHRcdCsgJywgJyArIHJpZ2h0ICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuXHRcdFx0Y2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuXHRcdFx0XHR2YXIgcGFyZW50VHlwZSA9IHBhcmVudCAmJiBwYXJlbnQudHlwZTtcblx0XHRcdFx0aWYgKCEoXG5cdFx0XHRcdFx0XHRwYXJlbnRUeXBlID09PSAnRm9yU3RhdGVtZW50J1xuXHRcdFx0XHRcdFx0fHwgcGFyZW50VHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdCYmIC9eWz0hPD5dLy50ZXN0KHBhcmVudC5vcGVyYXRvcilcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBwYXJlbnQuY29tcHV0ZWRcblx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdGlmIChub2RlLnR5cGUgPT09ICdVcGRhdGVFeHByZXNzaW9uJykge1xuXHRcdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCksXG5cdFx0XHRcdFx0XHRcdGV4cCA9ICdfXyRfXygnICsgYXJnICsgJywgXCInICsgbm9kZS5vcGVyYXRvclswXVxuXHRcdFx0XHRcdFx0XHRcdFx0KyAnXCIsIDEpJyxcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJyA9ICcgKyBleHA7XG5cdFx0XHRcdFx0XHRpZiAoIW5vZGUucHJlZml4XG5cdFx0XHRcdFx0XHRcdFx0JiYgKHBhcmVudFR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZ2V0Q29kZShwYXJlbnQubGVmdCB8fCBwYXJlbnQuaWQpID09PSBhcmcpXG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gZXhwO1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBhcmcgKyAnOyAnICsgc3RyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgc3RyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKC9eLj0kLy50ZXN0KG5vZGUub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHRcdFx0JiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCk7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIGxlZnQgKyAnID0gX18kX18oJyArIGxlZnQgKyAnLCBcIidcblx0XHRcdFx0XHRcdFx0XHRcdCsgbm9kZS5vcGVyYXRvclswXSArICdcIiwgJyArIHJpZ2h0ICsgJyknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBzb3VyY2VNYXAgPSBudWxsLFxuXHRcdFx0YnJvd3NlciA9IHBhcGVyLmJyb3dzZXIsXG5cdFx0XHR2ZXJzaW9uID0gYnJvd3Nlci52ZXJzaW9uTnVtYmVyLFxuXHRcdFx0bGluZUJyZWFrcyA9IC9cXHJcXG58XFxufFxcci9tZztcblx0XHRpZiAoYnJvd3Nlci5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzMFxuXHRcdFx0XHR8fCBicm93c2VyLndlYmtpdCAmJiB2ZXJzaW9uID49IDUzNy43NlxuXHRcdFx0XHR8fCBicm93c2VyLmZpcmVmb3ggJiYgdmVyc2lvbiA+PSAyMykge1xuXHRcdFx0dmFyIG9mZnNldCA9IDA7XG5cdFx0XHRpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZih1cmwpID09PSAwKSB7XG5cdFx0XHRcdHZhciBodG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXS5pbm5lckhUTUw7XG5cdFx0XHRcdG9mZnNldCA9IGh0bWwuc3Vic3RyKDAsIGh0bWwuaW5kZXhPZihjb2RlKSArIDEpLm1hdGNoKFxuXHRcdFx0XHRcdFx0bGluZUJyZWFrcykubGVuZ3RoICsgMTtcblx0XHRcdH1cblx0XHRcdHZhciBtYXBwaW5ncyA9IFsnQUFBQSddO1xuXHRcdFx0bWFwcGluZ3MubGVuZ3RoID0gKGNvZGUubWF0Y2gobGluZUJyZWFrcykgfHwgW10pLmxlbmd0aCArIDEgKyBvZmZzZXQ7XG5cdFx0XHRzb3VyY2VNYXAgPSB7XG5cdFx0XHRcdHZlcnNpb246IDMsXG5cdFx0XHRcdGZpbGU6IHVybCxcblx0XHRcdFx0bmFtZXM6W10sXG5cdFx0XHRcdG1hcHBpbmdzOiBtYXBwaW5ncy5qb2luKCc7QUFDQScpLFxuXHRcdFx0XHRzb3VyY2VSb290OiAnJyxcblx0XHRcdFx0c291cmNlczogW3VybF1cblx0XHRcdH07XG5cdFx0XHR2YXIgc291cmNlID0gb3B0aW9ucy5zb3VyY2UgfHwgIXVybCAmJiBjb2RlO1xuXHRcdFx0aWYgKHNvdXJjZSlcblx0XHRcdFx0c291cmNlTWFwLnNvdXJjZXNDb250ZW50ID0gW3NvdXJjZV07XG5cdFx0fVxuXHRcdHdhbGtBU1QocGFyc2UoY29kZSwgeyByYW5nZXM6IHRydWUgfSkpO1xuXHRcdGlmIChzb3VyY2VNYXApIHtcblx0XHRcdGNvZGUgPSBuZXcgQXJyYXkob2Zmc2V0ICsgMSkuam9pbignXFxuJykgKyBjb2RlXG5cdFx0XHRcdFx0KyBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCJcblx0XHRcdFx0XHQrIChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChcblx0XHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkpXG5cdFx0XHRcdFx0KyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyAodXJsIHx8ICdwYXBlcnNjcmlwdCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4ZWN1dGUoY29kZSwgc2NvcGUsIHVybCwgb3B0aW9ucykge1xuXHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0dmFyIHZpZXcgPSBzY29wZS5nZXRWaWV3KCksXG5cdFx0XHR0b29sID0gL1xccytvbig/OktleXxNb3VzZSkoPzpVcHxEb3dufE1vdmV8RHJhZylcXGIvLnRlc3QoY29kZSlcblx0XHRcdFx0XHQ/IG5ldyBUb29sKClcblx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHR0b29sSGFuZGxlcnMgPSB0b29sID8gdG9vbC5fZXZlbnRzIDogW10sXG5cdFx0XHRoYW5kbGVycyA9IFsnb25GcmFtZScsICdvblJlc2l6ZSddLmNvbmNhdCh0b29sSGFuZGxlcnMpLFxuXHRcdFx0cGFyYW1zID0gW10sXG5cdFx0XHRhcmdzID0gW10sXG5cdFx0XHRmdW5jO1xuXHRcdGNvZGUgPSBjb21waWxlKGNvZGUsIHVybCwgb3B0aW9ucyk7XG5cdFx0ZnVuY3Rpb24gZXhwb3NlKHNjb3BlLCBoaWRkZW4pIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBzY29wZSkge1xuXHRcdFx0XHRpZiAoKGhpZGRlbiB8fCAhL15fLy50ZXN0KGtleSkpICYmIG5ldyBSZWdFeHAoJyhbXFxcXGJcXFxcc1xcXFxXXXxeKSdcblx0XHRcdFx0XHRcdCsga2V5LnJlcGxhY2UoL1xcJC9nLCAnXFxcXCQnKSArICdcXFxcYicpLnRlc3QoY29kZSkpIHtcblx0XHRcdFx0XHRwYXJhbXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdGFyZ3MucHVzaChzY29wZVtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRleHBvc2UoeyBfXyRfXzogX18kX18sICRfXzogJF9fLCBwYXBlcjogc2NvcGUsIHZpZXc6IHZpZXcsIHRvb2w6IHRvb2wgfSxcblx0XHRcdFx0dHJ1ZSk7XG5cdFx0ZXhwb3NlKHNjb3BlKTtcblx0XHRoYW5kbGVycyA9IEJhc2UuZWFjaChoYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRpZiAobmV3IFJlZ0V4cCgnXFxcXHMrJyArIGtleSArICdcXFxcYicpLnRlc3QoY29kZSkpIHtcblx0XHRcdFx0cGFyYW1zLnB1c2goa2V5KTtcblx0XHRcdFx0dGhpcy5wdXNoKGtleSArICc6ICcgKyBrZXkpO1xuXHRcdFx0fVxuXHRcdH0sIFtdKS5qb2luKCcsICcpO1xuXHRcdGlmIChoYW5kbGVycylcblx0XHRcdGNvZGUgKz0gJ1xcbnJldHVybiB7ICcgKyBoYW5kbGVycyArICcgfTsnO1xuXHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcjtcblx0XHRpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5maXJlZm94KSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG5cdFx0XHRcdGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdFx0XHRpZiAoYnJvd3Nlci5maXJlZm94KVxuXHRcdFx0XHRjb2RlID0gJ1xcbicgKyBjb2RlO1xuXHRcdFx0c2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuXHRcdFx0XHQncGFwZXIuX2V4ZWN1dGUgPSBmdW5jdGlvbignICsgcGFyYW1zICsgJykgeycgKyBjb2RlICsgJ1xcbn0nXG5cdFx0XHQpKTtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHRcdGZ1bmMgPSBwYXBlci5fZXhlY3V0ZTtcblx0XHRcdGRlbGV0ZSBwYXBlci5fZXhlY3V0ZTtcblx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnVuYyA9IEZ1bmN0aW9uKHBhcmFtcywgY29kZSk7XG5cdFx0fVxuXHRcdHZhciByZXMgPSBmdW5jLmFwcGx5KHNjb3BlLCBhcmdzKSB8fCB7fTtcblx0XHRCYXNlLmVhY2godG9vbEhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHJlc1trZXldO1xuXHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHR0b29sW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRpZiAodmlldykge1xuXHRcdFx0aWYgKHJlcy5vblJlc2l6ZSlcblx0XHRcdFx0dmlldy5zZXRPblJlc2l6ZShyZXMub25SZXNpemUpO1xuXHRcdFx0dmlldy5lbWl0KCdyZXNpemUnLCB7XG5cdFx0XHRcdHNpemU6IHZpZXcuc2l6ZSxcblx0XHRcdFx0ZGVsdGE6IG5ldyBQb2ludCgpXG5cdFx0XHR9KTtcblx0XHRcdGlmIChyZXMub25GcmFtZSlcblx0XHRcdFx0dmlldy5zZXRPbkZyYW1lKHJlcy5vbkZyYW1lKTtcblx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHQpIHtcblx0XHRpZiAoL150ZXh0XFwvKD86eC18KXBhcGVyc2NyaXB0JC8udGVzdChzY3JpcHQudHlwZSlcblx0XHRcdFx0JiYgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnaWdub3JlJykgIT09ICd0cnVlJykge1xuXHRcdFx0dmFyIGNhbnZhc0lkID0gUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnY2FudmFzJyksXG5cdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKSxcblx0XHRcdFx0c3JjID0gc2NyaXB0LnNyYyB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpLFxuXHRcdFx0XHRhc3luYyA9IFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKHNjcmlwdCwgJ2FzeW5jJyksXG5cdFx0XHRcdHNjb3BlQXR0cmlidXRlID0gJ2RhdGEtcGFwZXItc2NvcGUnO1xuXHRcdFx0aWYgKCFjYW52YXMpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgY2FudmFzIHdpdGggaWQgXCInXG5cdFx0XHRcdFx0XHQrIGNhbnZhc0lkICsgJ1wiJyk7XG5cdFx0XHR2YXIgc2NvcGUgPSBQYXBlclNjb3BlLmdldChjYW52YXMuZ2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlKSlcblx0XHRcdFx0XHRcdHx8IG5ldyBQYXBlclNjb3BlKCkuc2V0dXAoY2FudmFzKTtcblx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUsIHNjb3BlLl9pZCk7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdEh0dHAucmVxdWVzdCgnZ2V0Jywgc3JjLCBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdFx0ZXhlY3V0ZShjb2RlLCBzY29wZSwgc3JjKTtcblx0XHRcdFx0fSwgYXN5bmMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhlY3V0ZShzY3JpcHQuaW5uZXJIVE1MLCBzY29wZSwgc2NyaXB0LmJhc2VVUkkpO1xuXHRcdFx0fVxuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1pZ25vcmUnLCAndHJ1ZScpO1xuXHRcdFx0cmV0dXJuIHNjb3BlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRBbGwoKSB7XG5cdFx0QmFzZS5lYWNoKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSwgbG9hZFNjcmlwdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkKHNjcmlwdCkge1xuXHRcdHJldHVybiBzY3JpcHQgPyBsb2FkU2NyaXB0KHNjcmlwdCkgOiBsb2FkQWxsKCk7XG5cdH1cblxuXHRpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdHNldFRpbWVvdXQobG9hZEFsbCk7XG5cdH0gZWxzZSB7XG5cdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgeyBsb2FkOiBsb2FkQWxsIH0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRjb21waWxlOiBjb21waWxlLFxuXHRcdGV4ZWN1dGU6IGV4ZWN1dGUsXG5cdFx0bG9hZDogbG9hZCxcblx0XHRwYXJzZTogcGFyc2Vcblx0fTtcblxufSkuY2FsbCh0aGlzKTtcblxucGFwZXIgPSBuZXcgKFBhcGVyU2NvcGUuaW5qZWN0KEJhc2UuZXhwb3J0cywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRCYXNlOiBCYXNlLFxuXHROdW1lcmljYWw6IE51bWVyaWNhbCxcblx0S2V5OiBLZXlcbn0pKSgpO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdGRlZmluZSgncGFwZXInLCBwYXBlcik7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHBhcGVyO1xufVxuXG5yZXR1cm4gcGFwZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2Jvd2VyX2NvbXBvbmVudHMvcGFwZXIvZGlzdC9wYXBlci1mdWxsLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFBhcGVyID0gcmVxdWlyZSgncGFwZXInKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZUNlbnRlcihvbGRDZW50ZXIsIG9mZnNldCwgZmFjdG9yKSB7XG4gIG9mZnNldCA9IG9mZnNldC5tdWx0aXBseShmYWN0b3IpO1xuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlWm9vbShvbGRab29tLCBkZWx0YSwgY2VudGVyLCBwb3NpdGlvbil7XG4gIHZhciBmYWN0b3IgPSAxLjA1XG4gIHZhciBuZXdab29tID0gZGVsdGEgPCAwID8gb2xkWm9vbSAqIGZhY3RvciA6IG9sZFpvb20gLyBmYWN0b3I7XG4gIHZhciBiZXRhID0gb2xkWm9vbSAvIG5ld1pvb207XG4gIHZhciBwYyA9IHBvc2l0aW9uLnN1YnRyYWN0KGNlbnRlcik7XG4gIHZhciBvZmZzZXQgPSBwb3NpdGlvbi5zdWJ0cmFjdChwYy5tdWx0aXBseShiZXRhKSkuc3VidHJhY3QoY2VudGVyKTtcbiAgcmV0dXJuIHtuZXdab29tLCBvZmZzZXR9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdmlld3MvdXRpbHMuanNcbiAqKi8iLCJ2YXIgUGFwZXIgPSByZXF1aXJlKCdwYXBlcicpO1xuXG52YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG5mdW5jdGlvbiByZW1vdmUoYW5pbWF0aW9uKXtcbiAgYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuZmlsdGVyKGEgPT4gYSAhPT0gYW5pbWF0aW9uKTtcbn1cblxuZnVuY3Rpb24gb25GcmFtZShldmVudCl7XG4gIGlmKGV2ZW50LmRlbHRhID09PSAwKSByZXR1cm47XG4gIGFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgIGFuaW1hdGlvbi5lbGFwc2VkVGltZSArPSBldmVudC5kZWx0YTtcbiAgICB2YXIgY29udGludWVBbmltYXRpb24gPSBhbmltYXRpb24uY2FsbGJhY2soYW5pbWF0aW9uLmVsYXBzZWRUaW1lKTtcbiAgICBpZihjb250aW51ZUFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJlbW92ZShhbmltYXRpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCl7XG4gIFBhcGVyLnZpZXcub25GcmFtZSA9IG9uRnJhbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY2FsbGJhY2spe1xuICB2YXIgYW5pbWF0aW9uID0ge1xuICAgIGNhbGxiYWNrLFxuICAgIGVsYXBzZWRUaW1lOiAwXG4gIH07XG4gIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICByZXR1cm4ge1xuICAgIHJlbW92ZTogKCkgPT4gcmVtb3ZlKGFuaW1hdGlvbilcbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL2FuaW1hdGlvbi5qc1xuICoqLyIsImZ1bmN0aW9uIEdldFVzZXJDb25maWcoKSB7XG4gIHZhciBjb25maWcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnVXNlckNvbmZpZycpO1xuICBpZighY29uZmlnKSB7XG4gICAgY29uZmlnID0ge307XG4gICAgU2V0VXNlckNvbmZpZyhjb25maWcpO1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIFNldFVzZXJDb25maWcoY29uZmlnKSB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdVc2VyQ29uZmlnJywgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7O1xufVxuXG5mdW5jdGlvbiBHZXRVc2VyQ29uZmlnVmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGNvbmZpZyA9IEdldFVzZXJDb25maWcoKTtcblxuICBpZihjb25maWdba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnW2tleV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgU2V0VXNlckNvbmZpZyhjb25maWcpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZ1trZXldO1xufVxuXG5mdW5jdGlvbiBTZXRVc2VyQ29uZmlnVmFsdWUoa2V5LCB2YWx1ZSkge1xuICB2YXIgY29uZmlnID0gR2V0VXNlckNvbmZpZygpO1xuICBjb25maWdba2V5XSA9IHZhbHVlO1xuICBTZXRVc2VyQ29uZmlnKGNvbmZpZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBHZXRNYXBzKCkge1xuICB2YXIgbWFwcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgIGlmKGtleS5pbmRleE9mKCdtYXAnKSA9PT0gMCkge1xuICAgICAgbWFwcy5wdXNoKEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXBzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQWRkTWFwKG1hcCkge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYXAua2V5LCBKU09OLnN0cmluZ2lmeShtYXApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlbW92ZU1hcChtYXApIHtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obWFwLmtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXROYnJPZlBsYXllcnMobmJyT2ZQbGF5ZXJzKSB7XG4gIFNldFVzZXJDb25maWdWYWx1ZSgnbmJyT2ZQbGF5ZXJzJywgbmJyT2ZQbGF5ZXJzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEdldE5ick9mUGxheWVycygpIHtcbiAgcmV0dXJuIEdldFVzZXJDb25maWdWYWx1ZSgnbmJyT2ZQbGF5ZXJzJywgMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBHZXRJc011dGVkKCkge1xuICByZXR1cm4gR2V0VXNlckNvbmZpZ1ZhbHVlKCdpc011dGVkJywgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0SXNNdXRlZChpc011dGVkKSB7XG4gIFNldFVzZXJDb25maWdWYWx1ZSgnaXNNdXRlZCcsIGlzTXV0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gR2V0RW5hYmxlU3RhcnMoKSB7XG4gIHJldHVybiBHZXRVc2VyQ29uZmlnVmFsdWUoJ2VuYWJsZVN0YXJzJywgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRFbmFibGVTdGFycyhlbmFibGVTdGFycykge1xuICBTZXRVc2VyQ29uZmlnVmFsdWUoJ2VuYWJsZVN0YXJzJywgZW5hYmxlU3RhcnMpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvc3RvcmFnZS5qc1xuICoqLyIsInJlcXVpcmUoJy4vbWFpbk1lbnUuY3NzJyk7XG52YXIgQ2xpY2tMaXN0ZW5lckhhbmRsZXIgPSByZXF1aXJlKCcuLi9jbGlja0xpc3RlbmVySGFuZGxlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluTWVudSB7XG4gIGNvbnN0cnVjdG9yKG9uRG9uZSwgcGFyYW1zKSB7XG4gICAgdGhpcy5tYWluTWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYWluTWVudScpO1xuICAgIHRoaXMubWFpbk1lbnUuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcblxuICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIgPSBuZXcgQ2xpY2tMaXN0ZW5lckhhbmRsZXIoKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmFkZChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHV6emxlTW9kZUJ1dHRvbicpLCAoKSA9PiBvbkRvbmUoeyB2aWV3OiAnUHV6emxlIG1lbnUnIH0pKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmFkZChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZnJlZU1vZGVCdXR0b24nKSwgKCkgPT4gb25Eb25lKHsgdmlldzogJ0ZyZWVwbGF5IG1lbnUnIH0pKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKXtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLm1haW5NZW51LnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdmlld3MvbWFpbk1lbnUvbWFpbk1lbnUuanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL21haW5NZW51LmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9tYWluTWVudS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9tYWluTWVudS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvbWFpbk1lbnUvbWFpbk1lbnUuY3NzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm1haW5NZW51IHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBhZGRpbmctdG9wOiAyM3Z3O1xcbiAgdG9wOiAwO1xcbiAgYm90dG9tOiAwO1xcbn1cXG5cXG4udGl0bGVUZXh0IHtcXG4gIGZvbnQtc2l6ZTogMTB2dztcXG4gIG1hcmdpbi1ib3R0b206IDV2dztcXG59XFxuXFxuLm1haW5NZW51QnV0dG9uIHtcXG4gIGZvbnQtc2l6ZTogMnZ3O1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5tYWluTWVudUJ1dHRvbiAuaWNvbntcXG4gIGRpc3BsYXk6IGlubGluZTtcXG4gIG9wYWNpdHk6IDE7XFxuICBmaWxsOiBjdXJyZW50Q29sb3I7XFxufVxcblxcbi5tYWluTWVudUJ1dHRvbi1wdXp6bGV7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDV2dztcXG4gIGxlZnQ6IDMwdnc7XFxufVxcblxcbi5tYWluTWVudUJ1dHRvbi1wdXp6bGUgLmljb257XFxuICBtYXJnaW4tcmlnaHQ6IDF2dztcXG59XFxuXFxuLm1haW5NZW51QnV0dG9uLWZyZWV7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDV2dztcXG4gIGxlZnQ6IDU0dnc7XFxufVxcblxcbi5tYWluTWVudUJ1dHRvbi1mcmVlIHN2ZyB7XFxuICBtYXJnaW4tcmlnaHQ6IDIuNXZ3O1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzMGRlZyk7XFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDMwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzBkZWcpO1xcbn1cXG5cXG4ubWFpbk1lbnVCdXR0b24gc3Zne1xcbiAgd2lkdGg6IDd2dztcXG4gIGhlaWdodDogN3Z3O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlciEuL3NyYy92aWV3cy9tYWluTWVudS9tYWluTWVudS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGF1ZGlvID0gcmVxdWlyZSgnLi4vYXVkaW8nKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpY2tMaXN0ZW5lckhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJzID0gW107XG4gIH1cblxuICBhZGQoZWxlbWVudCwgb25jbGljaykge1xuICAgIHZhciBjYWxsYmFjayA9IGV2ZW50ID0+IHtcbiAgICAgIGF1ZGlvLnBsYXlDbGljaygpO1xuICAgICAgb25jbGljayhldmVudCk7XG4gICAgfVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFjayk7XG4gICAgdGhpcy5jbGlja0xpc3RlbmVycy5wdXNoKHtlbGVtZW50LCBjYWxsYmFja30pO1xuICB9XG5cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5jbGlja0xpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBsaXN0ZW5lci5jYWxsYmFjaykpO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy92aWV3cy9jbGlja0xpc3RlbmVySGFuZGxlci5qc1xuICoqLyIsInZhciBzdG9yYWdlID0gcmVxdWlyZSgnLi9zdG9yYWdlJyk7XG5cbndpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG52YXIgY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbnZhciBtYXN0ZXJHYWluID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG5tYXN0ZXJHYWluLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG5tYXN0ZXJHYWluLmdhaW4udmFsdWUgPSBzdG9yYWdlLkdldElzTXV0ZWQoKSA/IDAgOiAwLjU7XG5cbmV4cG9ydCBmdW5jdGlvbiBUb2dnbGVJc011dGVkKCkge1xuICB2YXIgaXNNdXRlZCA9ICFzdG9yYWdlLkdldElzTXV0ZWQoKTtcbiAgc3RvcmFnZS5TZXRJc011dGVkKGlzTXV0ZWQpO1xuICBtYXN0ZXJHYWluLmdhaW4udmFsdWUgPSBpc011dGVkID8gMCA6IDAuNTtcbiAgcmV0dXJuIGlzTXV0ZWQ7XG59XG5cbnZhciBjbGljaztcbmxvYWRBcnJheUJ1ZmZlcignc291bmRzL2NsaWNrMi53YXYnLCBjb250ZXh0LCBidWZmZXIgPT4gY2xpY2sgPSBidWZmZXIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGxheUNsaWNrKCl7XG4gIHZhciBzb3VuZCA9IGNyZWF0ZVNvdXJjZUFuZEdhaW4oY2xpY2spO1xuICBzb3VuZC5nYWluTm9kZS5nYWluLnZhbHVlID0gMC41O1xuICBzb3VuZC5zb3VyY2Uuc3RhcnQoMCk7XG59XG5cbnZhciBhbWJpZW50U291bmRzID0gW107XG52YXIgYW1iaWVudFNvdW5kVXJscyA9IFtcbiAgJ3NvdW5kcy9zaXJlbnMtb2YtYW15Z2RhbGEud2F2JywgLy9odHRwOi8vZnJlZXNvdW5kLm9yZy9wZW9wbGUvRVJIL3NvdW5kcy8zMTA0MS9cbiAgJ3NvdW5kcy9ibGFzdGVyLTEud2F2JywgLy9odHRwOi8vZnJlZXNvdW5kLm9yZy9wZW9wbGUvRVJIL3NvdW5kcy8zMDMwNC9cbiAgJ3NvdW5kcy9ib29tLTIud2F2JywgLy9odHRwOi8vZnJlZXNvdW5kLm9yZy9wZW9wbGUvRVJIL3NvdW5kcy8zMDI2MS9cbiAgJ3NvdW5kcy9ib29tLTMud2F2JywgLy9odHRwOi8vZnJlZXNvdW5kLm9yZy9wZW9wbGUvRVJIL3NvdW5kcy8zMDI2Mi9cbiAgJ3NvdW5kcy93aW5kLm9nZycsIC8vaHR0cDovL2ZyZWVzb3VuZC5vcmcvcGVvcGxlL0JsYWNrJTIwQm9lL3NvdW5kcy8yMjMzMS9cbl07XG5hbWJpZW50U291bmRVcmxzLmZvckVhY2goXG4gICh1cmwsIGluZGV4KSA9PiBsb2FkQXJyYXlCdWZmZXIodXJsLCBjb250ZXh0LFxuICAgIGJ1ZmZlciA9PiB7XG4gICAgICBhbWJpZW50U291bmRzLnB1c2goYnVmZmVyKTtcbiAgICAgIGlmKGluZGV4ID09PSAwKSBzY2hlZHVsZUFtYmllbnRTb3VuZCgpO1xuICAgIH0pKTtcblxuZnVuY3Rpb24gc2NoZWR1bGVBbWJpZW50U291bmQoKXtcbiAgdmFyIGJ1ZmZlciA9IGFtYmllbnRTb3VuZHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYW1iaWVudFNvdW5kcy5sZW5ndGgpXTtcbiAgdmFyIGR1cmF0aW9uID0gYnVmZmVyLmR1cmF0aW9uO1xuICB2YXIgZmFkZVRpbWUgPSByYW5kb21JbnQoNSwgMTUpO1xuICB2YXIgc2lsZW5jZSA9IHJhbmRvbUludCg1LCAyNSk7XG5cbiAgdmFyIGdhaW4gPSByYW5kb20oMC4yLCAwLjUpO1xuICB2YXIgc291bmQgPSBjcmVhdGVTb3VyY2VBbmRHYWluKGJ1ZmZlcik7XG4gIHZhciBzb3VyY2UgPSBzb3VuZC5zb3VyY2U7XG4gIHZhciBnYWluTm9kZSA9IHNvdW5kLmdhaW5Ob2RlO1xuICB2YXIgY3VyclRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICBnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIGN1cnJUaW1lKTtcbiAgZ2Fpbk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShnYWluLCBjdXJyVGltZSArIGZhZGVUaW1lKTtcbiAgc291cmNlLnN0YXJ0KDApO1xuICBnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGdhaW4sIGN1cnJUaW1lICsgZHVyYXRpb24gLSBmYWRlVGltZSk7XG4gIGdhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgY3VyclRpbWUgKyBkdXJhdGlvbik7XG5cbiAgc2V0VGltZW91dCgoKSA9PiBzY2hlZHVsZUFtYmllbnRTb3VuZCgpLCAoZHVyYXRpb24gLSBmYWRlVGltZSArIHNpbGVuY2UpICogMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGxvYWRBcnJheUJ1ZmZlcih1cmwsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcXVlc3Qub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICByZXF1ZXN0Lm9ubG9hZCA9XG4gICAgKCkgPT4gY29udGV4dC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSxcbiAgICAgIGJ1ZmZlciA9PiBjYWxsYmFjayhidWZmZXIpLCBlcnJvciA9PiBjb25zb2xlLmxvZyhlcnJvcikpO1xuICByZXF1ZXN0LnNlbmQoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU291cmNlQW5kR2FpbihidWZmZXIpe1xuICB2YXIgZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgZ2Fpbk5vZGUuY29ubmVjdChtYXN0ZXJHYWluKTtcblxuICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgc291cmNlLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuICBzb3VyY2UuY29ubmVjdChtYXN0ZXJHYWluKTtcbiAgcmV0dXJuIHsgc291cmNlLCBnYWluTm9kZX07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb20obWluLCBtYXgpKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hdWRpby5qc1xuICoqLyIsInJlcXVpcmUoJy4vZnJlZXBsYXlNZW51LmNzcycpO1xudmFyIHZpZXcgPSByZXF1aXJlKCcuLi92aWV3Jyk7XG52YXIgYXVkaW8gPSByZXF1aXJlKCcuLi8uLi9hdWRpbycpO1xudmFyIHN0b3JhZ2UgPSByZXF1aXJlKCcuLi8uLi9zdG9yYWdlJyk7XG52YXIgcHJlcG9wID0gcmVxdWlyZSgnLi4vLi4vcHJlcG9wL21hcFByZXBvcHVsYXRvcicpO1xudmFyIENsaWNrTGlzdGVuZXJIYW5kbGVyID0gcmVxdWlyZSgnLi4vY2xpY2tMaXN0ZW5lckhhbmRsZXInKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnJlZXBsYXlNZW51e1xuICBjb25zdHJ1Y3RvcihvbkRvbmUsIHBhcmFtcyl7XG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlciA9IG5ldyBDbGlja0xpc3RlbmVySGFuZGxlcigpO1xuICAgIHRoaXMuc2VsZWN0ZWRNYXBJbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWxlY3RlZE1hcEltYWdlJyk7XG4gICAgdGhpcy5tYXBzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21hcHMnKTtcblxuICAgIHZpZXcucmVzZXQoKTtcbiAgICB0aGlzLm9uRG9uZSA9IG9uRG9uZTtcblxuICAgIHZhciBtYXBzID0gc3RvcmFnZS5HZXRNYXBzKCk7XG4gICAgaWYoIW1hcHMubGVuZ3RoKSB7XG4gICAgICBwcmVwb3AucHJlcG9wdWxhdGVNYXBzKG1hcHMgPT4gdGhpcy5zZXRNYXBzKG1hcHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRNYXBzKG1hcHMpO1xuICAgIH1cblxuICAgIHRoaXMubmJyT2ZQbGF5ZXJzRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNuYnJPZlBsYXllcnMnKTtcbiAgICB0aGlzLm5ick9mUGxheWVyc0VsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy5uYnJPZlBsYXllcnM7XG5cbiAgICB0aGlzLm11dGVCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbXV0ZUJ1dHRvbicpO1xuICAgIGlmKHN0b3JhZ2UuR2V0SXNNdXRlZCgpKSB7XG4gICAgICB0aGlzLm11dGVCdXR0b24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlci5hZGQodGhpcy5tdXRlQnV0dG9uLCAoKSA9PiB0aGlzLnRvZ2dsZUlzTXV0ZWQoKSk7XG5cbiAgICB0aGlzLnN0YXJzQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3N0YXJzQnV0dG9uJyk7XG4gICAgaWYoc3RvcmFnZS5HZXRFbmFibGVTdGFycygpKSB7XG4gICAgICB0aGlzLnN0YXJzQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgfVxuICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIuYWRkKHRoaXMuc3RhcnNCdXR0b24sICgpID0+IHRoaXMudG9nZ2xlU3RhcnNWaXNpYmlsaXR5KCkpO1xuXG4gICAgdGhpcy5mcmVlcGxheU1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZnJlZXBsYXlNZW51Jyk7XG4gICAgdGhpcy5mcmVlcGxheU1lbnUuc3R5bGUudmlzaWJpbGl0eSA9ICdpbml0aWFsJztcblxuICAgIHZhciBjcmVhdGVNYXBCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY3JlYXRlTWFwQnV0dG9uJyk7XG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlci5hZGQoY3JlYXRlTWFwQnV0dG9uLCAoKSA9PiB0aGlzLm9uRG9uZSh7IHZpZXc6ICdDcmVhdGUgbWFwJyB9KSk7XG5cbiAgICB2YXIgZmV3ZXJQbGF5ZXJzQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2Zld2VyUGxheWVyc0J1dHRvbicpO1xuICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIuYWRkKGZld2VyUGxheWVyc0J1dHRvbiwgKCkgPT4gdGhpcy5uYnJPZlBsYXllcnMtLSk7XG5cbiAgICB2YXIgbW9yZVBsYXllcnNCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbW9yZVBsYXllcnNCdXR0b24nKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmFkZChtb3JlUGxheWVyc0J1dHRvbiwgKCkgPT4gdGhpcy5uYnJPZlBsYXllcnMrKyk7XG5cbiAgICB2YXIgZWRpdE1hcEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNlZGl0TWFwQnV0dG9uJyk7XG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlci5hZGQoZWRpdE1hcEJ1dHRvbiwgKCkgPT4gdGhpcy5vbkRvbmUoeyB2aWV3OiAnQ3JlYXRlIG1hcCcsIHBhcmFtczogdGhpcy5zZWxlY3RlZE1hcCB9KSk7XG5cbiAgICB2YXIgZGVsZXRlTWFwQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlbGV0ZU1hcEJ1dHRvbicpO1xuICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIuYWRkKGRlbGV0ZU1hcEJ1dHRvbiwgKCkgPT4gdGhpcy5yZW1vdmVDdXJyZW50TWFwKCkpO1xuXG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlci5hZGQoc2VsZWN0ZWRNYXBJbWFnZSwgKCkgPT4ge1xuICAgICAgdGhpcy5vbkRvbmUoe1xuICAgICAgICB2aWV3OiAnR2FtZScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1hcDogdGhpcy5zZWxlY3RlZE1hcC5tYXAsXG4gICAgICAgICAgbnJiT2ZQbGF5ZXJzOiB0aGlzLm5ick9mUGxheWVyc1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgc2V0TWFwcyhtYXBzKSB7XG4gICAgdGhpcy5zYXZlZE1hcHMgPSBtYXBzO1xuICAgIHRoaXMuc2VsZWN0ZWRNYXAgPSB0aGlzLnNhdmVkTWFwc1swXTtcbiAgICB0aGlzLnJlbmRlck1hcHNMaXN0KCk7XG4gIH1cblxuICBnZXQgbmJyT2ZQbGF5ZXJzKCl7XG4gICAgcmV0dXJuIHN0b3JhZ2UuR2V0TmJyT2ZQbGF5ZXJzKCk7XG4gIH1cblxuICBzZXQgbmJyT2ZQbGF5ZXJzKHZhbHVlKXtcbiAgICB2YXIgbmJyT2ZQbGF5ZXJzID0gTWF0aC5tYXgoMSwgTWF0aC5taW4odmFsdWUsIDQpKTtcbiAgICBzdG9yYWdlLlNldE5ick9mUGxheWVycyhuYnJPZlBsYXllcnMpO1xuICAgIHRoaXMubmJyT2ZQbGF5ZXJzRWxlbWVudC5pbm5lclRleHQgPSBuYnJPZlBsYXllcnM7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRNYXBfO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkTWFwKHZhbHVlKSB7XG4gICAgdGhpcy5zZWxlY3RlZE1hcF8gPSB2YWx1ZTtcbiAgICB0aGlzLnNlbGVjdGVkTWFwSW1hZ2Uuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLnNlbGVjdGVkTWFwXy5kYXRhVVJMKTtcbiAgfVxuXG4gIHRvZ2dsZUlzTXV0ZWQoKXtcbiAgICB2YXIgaXNNdXRlZCA9IGF1ZGlvLlRvZ2dsZUlzTXV0ZWQoKTtcbiAgICBpZihpc011dGVkKSB7XG4gICAgICB0aGlzLm11dGVCdXR0b24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tdXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlU3RhcnNWaXNpYmlsaXR5KCkge1xuICAgIHZhciBuZXdTdGFyc1Zpc2liaWxpdHkgPSB2aWV3LnRvZ2dsZVN0YXJzVmlzaWJpbGl0eSgpO1xuICAgIGlmKG5ld1N0YXJzVmlzaWJpbGl0eSkge1xuICAgICAgdGhpcy5zdGFyc0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJzQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQ3VycmVudE1hcCgpe1xuICAgIGlmKHRoaXMuc2VsZWN0ZWRNYXApIHN0b3JhZ2UuUmVtb3ZlTWFwKHRoaXMuc2VsZWN0ZWRNYXApO1xuXG4gICAgdGhpcy5zYXZlZE1hcHMgPSBzdG9yYWdlLkdldE1hcHMoKTtcbiAgICBpZih0aGlzLnNhdmVkTWFwcy5sZW5ndGggPiAwKSB0aGlzLnNlbGVjdGVkTWFwID0gdGhpcy5zYXZlZE1hcHNbMF07XG4gICAgdGhpcy5jbGVhck1hcHNMaXN0KCk7XG4gICAgdGhpcy5yZW5kZXJNYXBzTGlzdCgpO1xuICB9XG5cbiAgcmVuZGVyTWFwc0xpc3QoKXtcbiAgICB0aGlzLnNhdmVkTWFwcy5mb3JFYWNoKChtYXAsIGluZGV4KSA9PiB7XG4gICAgICBpZihpbmRleCA9PT0gMCkgdGhpcy5zZWxlY3RlZE1hcCA9IG1hcDtcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIGltZy5zcmMgPSBtYXAuZGF0YVVSTDtcbiAgICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIuYWRkKGltZywgKCkgPT4gdGhpcy5zZWxlY3RlZE1hcCA9IG1hcCk7XG4gICAgICB0aGlzLm1hcHMuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFyTWFwc0xpc3QoKXtcbiAgICB3aGlsZSAodGhpcy5tYXBzLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMubWFwcy5yZW1vdmVDaGlsZCh0aGlzLm1hcHMubGFzdENoaWxkKTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCl7XG4gICAgdGhpcy5mcmVlcGxheU1lbnUuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgIHRoaXMuY2xlYXJNYXBzTGlzdCgpO1xuICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy92aWV3cy9mcmVlcGxheU1lbnUvZnJlZXBsYXlNZW51LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9mcmVlcGxheU1lbnUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL2ZyZWVwbGF5TWVudS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9mcmVlcGxheU1lbnUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2ZyZWVwbGF5TWVudS9mcmVlcGxheU1lbnUuY3NzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2ZyZWVwbGF5TWVudSB7XFxuICB0b3A6IDV2dztcXG4gIGJvdHRvbTogNXZ3O1xcbiAgcGFkZGluZzogMXZ3O1xcbn1cXG5cXG4ubWFwc01lbnUge1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtYXJnaW4tdG9wOiAxdnc7XFxuICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxuICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5tYXBzTWVudSA+ICoge1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbiNjcmVhdGVNYXBCdXR0b24ge1xcbiAgZm9udC1zaXplOiA1dnc7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLnNlbGVjdGVkTWFwIHtcXG4gIG1hcmdpbi1sZWZ0OiAxdnc7XFxufVxcblxcbi5zZWxlY3RlZE1hcCBpbWcge1xcbiAgd2lkdGg6IDQwdnc7XFxuICBoZWlnaHQ6IDQwdnc7XFxufVxcblxcbiNjcmVhdGVNYXBCdXR0b24sICNtYXBzIGltZyB7XFxuICB3aWR0aDogOXZ3O1xcbiAgaGVpZ2h0OiA5dnc7XFxufVxcblxcbiNtYXBzICogKyAqIHtcXG4gIG1hcmdpbi10b3A6IDF2dztcXG59XFxuXFxuLm1hcENvbnRyb2xzIHtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxuICBmb250LXNpemU6IDIwcHg7XFxufVxcblxcbmltZyB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlciEuL3NyYy92aWV3cy9mcmVlcGxheU1lbnUvZnJlZXBsYXlNZW51LmNzc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RvcmFnZSA9IHJlcXVpcmUoJy4uL3N0b3JhZ2UnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBvcHVsYXRlTWFwcyhjYikge1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsICdzcmMvcHJlcG9wL2RhdGEuanNvbicsIHRydWUpO1xuICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgcmVxdWVzdC5vbmxvYWQgPVxuICAgICgpID0+IHtcbiAgICAgIHZhciBtYXBzID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIG1hcHMuZm9yRWFjaChtYXAgPT4gc3RvcmFnZS5BZGRNYXAobWFwKSk7XG4gICAgICBjYihtYXBzKTtcbiAgICB9XG4gIHJlcXVlc3Quc2VuZCgpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcHJlcG9wL21hcFByZXBvcHVsYXRvci5qc1xuICoqLyIsInJlcXVpcmUoJy4vbWFwRWRpdG9yLmNzcycpO1xudmFyIFBhcGVyID0gcmVxdWlyZSgncGFwZXInKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnLi4vdmlldycpO1xudmFyIGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbicpO1xudmFyIGF1ZGlvID0gcmVxdWlyZSgnLi4vLi4vYXVkaW8nKTtcbnZhciBDbGlja0xpc3RlbmVySGFuZGxlciA9IHJlcXVpcmUoJy4uL2NsaWNrTGlzdGVuZXJIYW5kbGVyJyk7XG52YXIgc3RvcmFnZSA9IHJlcXVpcmUoJy4uLy4uL3N0b3JhZ2UnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwRWRpdG9ye1xuICBjb25zdHJ1Y3RvcihvbkRvbmUsIHBhcmFtcyl7XG4gICAgdGhpcy5vbkRvbmUgPSBvbkRvbmU7XG5cbiAgICBpZihwYXJhbXMpIHtcbiAgICAgIHRoaXMua2V5ID0gcGFyYW1zLmtleTtcbiAgICAgIHRoaXMudHJhY2sgPSBQYXBlci5wcm9qZWN0LmltcG9ydEpTT04ocGFyYW1zLm1hcC50cmFjayk7XG4gICAgICB0aGlzLnN0YXJ0ID0gUGFwZXIucHJvamVjdC5pbXBvcnRKU09OKHBhcmFtcy5tYXAuc3RhcnQpO1xuICAgICAgdGhpcy5lbmQgPSBQYXBlci5wcm9qZWN0LmltcG9ydEpTT04ocGFyYW1zLm1hcC5lbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYWNrID0gbmV3IFBhcGVyLlBhdGgoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSBuZXcgUGFwZXIuUGF0aCgpO1xuICAgICAgdGhpcy5lbmQgPSBuZXcgUGFwZXIuUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLnRvb2xzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndHJhY2snLFxuICAgICAgICBjb2xvcjogJ3B1cnBsZScsXG4gICAgICAgIHBhdGg6IHRoaXMudHJhY2ssXG4gICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjcmVhdGVUcmFja0J1dHRvbicpLFxuICAgICAgICBpbml0OiBuZXdDaXJjbGUgPT4gbmV3Q2lyY2xlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICBjb2xvcjogJ2dyZWVuJyxcbiAgICAgICAgcGF0aDogdGhpcy5zdGFydCxcbiAgICAgICAgZWxlbWVudDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NyZWF0ZVN0YXJ0QnV0dG9uJyksXG4gICAgICAgIGluaXQ6IG5ld0NpcmNsZSA9PiB0aGlzLmdldFRvb2woJ3RyYWNrJykucGF0aC5pbnRlcnNlY3QobmV3Q2lyY2xlKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgIGNvbG9yOiAneWVsbG93JyxcbiAgICAgICAgcGF0aDogdGhpcy5lbmQsXG4gICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjcmVhdGVFbmRCdXR0b24nKSxcbiAgICAgICAgaW5pdDogbmV3Q2lyY2xlID0+IHRoaXMuZ2V0VG9vbCgndHJhY2snKS5wYXRoLmludGVyc2VjdChuZXdDaXJjbGUpXG4gICAgICB9XG4gICAgXTtcbiAgICB0aGlzLnRvb2xzLmZvckVhY2godG9vbCA9PiB0b29sLnBhdGguZmlsbENvbG9yID0gdG9vbC5jb2xvcik7XG5cbiAgICB0aGlzLmNvdXJzZSA9IG5ldyBQYXBlci5Hcm91cCh0aGlzLnRyYWNrLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgdmlldy5hZGRDb3Vyc2UodGhpcy5jb3Vyc2UpO1xuXG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlciA9IG5ldyBDbGlja0xpc3RlbmVySGFuZGxlcigpO1xuICAgIHRoaXMudG9vbHMuZm9yRWFjaCh0b29sID0+XG4gICAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmFkZCh0b29sLmVsZW1lbnQsICgpID0+IHRoaXMuc2VsZWN0ZWRUb29sID0gdG9vbC5uYW1lKSk7XG5cbiAgICB0aGlzLm1hcEVkaXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYXBFZGl0b3InKTtcbiAgICB0aGlzLm1hcEVkaXRvci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXG4gICAgdGhpcy5tb3VzZUNvbnRyb2xzID0gbmV3IFBhcGVyLlRvb2woKTtcbiAgICB0aGlzLm1vdXNlQ29udHJvbHMub25Nb3VzZURvd24gPSBlID0+IHtcbiAgICAgIGF1ZGlvLnBsYXlDbGljaygpO1xuICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICB9XG4gICAgdGhpcy5tb3VzZUNvbnRyb2xzLm9uTW91c2VEcmFnID0gZSA9PiB0aGlzLm9uTW91c2VEcmFnKGUpO1xuXG4gICAgdGhpcy5zYXZlTWFwQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NhdmVNYXBCdXR0b24nKTtcbiAgICB0aGlzLnNhdmVNYXBCdXR0b24uY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmFkZCh0aGlzLnNhdmVNYXBCdXR0b24sICgpID0+IHRoaXMuZG9uZSgpKTtcbiAgICB0aGlzLmV4aXRNYXBFZGl0b3JCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZXhpdE1hcEVkaXRvckJ1dHRvbicpO1xuICAgIHRoaXMuY2xpY2tMaXN0ZW5lckhhbmRsZXIuYWRkKHRoaXMuZXhpdE1hcEVkaXRvckJ1dHRvbiwgKCkgPT4gdGhpcy5vbkRvbmUoeyB2aWV3OiAnTWFpbiBtZW51JyB9KSk7XG5cbiAgICB0aGlzLmJydXNoQnV0dG9ucyA9IFsnI2JydXNoU2l6ZTEnLCAnI2JydXNoU2l6ZTInLCAnI2JydXNoU2l6ZTMnXVxuICAgICAgLm1hcChidXR0b25TZWxlY3RvciA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJ1dHRvblNlbGVjdG9yKSk7XG4gICAgdGhpcy5icnVzaEJ1dHRvbnNcbiAgICAgIC5mb3JFYWNoKChlbGVtZW50LCBpKSA9PiB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmFkZChlbGVtZW50LCAoKSA9PiB0aGlzLmJydXNoc2l6ZSA9IGkgKyAxKSk7XG5cbiAgICB0aGlzLmJydXNoc2l6ZSA9IDI7XG4gICAgdGhpcy5zZWxlY3RlZFRvb2wgPSAndHJhY2snO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGVkVG9vbCgpe1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkVG9vbF87XG4gIH1cblxuICBzZXQgc2VsZWN0ZWRUb29sKHZhbHVlKXtcbiAgICB0aGlzLnNlbGVjdGVkVG9vbF8gPSB2YWx1ZTtcbiAgICB0aGlzLnNldEJ1dHRvblN0YXRlcygpO1xuICB9XG5cbiAgZ2V0IGJydXNoc2l6ZSgpe1xuICAgIHJldHVybiB0aGlzLmJydXNoc2l6ZV8gKiAyMDtcbiAgfVxuXG4gIHNldCBicnVzaHNpemUodmFsdWUpe1xuICAgIHRoaXMuYnJ1c2hzaXplXyA9IHZhbHVlO1xuICAgIHRoaXMuYnJ1c2hCdXR0b25zLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpO1xuICAgIHRoaXMuYnJ1c2hCdXR0b25zW3ZhbHVlIC0gMV0uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgfVxuXG4gIGdldFRvb2wobmFtZSl7XG4gICAgcmV0dXJuIHRoaXMudG9vbHMuZmlsdGVyKHRvb2wgPT4gdG9vbC5uYW1lID09PSBuYW1lKVswXVxuICB9XG5cbiAgc2V0QnV0dG9uU3RhdGVzKCkge1xuICAgIGlmKCF0aGlzLmdldFRvb2woJ3RyYWNrJykucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuZ2V0VG9vbCgnc3RhcnQnKS5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkaXNhYmxlZFwiKTtcbiAgICAgIHRoaXMuZ2V0VG9vbCgnZW5kJykuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZGlzYWJsZWRcIik7XG4gICAgfVxuXG4gICAgaWYodGhpcy50b29scy5maWx0ZXIodG9vbCA9PiB0b29sLnBhdGguaXNFbXB0eSgpKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2F2ZU1hcEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIHRoaXMudG9vbHMuZm9yRWFjaCh0b29sID0+IHRvb2wuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIikpO1xuICAgIHRoaXMuZ2V0VG9vbCh0aGlzLnNlbGVjdGVkVG9vbCkuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gIH1cblxuICBvbk1vdXNlRG93bihldmVudCkge1xuICAgIHZhciB0b29sID0gdGhpcy5nZXRUb29sKHRoaXMuc2VsZWN0ZWRUb29sKTtcbiAgICBpZih0b29sLnBhdGguYXJlYSA8IDUwKXtcbiAgICAgIHRoaXMucmVtb3ZlUGF0aCh0b29sLnBhdGgpO1xuICAgICAgdmFyIHBhdGggPSBuZXcgUGFwZXIuUGF0aC5DaXJjbGUoZXZlbnQucG9pbnQsIHRoaXMuYnJ1c2hzaXplKTtcbiAgICAgIHRvb2wucGF0aCA9IHBhdGg7XG4gICAgICB0b29sLnBhdGguZmlsbENvbG9yID0gdG9vbC5jb2xvcjtcbiAgICAgIHRvb2wucGF0aC5zaW1wbGlmeSgpO1xuICAgICAgdGhpcy5jb3Vyc2UuYWRkQ2hpbGQodG9vbC5wYXRoKTtcbiAgICB9XG4gICAgdGhpcy5pc0FkZGluZyA9IHRvb2wucGF0aC5jb250YWlucyhldmVudC5wb2ludCk7XG4gICAgdGhpcy5zZXRCdXR0b25TdGF0ZXMoKTtcbiAgfVxuXG4gIG9uTW91c2VEcmFnKGV2ZW50KSB7XG4gICAgdmFyIGVkaXRDaXJjbGUgPSBuZXcgUGFwZXIuUGF0aC5DaXJjbGUoZXZlbnQucG9pbnQsIHRoaXMuYnJ1c2hzaXplKTtcbiAgICB2YXIgdG9vbCA9IHRoaXMuZ2V0VG9vbCh0aGlzLnNlbGVjdGVkVG9vbCk7XG5cbiAgICB2YXIgbmV3UGF0aCA9IHRoaXMuaXNBZGRpbmcgPyB0b29sLnBhdGgudW5pdGUoZWRpdENpcmNsZSkgOiB0b29sLnBhdGguc3VidHJhY3QoZWRpdENpcmNsZSk7XG4gICAgdGhpcy5yZW1vdmVQYXRoKGVkaXRDaXJjbGUpO1xuICAgIHRoaXMucmVtb3ZlUGF0aCh0b29sLnBhdGgpO1xuICAgIHRvb2wucGF0aCA9IG5ld1BhdGg7XG4gICAgdG9vbC5wYXRoLmZpbGxDb2xvciA9IHRvb2wuY29sb3I7XG4gICAgdGhpcy5zZXRCdXR0b25TdGF0ZXMoKTtcbiAgfVxuXG4gIHJlbW92ZVBhdGgocGF0aCl7XG4gICAgcGF0aC5yZW1vdmUoKTtcbiAgICBpZihwYXRoLnJlbW92ZVNlZ21lbnRzKXtcbiAgICAgIHBhdGgucmVtb3ZlU2VnbWVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gYy5yZW1vdmVTZWdtZW50cygpKTtcbiAgICAgIHBhdGgucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICB9O1xuICB9XG5cbiAgZG9uZSgpe1xuICAgIHZhciB0cmFjayA9IHRoaXMuZ2V0VG9vbCgndHJhY2snKTtcbiAgICB0aGlzLnRvb2xzXG4gICAgICAuZmlsdGVyKHRvb2wgPT4gdG9vbC5uYW1lICE9ICd0cmFjaycpXG4gICAgICAuZm9yRWFjaCh0b29sID0+IHtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0cmFjay5wYXRoLnVuaXRlKHRvb2wucGF0aCk7XG4gICAgICAgIHRyYWNrLnBhdGgucmVtb3ZlKCk7XG4gICAgICAgIHRyYWNrLnBhdGggPSBuZXdQYXRoO1xuICAgICAgfSk7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHRoaXMudG9vbHMuZm9yRWFjaCh0b29sID0+IG1hcFt0b29sLm5hbWVdID0gdG9vbC5wYXRoLnRvSlNPTigpKTtcblxuICAgIHZhciBkYXRhVVJMID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzJykudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgIHZhciBrZXkgPSB0aGlzLmtleSA/IHRoaXMua2V5IDogJ21hcC0nICsgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgc3RvcmFnZS5BZGRNYXAoeyBkYXRhVVJMLCBtYXAsIGtleSB9KTtcbiAgICB0aGlzLm9uRG9uZSh7IHZpZXc6ICdNYWluIG1lbnUnIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpe1xuICAgIHRoaXMuY291cnNlLnJlbW92ZSgpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVlbmQnLCB0aGlzLmdlc3R1cmVlbmRMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9zZXdoZWVsJywgdGhpcy5tb3VzZXdoZWVsTGlzdGVuZXIpO1xuICAgIHRoaXMubW91c2VDb250cm9scy5yZW1vdmUoKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLm1hcEVkaXRvci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL21hcEVkaXRvci9tYXBFZGl0b3IuanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL21hcEVkaXRvci5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vbWFwRWRpdG9yLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL21hcEVkaXRvci5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvbWFwRWRpdG9yL21hcEVkaXRvci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjbWFwRWRpdG9yIHtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG1hcmdpbjogMXZ3O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1zaXplOiAxLjJ2dztcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTI4LCAxMjgsIDAuMik7XFxuICBib3JkZXI6IDFweCBzb2xpZCB3aGl0ZTtcXG4gIHRvcDogMzB2dztcXG59XFxuXFxuI21hcEVkaXRvciA+ICoge1xcbiAgcGFkZGluZzogMXZ3O1xcbn1cXG5cXG4jbWFwRWRpdG9yID4gKiArICoge1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHdoaXRlO1xcbn1cXG5cXG4ubWFwRWRpdG9yU3RlcHMgPiAqIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4ubWFwRWRpdG9yU3RlcHMgPiAqICsgKiB7XFxuICBtYXJnaW4tdG9wOiAxdnc7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyIS4vc3JjL3ZpZXdzL21hcEVkaXRvci9tYXBFZGl0b3IuY3NzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vZ2FtZUd1aS5jc3MnKTtcbnZhciBQYXBlciA9IHJlcXVpcmUoJ3BhcGVyJyk7XG52YXIgUGxheWVyID0gcmVxdWlyZSgnLi9wbGF5ZXInKTtcbnZhciBHYW1lID0gcmVxdWlyZSgnLi4vLi4vZ2FtZS9nYW1lJyk7XG52YXIgdmlldyA9IHJlcXVpcmUoJy4uL3ZpZXcnKTtcbnZhciBhbmltYXRpb24gPSByZXF1aXJlKCcuLi9hbmltYXRpb24nKTtcbnZhciBhdWRpbyA9IHJlcXVpcmUoJy4uLy4uL2F1ZGlvJyk7XG52YXIgQ2xpY2tMaXN0ZW5lckhhbmRsZXIgPSByZXF1aXJlKCcuLi9jbGlja0xpc3RlbmVySGFuZGxlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lR3Vpe1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgcGFyYW1zKXtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5nYW1lO1xuICAgIHRoaXMubmJyT2ZQbGF5ZXJzID0gcGFyYW1zLm5yYk9mUGxheWVycztcbiAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICB0aGlzLnBsYXllckNvbmZpZ3MgPSBbXG4gICAgICB7IG5hbWU6ICdZZWxsb3cnLCBjb2xvcjogJyNmZmZmMDAnIH0sXG4gICAgICB7IG5hbWU6ICdCbHVlJywgY29sb3I6ICcjMDAwMGZmJyB9LFxuICAgICAgeyBuYW1lOiAnUmVkJywgY29sb3I6ICcjZmYwMDAwJyB9LFxuICAgICAgeyBuYW1lOiAnR3JlZW4nLCBjb2xvcjogJyMwMGZmMDAnIH0sXG4gICAgXVxuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgUGFwZXIuR3JvdXAoKTtcbiAgICB0aGlzLmNvbnRyb2xBbmltYXRpb25zID0gW107XG4gICAgdGhpcy5mb3JlR3JvdW5kID0gbmV3IFBhcGVyLkdyb3VwKFt0aGlzLmNvbnRyb2xzXSk7XG4gICAgdGhpcy5jb3Vyc2UgPSBuZXcgUGFwZXIuR3JvdXAoKTtcbiAgICB0aGlzLm1vdXNlQ29udHJvbHMgPSBuZXcgUGFwZXIuVG9vbCgpO1xuICAgIHRoaXMubW91c2VDb250cm9scy5vbk1vdXNlRG93biA9IGUgPT4gdGhpcy5hZGRQbGF5ZXJDbGlja0V2ZW50KGUpO1xuXG4gICAgdGhpcy5nYW1lID0gbmV3IEdhbWUocGFyYW1zLm1hcCk7XG5cbiAgICB2YXIgdHJhY2sgPSB0aGlzLmdhbWUudHJhY2s7XG4gICAgdHJhY2suZmlsbENvbG9yID0gJ3B1cnBsZSc7XG4gICAgdmFyIHN0YXJ0QXJlYSA9IHRoaXMuZ2FtZS5zdGFydDtcbiAgICBzdGFydEFyZWEuZmlsbENvbG9yID0gJ2dyZWVuJztcbiAgICB2YXIgZW5kQXJlYSA9IHRoaXMuZ2FtZS5lbmQ7XG4gICAgZW5kQXJlYS5maWxsQ29sb3IgPSAneWVsbG93JztcblxuICAgIHRoaXMuY291cnNlLmFkZENoaWxkKHRyYWNrKTtcbiAgICB0aGlzLmNvdXJzZS5hZGRDaGlsZChzdGFydEFyZWEpO1xuICAgIHRoaXMuY291cnNlLmFkZENoaWxkKGVuZEFyZWEpO1xuICAgIHZpZXcuYWRkQ291cnNlKHRoaXMuY291cnNlKTtcblxuICAgIHRoaXMuc2V0Vmlld1RvU3RhcnQoKTtcblxuICAgIHRoaXMubW91c2V3aGVlbExpc3RlbmVyID0gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50LndoZWVsRGVsdGEgPT09IDApIHJldHVybjtcbiAgICAgIHRoaXMubW91c2V3aGVlbChldmVudC53aGVlbERlbHRhIDwgMCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmdlc3R1cmVlbmRMaXN0ZW5lciA9IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVlbmQnLCBlID0+IHRoaXMubW91c2V3aGVlbChlLnNjYWxlIDwgMSksIGZhbHNlKTtcblxuICAgIHRoaXMuZ2FtZUd1aSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNnYW1lR3VpJyk7XG4gICAgdGhpcy5lbmRHYW1lQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VuZEdhbWVCdXR0b24nKTtcbiAgICB0aGlzLmVuZEdhbWVUZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VuZEdhbWVUZXh0Jyk7XG5cbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyID0gbmV3IENsaWNrTGlzdGVuZXJIYW5kbGVyKCk7XG4gICAgdGhpcy5jbGlja0xpc3RlbmVySGFuZGxlci5hZGQoZW5kR2FtZUJ1dHRvbiwgKCkgPT4gdGhpcy5lbmRHYW1lQnV0dG9uTGlzdGVuZXIoKSk7XG4gIH1cblxuICBnZXQgY3VycmVudFBsYXllcigpe1xuICAgIHJldHVybiB0aGlzLnBsYXllcnNbdGhpcy5nYW1lLmN1cnJlbnRQbGF5ZXJJbmRleF07XG4gIH1cblxuICBhZGRQbGF5ZXJDbGlja0V2ZW50KGV2ZW50KXtcbiAgICBhdWRpby5wbGF5Q2xpY2soKTtcbiAgICB2YXIgeCA9IE1hdGgucm91bmQoZXZlbnQucG9pbnQueCAvIDIwKSAqIDIwO1xuICAgIHZhciB5ID0gTWF0aC5yb3VuZChldmVudC5wb2ludC55IC8gMjApICogMjA7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBhcGVyLlBvaW50KHgsIHkpO1xuICAgIGlmKHRoaXMuZ2FtZS5zdGFydC5jb250YWlucyhwb2ludCkpe1xuICAgICAgdGhpcy5nYW1lLmFkZFBsYXllcihwb2ludCwgbmV3IFBhcGVyLlBvaW50KDAsIDApKTtcbiAgICAgIHRoaXMucGxheWVycy5wdXNoKG5ldyBQbGF5ZXIodGhpcy5wbGF5ZXJDb25maWdzLnBvcCgpLCBwb2ludCkpO1xuICAgICAgaWYodGhpcy5wbGF5ZXJzLmxlbmd0aCA9PT0gdGhpcy5uYnJPZlBsYXllcnMpe1xuICAgICAgICB0aGlzLnN0YXJ0R2FtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXJ0R2FtZSgpe1xuICAgIHRoaXMucGxheWVycy5mb3JFYWNoKHAgPT4gdGhpcy5mb3JlR3JvdW5kLmFwcGVuZEJvdHRvbShwLmVsZW1lbnRzKSk7XG4gICAgdGhpcy5tb3VzZUNvbnRyb2xzLm9uTW91c2VEb3duID0gZSA9PiB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgIHRoaXMuZ2FtZS5zdGFydEdhbWUoKTtcbiAgICB0aGlzLmRyYXdDb250cm9scygpO1xuICB9XG5cbiAgb25Nb3VzZURvd24oZXZlbnQpe1xuICAgIGF1ZGlvLnBsYXlDbGljaygpO1xuICAgIHZhciBpdGVtID0gZXZlbnQuZ2V0SXRlbSgpO1xuICAgIGlmKCFpdGVtKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZW1DbGlja2VkID0gaXRlbS5oaXRUZXN0KGV2ZW50LnBvaW50KS5pdGVtO1xuICAgIGlmKGl0ZW1DbGlja2VkICYmIGl0ZW1DbGlja2VkLm1vdmVQbGF5ZXJEYXRhKXtcbiAgICAgIHRoaXMubW92ZVBsYXllcihpdGVtQ2xpY2tlZC5tb3ZlUGxheWVyRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgbW91c2V3aGVlbChzaG91bGRab29tT3V0KXtcbiAgICBpZihzaG91bGRab29tT3V0KSB7XG4gICAgICB0aGlzLnNldFZpZXdUb1RyYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCF0aGlzLmdhbWUuY3VycmVudFBsYXllcikge1xuICAgICAgICB0aGlzLnNldFZpZXdUb1N0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFZpZXdUb0NvbnRyb2xzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbW92ZVBsYXllcihyZWxhdGl2ZVZlY3Rvcil7XG4gICAgdmFyIGd1aVBsYXllciA9IHRoaXMucGxheWVyc1t0aGlzLmdhbWUuY3VycmVudFBsYXllckluZGV4XTtcbiAgICB2YXIgcGxheWVyID0gdGhpcy5nYW1lLm1vdmVQbGF5ZXIocmVsYXRpdmVWZWN0b3IpO1xuICAgIGd1aVBsYXllci5hZGRQb3NpdGlvbihwbGF5ZXIucG9zaXRpb24pO1xuICAgIGlmKHBsYXllci5pc0luRW5kWm9uZSl7XG4gICAgICB2YXIgbW92ZXMgPSBwbGF5ZXIucG9zaXRpb25zLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLmVuZEdhbWUoJ0dhbWUgb3ZlciwgJyArIGd1aVBsYXllci5uYW1lLnRvTG93ZXJDYXNlKCkgKyAnIHBsYXllciB3b24gaW4gJyArIG1vdmVzICsgJyBtb3ZlcyEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXh0VHVybigpO1xuICAgIH1cbiAgfVxuXG4gIG5leHRUdXJuKCl7XG4gICAgdGhpcy5nYW1lLm5leHRUdXJuKCk7XG4gICAgdGhpcy5jbGVhckNvbnRyb2xzKCk7XG5cbiAgICBpZih0aGlzLmdhbWUuZ2FtZU92ZXIoKSkge1xuICAgICAgdGhpcy5lbmRHYW1lKCdFdmVyeWJvZHkgY3Jhc2hlZCwgeW91IGFsbCBsb3N0IScpO1xuICAgIH0gZWxzZSBpZighdGhpcy5nYW1lLmN1cnJlbnRQbGF5ZXIuaXNBbGl2ZSl7XG4gICAgICB0aGlzLm5leHRUdXJuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd0NvbnRyb2xzKCk7XG4gICAgfVxuICB9XG5cbiAgZHJhd0NvbnRyb2xzKCl7XG4gICAgdmFyIGNpcmNsZXMgPSB0aGlzLmdhbWUudmVjdG9yc0ZvckNvbnRyb2xzLm1hcChjb250cm9sT2JqZWN0ID0+IHRoaXMuY3JlYXRlQ29udHJvbChjb250cm9sT2JqZWN0KSk7XG4gICAgdGhpcy5jb250cm9sQW5pbWF0aW9ucyA9IGNpcmNsZXMubWFwKGNpcmNsZSA9PiBhbmltYXRpb24uYWRkKGVsYXBzZWRUaW1lID0+IHtcbiAgICAgIGNpcmNsZS5zY2FsZSgxICsgKE1hdGguc2luKGVsYXBzZWRUaW1lICogMTApIC8gMTAwKSk7XG4gICAgfSkpO1xuICAgIGNpcmNsZXMuZm9yRWFjaChjaXJjbGUgPT4gdGhpcy5jb250cm9scy5hZGRDaGlsZChjaXJjbGUpKTtcbiAgICB0aGlzLnNldFZpZXdUb0NvbnRyb2xzKCk7XG4gIH1cblxuICBjbGVhckNvbnRyb2xzKCl7XG4gICAgdGhpcy5jb250cm9scy5yZW1vdmVDaGlsZHJlbigpO1xuICAgIHRoaXMuY29udHJvbEFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4gYW5pbWF0aW9uLnJlbW92ZSgpKTtcbiAgfVxuXG4gIHNldFZpZXdUb1N0YXJ0KCkge1xuICAgIHZpZXcuc2V0Vmlldyh0aGlzLmdhbWUuc3RhcnQuYm91bmRzLmV4cGFuZCgyMDApKTtcbiAgfVxuXG4gIHNldFZpZXdUb0NvbnRyb2xzKCl7XG4gICAgdmFyIHBsYXllckJvdW5kcyA9IHRoaXMuY29udHJvbHMuYm91bmRzLmluY2x1ZGUodGhpcy5nYW1lLmN1cnJlbnRQbGF5ZXIucG9zaXRpb24pO1xuICAgIHZpZXcuc2V0VmlldyhwbGF5ZXJCb3VuZHMuZXhwYW5kKDIwMCkpO1xuICB9XG5cbiAgc2V0Vmlld1RvVHJhY2soKXtcbiAgICB2aWV3LnNldFZpZXcodGhpcy5nYW1lLnRyYWNrLmJvdW5kcyk7XG4gIH1cblxuICBjcmVhdGVDb250cm9sKGNvbnRyb2xPYmplY3Qpe1xuICAgIHZhciBjaXJjbGUgPSB0aGlzLmN1cnJlbnRQbGF5ZXIuY3JlYXRlUG9zaXRpb25FbGVtZW50KGNvbnRyb2xPYmplY3QuYWJzb2x1dGUsIHRoaXMuY3VycmVudFBsYXllci5yYWRpdXMpO1xuICAgIGNpcmNsZS5tb3ZlUGxheWVyRGF0YSA9IGNvbnRyb2xPYmplY3QucmVsYXRpdmU7XG4gICAgY2lyY2xlLm9wYWNpdHkgPSAwLjU7XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuXG4gIGVuZEdhbWUodGV4dCl7XG4gICAgdGhpcy5jbGVhckNvbnRyb2xzKCk7XG4gICAgdGhpcy5nYW1lR3VpLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgdGhpcy5lbmRHYW1lVGV4dC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH1cblxuICBlbmRHYW1lQnV0dG9uTGlzdGVuZXIoKSB7XG4gICAgdGhpcy5jYWxsYmFjayh7IHZpZXc6ICdNYWluIG1lbnUnIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpe1xuICAgIHRoaXMuY291cnNlLnJlbW92ZSgpO1xuICAgIHRoaXMuZm9yZUdyb3VuZC5yZW1vdmUoKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdnZXN0dXJlZW5kJywgdGhpcy5nZXN0dXJlZW5kTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vc2V3aGVlbCcsIHRoaXMubW91c2V3aGVlbExpc3RlbmVyKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmdhbWVHdWkuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgIHRoaXMuZW5kR2FtZVRleHQudGV4dENvbnRlbnQgPSAnJztcbiAgICB0aGlzLm1vdXNlQ29udHJvbHMucmVtb3ZlKCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL2dhbWVHdWkvZ2FtZUd1aS5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vZ2FtZUd1aS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vZ2FtZUd1aS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9nYW1lR3VpLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9nYW1lR3VpL2dhbWVHdWkuY3NzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2dhbWVHdWkge1xcbiAgdG9wOiA1dnc7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5lbmRHYW1lTWVzc2FnZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEyOCwgMTI4LCAwLjIpO1xcbiAgYm9yZGVyOiAxcHggc29saWQgd2hpdGU7XFxuICBwYWRkaW5nOiAxdnc7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbi5lbmRHYW1lVGV4dCB7XFxuICBtYXJnaW4tYm90dG9tOiAxdnc7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyIS4vc3JjL3ZpZXdzL2dhbWVHdWkvZ2FtZUd1aS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFBhcGVyID0gcmVxdWlyZSgncGFwZXInKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVye1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIHBvc2l0aW9uKXtcbiAgICB0aGlzLmNvbG9yID0gY29uZmlnLmNvbG9yO1xuICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIHRoaXMucmFkaXVzID0gNTtcbiAgICB0aGlzLnBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMucGF0aCA9IG5ldyBQYXBlci5QYXRoKHtcbiAgICAgIHN0cm9rZUNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAuNVxuICAgIH0pO1xuICAgIHRoaXMuY2lyY2xlcyA9IG5ldyBQYXBlci5Hcm91cCgpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgUGFwZXIuR3JvdXAoW3RoaXMucGF0aCwgdGhpcy5jaXJjbGVzXSk7XG5cbiAgICB0aGlzLmFkZFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfVxuXG4gIGFkZFBvc2l0aW9uKHBvc2l0aW9uKXtcbiAgICB0aGlzLnBhdGguYWRkKHBvc2l0aW9uKTtcbiAgICB0aGlzLnBhdGguc21vb3RoKCk7XG5cbiAgICB0aGlzLmNpcmNsZXMucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICB0aGlzLnBvc2l0aW9uc1xuICAgICAgLm1hcCgocCwgaW5kZXgpID0+IHRoaXMuY3JlYXRlUG9zaXRpb25FbGVtZW50KHAsIHRoaXMucmFkaXVzICogKGluZGV4ICsgMSkgLyB0aGlzLnBvc2l0aW9ucy5sZW5ndGgpKVxuICAgICAgLmZvckVhY2goY2lyY2xlID0+IHRoaXMuY2lyY2xlcy5hZGRDaGlsZChjaXJjbGUpKTtcbiAgfVxuXG4gIGNyZWF0ZVBvc2l0aW9uRWxlbWVudChwb3NpdGlvbiwgcmFkaXVzKXtcbiAgICB2YXIgY2lyY2xlID0gbmV3IFBhcGVyLlBhdGguQ2lyY2xlKHBvc2l0aW9uLCByYWRpdXMpO1xuICAgIGNpcmNsZS5maWxsQ29sb3IgPSAnYmxhY2snO1xuICAgIGNpcmNsZS5zdHJva2VDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY2lyY2xlLnN0cm9rZVdpZHRoID0gMC41O1xuICAgIHJldHVybiBjaXJjbGU7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL2dhbWVHdWkvcGxheWVyLmpzXG4gKiovIiwidmFyIENhciA9IHJlcXVpcmUoJy4vY2FyJyk7XG52YXIgUGFwZXIgPSByZXF1aXJlKCdwYXBlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1le1xuICBjb25zdHJ1Y3RvcihtYXApe1xuICAgIHRoaXMuc2NhbGUgPSAyMDtcbiAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICB0aGlzLnRyYWNrID0gUGFwZXIucHJvamVjdC5pbXBvcnRKU09OKG1hcC50cmFjayk7XG4gICAgdGhpcy5zdGFydCA9IFBhcGVyLnByb2plY3QuaW1wb3J0SlNPTihtYXAuc3RhcnQpO1xuICAgIHRoaXMuZW5kID0gUGFwZXIucHJvamVjdC5pbXBvcnRKU09OKG1hcC5lbmQpO1xuICAgIHRoaXMuY3VycmVudFBsYXllckluZGV4ID0gMDtcbiAgICB0aGlzLnZlY3RvcnNGb3JDb250cm9scyA9IFtdO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQbGF5ZXIoKXtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJzW3RoaXMuY3VycmVudFBsYXllckluZGV4XTtcbiAgfVxuXG4gIHN0YXJ0R2FtZSgpe1xuICAgIHRoaXMuc2V0VmVjdG9yc0ZvckNvbnRyb2xzKCk7XG4gIH1cblxuICBzZXRWZWN0b3JzRm9yQ29udHJvbHMoKXtcbiAgICB2YXIgcGxheWVyID0gdGhpcy5jdXJyZW50UGxheWVyO1xuICAgIHZhciB2ZWN0b3JzRm9yQ29udHJvbHMgPSBbXTtcbiAgICBmb3IodmFyIHkgPSAxOyB5ID49IC0xOyB5LS0pe1xuICAgICAgZm9yKHZhciB4ID0gLTE7IHggPD0gMTsgeCsrKXtcbiAgICAgICAgdmFyIHBsYXllclJlbGF0aXZlVmVjdG9yID0gbmV3IFBhcGVyLlBvaW50KHRoaXMuc2NhbGUgKiB4LCB0aGlzLnNjYWxlICogeSkuY2xvbmUoKS5hZGQocGxheWVyLmRpcmVjdGlvbik7XG4gICAgICAgIHZhciBhYnNvbHV0ZVZlY3RvciA9IHBsYXllclJlbGF0aXZlVmVjdG9yLmNsb25lKCkuYWRkKHBsYXllci5wb3NpdGlvbik7XG4gICAgICAgIGlmKHRoaXMuaXNQb3NzaWJsZVBvc2l0aW9uKGFic29sdXRlVmVjdG9yKSkge1xuICAgICAgICAgIHZlY3RvcnNGb3JDb250cm9scy5wdXNoKHtcbiAgICAgICAgICAgIHJlbGF0aXZlOiBwbGF5ZXJSZWxhdGl2ZVZlY3RvcixcbiAgICAgICAgICAgIGFic29sdXRlOiBhYnNvbHV0ZVZlY3RvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodmVjdG9yc0ZvckNvbnRyb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGxheWVyLmlzQWxpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlY3RvcnNGb3JDb250cm9scyA9IHZlY3RvcnNGb3JDb250cm9scztcbiAgfVxuXG4gIGFkZFBsYXllcihwb2ludCwgZGlyZWN0aW9uKXtcbiAgICB0aGlzLnBsYXllcnMucHVzaChuZXcgQ2FyKHBvaW50LCBkaXJlY3Rpb24pKTtcbiAgfVxuXG4gIG1vdmVQbGF5ZXIodmVjdG9yKXtcbiAgICB0aGlzLmN1cnJlbnRQbGF5ZXIubW92ZSh2ZWN0b3IpO1xuICAgIHZhciBwbGF5ZXIgPSB0aGlzLmN1cnJlbnRQbGF5ZXI7XG4gICAgcGxheWVyLmlzSW5FbmRab25lID0gdGhpcy5pc0luWm9uZSh0aGlzLmVuZCwgcGxheWVyLnBvc2l0aW9uKTtcbiAgICByZXR1cm4gcGxheWVyO1xuICB9XG5cbiAgbmV4dFR1cm4oKXtcbiAgICB0aGlzLnNldE5leHRQbGF5ZXIoKTtcbiAgICB0aGlzLnNldFZlY3RvcnNGb3JDb250cm9scygpO1xuICB9XG5cbiAgc2V0TmV4dFBsYXllcigpe1xuICAgIHRoaXMuY3VycmVudFBsYXllckluZGV4Kys7XG4gICAgaWYodGhpcy5jdXJyZW50UGxheWVySW5kZXggPT09IHRoaXMucGxheWVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudFBsYXllckluZGV4ID0gMDtcbiAgICB9XG4gIH1cblxuICBpc1Bvc3NpYmxlUG9zaXRpb24odikge1xuICAgIHZhciBjYXJzT25UaGlzUG9zaXRpb24gPSB0aGlzLnBsYXllcnMuZmlsdGVyKHAgPT4gcC5wb3NpdGlvbi5jbG9uZSgpLnN1YnRyYWN0KHYpLmxlbmd0aCA9PT0gMCk7XG4gICAgdmFyIG5vT3RoZXJDYXJzID0gY2Fyc09uVGhpc1Bvc2l0aW9uLmxlbmd0aCA9PT0gMDtcbiAgICB2YXIgaXNPblRyYWNrID0gdGhpcy50cmFjay5jb250YWlucyh2KTtcbiAgICByZXR1cm4gbm9PdGhlckNhcnMgJiYgaXNPblRyYWNrO1xuICB9XG5cbiAgaXNJblpvbmUoem9uZSwgcG9zaXRpb24pe1xuICAgIHJldHVybiB6b25lLmNvbnRhaW5zKHBvc2l0aW9uKTtcbiAgfVxuXG4gIGdhbWVPdmVyKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcnMuZmlsdGVyKHAgPT4gcC5pc0FsaXZlKS5sZW5ndGggPT09IDA7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2dhbWUvZ2FtZS5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIENhciB7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBkaXJlY3Rpb24pe1xuICAgIHRoaXMucG9zaXRpb25zID0gW3Bvc2l0aW9uXTtcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbkluZGV4ID0gMDtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB0aGlzLmlzQWxpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNJbkVuZFpvbmUgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1t0aGlzLmN1cnJlbnRQb3NpdGlvbkluZGV4XTtcbiAgfVxuXG4gIHNldCBwb3NpdGlvbih2YWx1ZSl7XG4gICAgdGhpcy5wb3NpdGlvbnMucHVzaCh2YWx1ZSk7XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb25JbmRleCsrO1xuICB9XG5cbiAgbW92ZSh2ZWN0b3IpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpLmFkZCh2ZWN0b3IpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gdmVjdG9yO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9nYW1lL2Nhci5qc1xuICoqLyIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXNlIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXG5cdFx0XHRcdC8vIElzc3VlIDEyMDogdG91Y2guaWRlbnRpZmllciBpcyAwIHdoZW4gQ2hyb21lIGRldiB0b29scyAnRW11bGF0ZSB0b3VjaCBldmVudHMnIGlzIHNldCB3aXRoIGFuIGlPUyBkZXZpY2UgVUEgc3RyaW5nLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYWxsIHRvdWNoIGV2ZW50cyB0byBiZSBpZ25vcmVkLiBBcyB0aGlzIGJsb2NrIG9ubHkgYXBwbGllcyB0byBpT1MsIGFuZCBpT1MgaWRlbnRpZmllcnMgYXJlIGFsd2F5cyBsb25nLFxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXG5cdFx0XHRcdGlmICh0b3VjaC5pZGVudGlmaWVyICYmIHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMubGFzdFRvdWNoSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgKHVzaW5nIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgYW5kOlxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXG5cdFx0XHRcdC8vIDIpIHRoZSB1c2VyIHN0b3BzIHRoZSBmbGluZyBzY3JvbGwgd2l0aCBhbm90aGVyIHRhcFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBldmVudC50YXJnZXQgb2YgdGhlIGxhc3QgJ3RvdWNoZW5kJyBldmVudCB3aWxsIGJlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHVuZGVyIHRoZSB1c2VyJ3MgZmluZ2VyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xuXHRcdFx0XHQvLyBpcyBtYWRlIHRvIGVuc3VyZSB0aGF0IGEgcGFyZW50IGxheWVyIHdhcyBub3Qgc2Nyb2xsZWQgYmVmb3JlIHNlbmRpbmcgYSBzeW50aGV0aWMgY2xpY2sgKGlzc3VlICM0MikuXG5cdFx0XHRcdHRoaXMudXBkYXRlU2Nyb2xsUGFyZW50KHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSBldmVudC50aW1lU3RhbXA7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblxuXHRcdHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS50b3VjaEhhc01vdmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XG5cblx0XHRpZiAoTWF0aC5hYnModG91Y2gucGFnZVggLSB0aGlzLnRvdWNoU3RhcnRYKSA+IGJvdW5kYXJ5IHx8IE1hdGguYWJzKHRvdWNoLnBhZ2VZIC0gdGhpcy50b3VjaFN0YXJ0WSkgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xuXHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQgIT09IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpIHx8IHRoaXMudG91Y2hIYXNNb3ZlZChldmVudCkpIHtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGxhYmVsbGVkIGNvbnRyb2wgZm9yIHRoZSBnaXZlbiBsYWJlbCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxMYWJlbEVsZW1lbnR9IGxhYmVsRWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uKGxhYmVsRWxlbWVudCkge1xuXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LmNvbnRyb2w7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGJyb3dzZXJzIHVuZGVyIHRlc3QgdGhhdCBzdXBwb3J0IHRvdWNoIGV2ZW50cyBhbHNvIHN1cHBvcnQgdGhlIEhUTUw1IGh0bWxGb3IgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxFbGVtZW50Lmh0bWxGb3IpO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIGZvciBhdHRyaWJ1dGUgZXhpc3RzLCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBmaXJzdCBsYWJlbGxhYmxlIGRlc2NlbmRhbnQgZWxlbWVudFxuXHRcdC8vIHRoZSBsaXN0IG9mIHdoaWNoIGlzIGRlZmluZWQgaGVyZTogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbFxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBlbmQsIGRldGVybWluZSB3aGV0aGVyIHRvIHNlbmQgYSBjbGljayBldmVudCBhdCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGZvckVsZW1lbnQsIHRyYWNraW5nQ2xpY2tTdGFydCwgdGFyZ2V0VGFnTmFtZSwgc2Nyb2xsUGFyZW50LCB0b3VjaCwgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudDtcblxuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvdXIgb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gRmFzdENsaWNrO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBGYXN0Q2xpY2suYXR0YWNoO1xuXHRcdG1vZHVsZS5leHBvcnRzLkZhc3RDbGljayA9IEZhc3RDbGljaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xuXHR9XG59KCkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmFzdGNsaWNrL2xpYi9mYXN0Y2xpY2suanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==